;;*****************************************************************************
;;
;; File:        replicator.dbl
;;
;; Type:        Application (replicator)
;;
;; Description: Replicates Synergy data file changes that have been recorded
;;              in the replucation log file to a SQL Server database.
;;
;;*****************************************************************************
;;
;; Copyright (c) 2008, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import SynPSG.ReplicationDemo

main replicator

    .include "CONNECTDIR:ssql.def"
    .include "GENSRC:structureio.def"
    .include "REPLICATION" repository, record="instruction", end

    .define D_MAX_CUR       20
    .define D_MAX_COL       200
    .define D_MAX_BUFFER    4096

    .define D_TRANS_FILE    "DAT:replication.ism"
    .define D_SLEEP_TIME    60                  ;;Seconds to sleep
    .define D_ERROR_TIME    0.5                 ;;Time to sleep after an error

    .define log(x)          writes(logch,%TimeStamp+%atrim(x))
    .define debuglog(x)     if (fullLogging) writes(logch,%TimeStamp+%atrim(x))

    global common
        db                  ,i4                 ;;Database channel
        nsid                ,i4                 ;;Name space id
        tch                 ,i4                 ;;Instruction file channel
        logch               ,i4                 ;;Log file channel
        inserts             ,i4                 ;;Create operations completed
        updates             ,i4                 ;;Update operations completed
        deletes             ,i4                 ;;Delete operations completed
        fails               ,i4                 ;;Failed operations
        runningOnTerminal   ,boolean            ;;Program is running on a terminal
    endcommon

    record local_data
        ok                  ,boolean            ;;Main status
        db_connect          ,string             ;;Database connect string
        sleep_time          ,i4                 ;;Seconds to sleep
        errnum              ,i4                 ;;Error number
        nsptr               ,i4                 ;;Namespace pointer
        dberr               ,i4                 ;;Database error
        length              ,i4                 ;;Length of buffer
        status              ,i4                 ;;General working status return
        noMoreInstructions  ,boolean            ;;End of instruction file
        rows                ,i4                 ;;Number of rows affected
        success_count       ,i4                 ;;Bulk load success count
        fail_count          ,i4                 ;;Bulk load failure count
        fullLogging         ,boolean            ;;Are we doing full logging?
        logKeys             ,boolean            ;;Include key data in debug logs
        switchMode          ,boolean            ;;Switched from INSERT to UPDATE or vice versa
        logLoadExceptions   ,boolean            ;;Log bulk load exceptions to a log file?
        cycleLog            ,boolean            ;;Cycle the log file
        functionName        ,a40                ;;External function to call
        log_file            ,string             ;;Name of log file (or TT:)
        log_mode            ,a3
        databuffer          ,a(D_MAX_BUFFER)
        dberrtxt            ,a1024
        primaryKey          ,string             ;;Primary key of current record
        shutdownCommand     ,a3
    endrecord

    record structure_data
        structure_name      ,a30                ;;Name of structure
        structure_chan      ,i4                 ;;ISAM channel being used
        structure_size      ,i4                 ;;Record length
        structure_keynum    ,i4                 ;;Key number of unique key
    endrecord

    external function
        xsubr               ,^val
    endexternal

proc

    init local_data
    ok = true
    xcall flags(7004020,1)

    xcall openelb("EXE:library.elb")

    runningOnTerminal = (%tnmbr>=0)

    ;;Set the sleep time between processing runs
    xcall getlog("REPLICATOR_INTERVAL",databuffer,length)
    if (length) then
        sleep_time = databuffer(1:length)
    else
        sleep_time = D_SLEEP_TIME

    ;;Set the logging level
    xcall getlog("REPLICATOR_FULL_LOG",databuffer,length)
    fullLogging = ((length>0)&&(databuffer.eq."YES"))

    ;;Should we log keys?
    xcall getlog("REPLICATOR_LOG_KEYS",databuffer,length)
    logKeys = ((length>0)&&(databuffer.eq."YES"))

    ;;Should we log data exceptions to a log file when doing a bulk load?
    xcall getlog("REPLICATOR_LOG_BULK_LOAD_EXCEPTIONS",databuffer,length)
    logLoadExceptions = ((length>0)&&(databuffer.eq."YES"))

    ;;Open the log
    call OpenLogFile

    ;;Open the instruction file
    if (ok)
    begin
        try
        begin
            open(tch=0,U:I,D_TRANS_FILE)
        end
        catch (ex)
        begin
            log("ERROR: Failed to open " + D_TRANS_FILE)
            ok = false
        end
        endtry
    end

    ;;Get the database connect string from the logical REPLICATOR_DATABASE
    if (ok)
    begin
        xcall getlog("REPLICATOR_DATABASE",databuffer,length)
        if (length) then
        begin
            db_connect = databuffer(1:length)
            log("Database connect : " + db_connect)
        end
        else
        begin
            ;;No connect string, we're dead!
            log("ERROR: No database connect string was found. Define environment variable REPLICATOR_DATABASE.")
            ok = false
        end
    end

    ;;Enable and Initialize SQL Connection
    if (ok)
    begin
        .ifdef OS_VMS
        xcall init_ssql
        .else
        status = %option(48,1)
        .endc
        if (%ssc_init(db=1,D_MAX_CUR,D_MAX_COL,D_MAX_BUFFER)==SSQL_FAILURE)
        begin
            log("ERROR: Failed to initialize SQL Connection")
            ok = false
        end
    end

    ;;Connect to the database
    if (ok)
    begin
        debuglog("Connecting to database")
        if (%ssc_connect(db,db_connect)==SSQL_FAILURE)
        begin
            xcall ssc_getemsg(db,dberrtxt,length)
            log("ERROR: Failed to connect to database")
            log(" -     Connect string: " + db_connect)
            log(" -     Error message : " + dberrtxt(1,length))
            ok = false
        end
    end

    ;;Register a shutdown handler
    if (ok && !runningOnTerminal)
        xcall syn_atexit(%xaddr("ReplicatorShutdown"))

    ;;Main processing
    if (ok)
    begin
        ;;Create a namespace to record information about Synergy data files
        ;;that we have opened.
        nsid = %nspc_open(,%size(structure_data))

        log("")
        log("Ready to process instructions...")
        log("------------------------------------------------------------")

        ;;Main loop
        repeat
        begin
            ;;Check for outstanding instructions
            call GetInstruction

            if (noMoreInstructions) then
            begin
                if (runningOnTerminal)
                    debuglog("Sleeping for " + %string(sleep_time) + " seconds...")
                sleep sleep_time
            end
            else
            begin
                ;;If this is a routine request (create/update/delete) then do
                ;;file and table checks to ensure we have the file open and the
                ;;database table exists
                if ( (instruction.action==(i)REPLICATION_INSTRUCTION.CREATE_ROW)
                & || (instruction.action==(i)REPLICATION_INSTRUCTION.UPDATE_ROW)
                & || (instruction.action==(i)REPLICATION_INSTRUCTION.DELETE_ROW)
                &   )
                begin
                    ;;Check if we already have the file open
                    call CheckFileTable

                    ;;If we don't have the file open by now then we probably have a
                    ;;configuration problem, so abort processing
                    if (!structure_data.structure_chan)
                    begin
                        log("ERROR: Abnormal replicator shutdown")
                        exitloop
                    end
                end

                ;;Execute the instruction

                using (instruction.action) select

                ;;"Routine" processing requests

                (REPLICATION_INSTRUCTION.CREATE_ROW),
                    call DoInsert

                (REPLICATION_INSTRUCTION.UPDATE_ROW),
                    call DoUpdate

                (REPLICATION_INSTRUCTION.DELETE_ROW),
                    call DoDelete

                ;;"Special" processing requests

                (REPLICATION_INSTRUCTION.CREATE_TABLE),
                    call DoCreateTable

                (REPLICATION_INSTRUCTION.LOAD_TABLE),
                    call DoLoadTable

                (REPLICATION_INSTRUCTION.CREATE_AND_LOAD_TABLE),
                    call DoCreateAndLoadTable

                (REPLICATION_INSTRUCTION.DELETE_ALL_ROWS),
                    call DoDeleteAllRows

                (REPLICATION_INSTRUCTION.DELETE_TABLE),
                    call DoDeleteTable

                (REPLICATION_INSTRUCTION.CYCLE_LOG),
                begin
                    cycleLog = true
                    call OpenLogFile
                end

                (REPLICATION_INSTRUCTION.SHUTDOWN),
                begin
                    delete(tch)
                    xcall ReplicatorShutdown
                    stop
                end

                endusing

                ;;Delete the instruction from the instruction file
                delete(tch)

            end

            ;;Go back to first record in instruction file and start over
            try
            begin
                find(tch,,^FIRST)
            end
            catch (ex)
            begin
                nop
            end
            endtry
        end
    end

    ;;Close the database
    if (db)
        xcall ssc_release(db)

    ;;Release the name space
    if (nsid)
        xcall nspc_close(nsid)

    ;;Close the instructions file
    if (tch&&%chopen(tch))
        close tch

    ;;All done
    stop

;;-----------------------------------------------------------------------------
;; Look for a pending instruction
;;
GetInstruction,

    repeat
    begin
        try
        begin
            reads(tch,instruction,,LOCK:Q_AUTO_LOCK)
            noMoreInstructions = false
            exitloop
        end
        catch (ex, @EndOfFileException)
        begin
            noMoreInstructions = true
            exitloop
        end
        catch (ex, @RecordLockedException)
        begin
            sleep D_ERROR_TIME
            nextloop
        end
        endtry
    end

    return

;;-----------------------------------------------------------------------------

CheckFileTable,

    ;;Do we already have an entry for this file in our namespace?

    if (nsptr = %nspc_find(nsid,instruction.structure_name,structure_data)) then
    begin
        ;;Yes, we're good to go!
        nop
    end
    else
    begin
        ;;No, open the file and make sure it worked
        call OpenFile
        if (!structure_data.structure_chan)
            exit

        ;;Get the record size of the file
        try
        begin
            functionName = %atrim(instruction.structure_name) + "_LENGTH"
            structure_data.structure_size = %xsubr(functionName)
        end
        catch (ex, @SynException)
        begin
            ok = %LogFunctionFail(logch,functionName,ex.Errno,ex.Message)
            return
        end
        endtry

        ;;Default to using the primary key to access ISAM records
        structure_data.structure_keynum = 0

        ;;If we have more than one key, look for "REPLICATION_KEY"
        begin
            data numKeys, i4
            if ((numKeys = %isinfo(structure_data.structure_chan,"NUMKEYS")) > 1)
            begin
                data thisKey, i4
                for thisKey from 1 thru numKeys - 1
                begin
                    if (%isinfoa(structure_data.structure_chan,"KEYNAME",thisKey)=="REPLICATION_KEY")
                    begin
                        structure_data.structure_keynum = thisKey
                        exitloop
                    end
                end
            end
        end

        ;;Report the key that will be used
        debuglog(" - Key " + %string(structure_data.structure_keynum) + " will be used to access the ISAM file")

        ;;And save the structure name
        structure_data.structure_name = instruction.structure_name

        ;;Record the new open file in the namespace
        nsptr = %nspc_add(nsid,instruction.structure_name,structure_data)
    end

    return

;;-----------------------------------------------------------------------------
;; Open a Synergy data file
;;
OpenFile,

    debuglog("Opening file " + %atrim(instruction.structure_name))

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_IO"
        status = %xsubr(functionName,IO_OPEN_INP,structure_data.structure_chan,,,,,,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logch,functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    if (status == IO_OK) then
    begin
        debuglog(" - File opened")
        call CheckTable
    end
    else
    begin
        debuglog(" - Failed to open file!")
        clear structure_data.structure_chan
        xcall LogFunctionError(logch,functionName,status,dberrtxt)
    end

    return

;;-----------------------------------------------------------------------------
;; Find out if a table exists in the SQL database. If not create and load it.
;;
CheckTable,

    debuglog("Checking if table " + %atrim(instruction.structure_name) + " exists")

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_EXISTS"
        status = %xsubr(functionName,db,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logch,functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    using status select
    (1),
        debuglog(" - Table exists")
    (0),
    begin
        debuglog(" - Table not found!")
        call CreateTable
    end
    (<0),;Error
        xcall LogFunctionError(logch,functionName,status,dberrtxt)
    endusing

    return

;;-----------------------------------------------------------------------------
;; Create and load a new table in the SQL database
;;
CreateTable,

    log("Creating table " + %atrim(instruction.structure_name))

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_CREATE"
        status = %xsubr(functionName,db,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logch,functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    if (status) then
    begin
        debuglog(" - Table created")
        call LoadTable
    end
    else
    begin
        xcall LogFunctionError(logch,functionName,status,dberrtxt)
    end

    return

;;-----------------------------------------------------------------------------
;; Perform an initial load of a new table in the SQL database
;;
LoadTable,

    log("Starting full load of table " + %atrim(instruction.structure_name))

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_LOAD"

        if (runningOnTerminal) then
            status = %xsubr(functionName,db,dberrtxt,logLoadExceptions,logch,success_count,fail_count)
        else
            status = %xsubr(functionName,db,dberrtxt,logLoadExceptions,,success_count,fail_count)

        if (status) then
        begin
            log(" - Full load of table " + %atrim(instruction.structure_name) + " complete")
            log(" - " + %string(success_count) + " rows inserted, " + %string(fail_count) + " rows failed")
            inserts += success_count
            fails   += fail_count
        end
        else
        begin
            xcall LogFunctionError(logch,functionName,status,dberrtxt)
        end
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logch,functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Add a new row
;;
DoInsert,

    if (switchMode) then
    begin
        debuglog(" - Insert row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end
    else
    begin
        debuglog("Insert row in table " + %atrim(instruction.structure_name))
        call ReadSynergyRecord
    end

    if ((status==IO_OK)&&(databuffer))
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + '_INSERT_ROW'
            status = %xsubr(functionName,db,databuffer(1,structure_data.structure_size),dberrtxt)
        end
        catch (ex, @SynException)
        begin
            ok = %LogFunctionFail(logch,functionName,ex.Errno,ex.Message)
            return
        end
        endtry
    end

    using status select
    (0),
    begin
        xcall LogFunctionError(logch,functionName,status,dberrtxt)
    end
    (1),
    begin
        debuglog(" - Row inserted")
        inserts+=1
    end
    (2),
    begin
        debuglog(" - Row already exists, switching to UPDATE")
        status = IO_OK
        switchMode = true
        call DoUpdate
    end
    endusing

    return

;;-----------------------------------------------------------------------------
;; Update an existing row
;;
DoUpdate,

    if (switchMode) then
    begin
        debuglog(" - Update row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end
    else
    begin
        debuglog("Update row in table " + %atrim(instruction.structure_name))
        call ReadSynergyRecord
    end

    ;; Check that a record was returned before calling update because the record
    ;; may have been deleted since. If so just ignore the instruction.

    if ((status==IO_OK)&&(databuffer))
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + '_UPDATE_ROW'
            status = %xsubr(functionName,db,databuffer(1,structure_data.structure_size),rows,dberrtxt)
        end
        catch (ex, @SynException)
        begin
            ok = %LogFunctionFail(logch,functionName,ex.Errno,ex.Message)
            return
        end
        endtry
    end

    if (status) then
    begin
        if (rows) then
        begin
            debuglog(" - Row updated")
            updates+=1
        end
        else
        begin
            debuglog(" - Row not found, switching to INSERT")
            status = IO_OK
            sWitchMode = true
            call DoInsert
        end
    end
    else
    begin
        xcall LogFunctionError(logch,functionName,status,dberrtxt)
    end

    return

;;-----------------------------------------------------------------------------
;; Delete a row
;;
DoDelete,

    debuglog("Delete row from table " + %atrim(instruction.structure_name))

    if (logKeys)
        debugLog(" - Key: " + %atrim(instruction.key))

    try
    begin
        functionName = %atrim(instruction.structure_name) + '_DELETE_ROW'
        status = %xsubr(functionName,db,instruction.key,dberrtxt)
        if (status) then
        begin
            debuglog(" - Row deleted")
            deletes+=1
        end
        else
        begin
            debuglog(" - " + dberrtxt)
            xcall LogFunctionError(logch,functionName,status,dberrtxt)
        end
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logch,functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Create a new table
;;
DoCreateTable,

    ;;Create a new table (only)
    ;;If the table already exists, do nothing

    debuglog("Create table " + %atrim(instruction.structure_name))
    debuglog(" - Checking if table already exists")

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_EXISTS"
        status = %xsubr(functionName,db,dberrtxt)
        using status select
        (1),
        begin
            debuglog(" - Table already exists!")
        end
        (0),
        begin
            debuglog(" - Creating table")

            try
            begin
                functionName = %atrim(instruction.structure_name) + "_CREATE"
                status = %xsubr(functionName,db,dberrtxt)
                if (status) then
                    debuglog(" - Table created")
                else
                    xcall LogFunctionError(logch,functionName,status,dberrtxt)
            end
            catch (ex, @SynException)
            begin
                ok = %LogFunctionFail(logch,functionName,ex.Errno,ex.Message)
            end
            endtry
        end
        (<0),
        begin
            xcall LogFunctionError(logch,functionName,status,dberrtxt)
        end
        endusing
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logch,functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Load new data into existing table
;;
DoLoadTable,

    ;;Do a full load of an existing table with new data
    ;;Delete all existing data before loading new data

    log("Starting reload of table " + %atrim(instruction.structure_name))
    debuglog(" - Checking if table exists")

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_EXISTS"
        status = %xsubr(functionName,db,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logch,functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    using status select
    (1),
    begin
        call DoDeleteAllRows
        call LoadTable
    end
    (0),
    begin
        debuglog(" - Table does not exist!")
    end
    (<0),
    begin
        xcall LogFunctionError(logch,functionName,status,dberrtxt)
    end
    endusing

    return

;;-----------------------------------------------------------------------------
;; Create a new table and load new data into it
;;
DoCreateAndLoadTable,

    ;;Create a new table, do nothing if the table already exists
    ;;We create the table, then do a full load of data

    call CheckTable

    return

;;-----------------------------------------------------------------------------
;; Delete all rows from an existing table
;;
DoDeleteAllRows,

    log("Deleting all rows from table " + %atrim(instruction.structure_name))

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_CLEAR"
        status = %xsubr(functionName,db,dberrtxt)
        if (status) then
            debuglog(" - All rows were deleted")
        else
            xcall LogFunctionError(logch,functionName,status,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logch,functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Delete an existing table
;;
DoDeleteTable,

    ;;Is the file in the file table?
    if (nsptr=%nspc_find(nsid,instruction.structure_name,structure_data))
    begin

        ;Yes - close the file
        if ((structure_data.structure_chan)&&%chopen(structure_data.structure_chan))
        begin
            close structure_data.structure_chan
            clear structure_data
        end

        ;And remove it from the file table
        xcall nspc_delete(nsid,nsptr)
    end

    log("Deleting table " + %atrim(instruction.structure_name))

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_DROP"
        status = %xsubr(functionName,db,dberrtxt)
        if (status) then
            debuglog(" - Table was deleted")
        else
            xcall LogFunctionError(logch,functionName,status,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logch,functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Read the record associated with the key obtained from the instruction file.
;;
ReadSynergyRecord,

    ;;Find the master record details
    try
    begin
        functionName = %atrim(instruction.structure_name) + "_IO"
        status = %xsubr(functionName,IO_READ,structure_data.structure_chan,instruction.key,structure_data.structure_keynum,databuffer(1,structure_data.structure_size),,,dberrtxt)
        using status select
        (IO_OK),
        begin
            if (logKeys)
                debugLog(" - Key: " + %atrim(instruction.key))
        end
        (IO_NOT_FOUND,IO_EOF),
            debuglog(" - Record not found in ISAM file!")
        (),
            xcall LogFunctionError(logch,functionName,status,dberrtxt)
        endusing
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logch,functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Open the log file

OpenLogFile,

    ;;Are we running on a terminal?
    if (runningOnTerminal) then
    begin
        log_file = "TT:"
        log_mode = "O"
    end
    else
    begin
        ;;The logical will be used if defined, otherwise current directory will be used
        log_file = "REPLICATOR_LOGDIR:replicator_"+%datetime+".log"
        log_mode = "O:S"
    end

    ;;Open the log file
    try
    begin
        if (cycleLog)
        begin
            log("Log is being cycled. New log is " + log_file)
            close logch
            cycleLog = false
        end

        open(logch=0,log_mode,log_file)

        log("------------------------------------------------------------")
        log("SQL Replicator Log")
        log("")
        log("Instruction file : " + D_TRANS_FILE)
        log("Sleep interval   : " + %string(sleep_time) + " seconds.")
    end
    catch (ex)
    begin
        if (!runningOnTerminal)
            xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE,"Replicator failed to open log file " + log_file + ". Error number " + %string(%ernum))
        ok = false
    end
    endtry

    return

endmain

;;*****************************************************************************
;;
;; Routine:     ReplicatorShutdown
;;
;; Description: This routine is an event handler which is called when the
;;              replicator service is being stopped by the Windows operating
;;              system, or because a shutdown message was received via the
;;              instructions file.
;;
;; Author:      Steve Ives, Synergex Professional Services Group
;;
;; Created:     10th April 2008
;;
;;*****************************************************************************
;;
;; This code is supplied as seen and without warranty or support, and is used
;; at your own risk. Neither the author or Synergex accept any responsability
;; for any loss or damage which may result from the use of this code. This text
;; must remain unaltered in this file at all times. Possession or use of this
;; code, or any modified version of this code, indicates your acceptance of
;; these conditions.
;;
;;*****************************************************************************
;;
subroutine ReplicatorShutdown

    endparams

    .include "CONNECTDIR:ssql.def"
    .include "DBLDIR:namspc.def"
    .include "GENSRC:structureio.def"

    external common
        db                  ,i4                 ;;Database channel
        nsid                ,i4                 ;;Name space id
        tch                 ,i4                 ;;Instruction file channel
        logch               ,i4                 ;;Log file channel
        inserts             ,i4                 ;;Number of create operations completed
        updates             ,i4                 ;;Number of update operations completed
        deletes             ,i4                 ;;Number of delete operations completed
        fails               ,i4                 ;;Number of failed operations
        runningOnTerminal   ,i4                 ;;Program is running on a terminal
    endcommon

    stack record
        idx                 ,i4                 ;;Loop counter
        access_code         ,i4                 ;;Namespace access code
        status              ,i4                 ;;Function return status
        functionName        ,string             ;;External function name to call
    endrecord

    record structure_data
        structure_name      ,a30                ;;Name of structure
        structure_chan      ,i4                 ;;ISAM channel being used
    endrecord

proc

    log("------------------------------------------------------------")
    log("Normal replicator shutdown. Session summary:")
    log("INSERTS: " + %string(inserts,"ZZZ,ZZZ,ZZZ,ZZX"))
    log("UPDATES: " + %string(updates,"ZZZ,ZZZ,ZZZ,ZZX"))
    log("DELETES: " + %string(deletes,"ZZZ,ZZZ,ZZZ,ZZX"))
    log("ERRORS:  " + %string(fails,  "ZZZ,ZZZ,ZZZ,ZZX"))
    log("------------------------------------------------------------")

    ;;Close the database
    if (db)
    begin
        xcall ssc_release(db)
        clear db
    end

    ;;Close any data files that we have open
    if (nsid)
    begin
        for idx from 1 thru %nspc_stoa(nsid,9999)
        begin
            ;;Get the item data from the namespace
            access_code = %nspc_stoa(nsid,idx)
            xcall nspc_getdata(nsid,access_code,structure_data)
            ;;Close the channel
            if ((structure_data.structure_chan)&&%chopen(structure_data.structure_chan))
            begin
                try
                begin
                    functionName = %atrim(structure_data.structure_name) + "_IO"
                    status = %xsubr(functionName,IO_CLOSE,structure_data.structure_chan)
                end
                catch (ex)
                begin
                    nop
                end
                endtry
            end
        end

        xcall nspc_close(nsid)
        clear nsid

    end

    ;;Close the instructions file
    if (tch)
    begin
        close tch
        clear tch
    end

    if (runningOnTerminal)
    begin
        log("Replicator will stop in 2 seconds")
        sleep 2
    end

    xreturn

endsubroutine

subroutine LogFunctionError
    required in logChannel, int
    required in functionName, string
    required in errorNumber, int
    required in errorMessage, string
    endparams
proc
    writes(logChannel,%TimeStamp+"ERROR: Function" + %atrim(functionName) + " returned error " + %string(errorNumber) + ": " + %atrim(errorMessage))
    xreturn
endsubroutine

function LogFunctionFail, boolean
    required in logChannel, int
    required in functionName, string
    required in errorNumber, int
    required in errorMessage, string
    endparams
proc
    writes(logChannel,%TimeStamp+"ERROR: Function " + %atrim(functionName) + " failed with error " + %string(errorNumber) + ": " + %atrim(errorMessage))
    freturn false
endfunction

function TimeStamp, string
    external common
        db                  ,i4                 ;;Database channel
        nsid                ,i4                 ;;Name space id
        tch                 ,i4                 ;;Instruction file channel
        logch               ,i4                 ;;Log file channel
        inserts             ,i4                 ;;Number of create operations completed
        updates             ,i4                 ;;Number of update operations completed
        deletes             ,i4                 ;;Number of delete operations completed
        fails               ,i4                 ;;Number of failed operations
        runningOnTerminal   ,i4                 ;;Program is running on a terminal
    endcommon
    record
        now                 ,d20
    endrecord
proc
    if (runningOnTerminal) then
        freturn ""
    else
    begin
        now = %datetime
        freturn %string(now(1:14),"XXXX-XX-XX XX:XX:XX ")
    end
endfunction

