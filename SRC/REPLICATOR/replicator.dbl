;;*****************************************************************************
;;
;; File:        replicator.dbl
;;
;; Type:        Application (replicator)
;;
;; Description: Replicates Synergy data file changes that have been recorded
;;              in the replucation log file to a SQL Server database.
;;
;;*****************************************************************************
;;
;; Copyright (c) 2008, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import replicator
import System.Collections

main replicator

    .include "CONNECTDIR:ssql.def"
    .include "REPLICATOR_INCLUDE:SmtpMail.def"
.ifdef D_VMS
    .include "REPLICATION_VMS" repository, record="instruction", end
.else
    .include "REPLICATION" repository, record="instruction", end
.endc

.align
    record
        ok,                 boolean             ;;Main status
        noMoreInstructions, boolean             ;;End of instruction file
        switchMode,         boolean             ;;Switched from INSERT to UPDATE or vice versa
        switchDone,         boolean             ;;Have we tried to switch modes before?
        bulkLoad,           boolean             ;;Use bulk load?
        doCheckCommit,      boolean             ;;Do we need to check if it's time to commit?
        doForceCommit,      boolean             ;;Do we need to force a commit?
        nsptr,              i4                  ;;Namespace pointer
        status,             i4                  ;;General working status return
        rows,               i4                  ;;Number of rows affected
        functionName,       string              ;;External function to call
        keyValue,           string              ;;Key value of the current ISAM record
        recordNumber,       d28                 ;;Record number of the current relative record
        dberrtxt,           a1024               ;;Error text from a failed database call
        structure_data,     strStructureData    ;;Data stored for each structure
    endrecord

    external function
        xsubr,              ^val
    endexternal

proc

    ok = %ConfigureEnvironment

    if (ok)
    begin
        ;;Main processing loop
        repeat
        begin
            ;;Get the next instruction from the queue
            call GetInstruction

            if (noMoreInstructions) then
            begin
                ;;The queue is currently empty. If we're in batch commit mode then commit any outstanding changes
                if ((Settings.CommitMode == DatabaseCommitMode.Batch) && (Counters.BatchCounter > 0))
                begin
                    call CommitTransaction
                end
                ;;And sleep for a while before trying again
                sleep Settings.SleepTime
            end
            else
            begin
                ;;Any action with a negative value has been co-opted to signify a shutdown request.
                if (instruction.action < 0)
                begin
                    ;;Restore the recorded action to it's original (positive) value
                    instruction.action = -instruction.action
                    write(Settings.InstructionChannel,instruction)

                    ;;And shutdown
                    Logger.Log("Shutdown requested")
                    xcall ReplicatorShutdown
                    stop
                end

                ;;We have an instruction to process

                doCheckCommit = false
                doForceCommit = false
                switchDone = false

                ;;If this is a routine request (create/update/delete) then do
                ;;file and table checks to ensure we have the file open and the
                ;;database table exists
                if    ((instruction.action==(i)REPLICATION_INSTRUCTION.CREATE_ROW)
                &    || (instruction.action==(i)REPLICATION_INSTRUCTION.UPDATE_ROW)
                &    || (instruction.action==(i)REPLICATION_INSTRUCTION.DELETE_ROW)
                &    || (instruction.action==(i)REPLICATION_INSTRUCTION.INSERT_RELATIVE)
                &    || (instruction.action==(i)REPLICATION_INSTRUCTION.UPDATE_RELATIVE)
                &    )
                begin
                    ;;Check if we already have the file open
                    call CheckFileTable

                    ;;If we don't have the file open by now then we probably have a configuration problem
                    if (!structure_data.structure_chan)
                    begin
                        Logger.ErrorLog("Abnormal replicator shutdown")
                        exitloop
                    end
                end

                ;;Execute the instruction

                using (instruction.action) select

                ;;"Routine" processing requests

                (REPLICATION_INSTRUCTION.CREATE_ROW),
                begin
                    Logger.VerboseLog("Insert row in table " + %atrim(instruction.structure_name))
                    call DoInsert
                    doCheckCommit = true
                end

                (REPLICATION_INSTRUCTION.UPDATE_ROW),
                begin
                    Logger.VerboseLog("Update row in table " + %atrim(instruction.structure_name))
                    call DoUpdate
                    doCheckCommit = true
                end

                (REPLICATION_INSTRUCTION.DELETE_ROW),
                begin
                    Logger.VerboseLog("Delete row from table " + %atrim(instruction.structure_name))
                    call DoDelete
                    doCheckCommit = true
                end

                (REPLICATION_INSTRUCTION.INSERT_RELATIVE),
                begin
                    Logger.VerboseLog("Insert row in table " + %atrim(instruction.structure_name))
                    call DoInsertRelative
                    doCheckCommit = true
                end

                (REPLICATION_INSTRUCTION.UPDATE_RELATIVE),
                begin
                    Logger.VerboseLog("Update row in table " + %atrim(instruction.structure_name))
                    call DoUpdateRelative
                    doCheckCommit = true
                end

                ;;"Special" processing requests

                (REPLICATION_INSTRUCTION.ADD_INDEXES),
                begin
                    Logger.Log("Add indexes to table " + %atrim(instruction.structure_name))
                    call DoAddIndexes
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.CREATE_TABLE),
                begin
                    Logger.Log("Create table " + %atrim(instruction.structure_name))
                    call DoCreateTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.LOAD_TABLE),
                begin
                    Logger.Log("Load table " + %atrim(instruction.structure_name))
                    bulkLoad = false
                    call DoLoadTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.BULK_LOAD_TABLE),
                begin
                    if (bulkLoad = Settings.CanBulkLoad()) then
                        Logger.Log("Bulk load table " + %atrim(instruction.structure_name))
                    else
                    begin
                        Logger.Log("Bulk load requested but unavailable!")
                        Logger.Log("Load table " + %atrim(instruction.structure_name))
                    end
                    call DoLoadTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.CREATE_AND_LOAD_TABLE),
                begin
                    Logger.Log("Create and load table " + %atrim(instruction.structure_name))
                    call DoCreateAndLoadTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.CREATE_CSV),
                begin
                    Logger.Log("Export table " + %atrim(instruction.structure_name) + " to delimited file")
                    call DoCreateCsv
                end

                (REPLICATION_INSTRUCTION.DELETE_ALL_ROWS),
                begin
                    Logger.Log("Truncate table " + %atrim(instruction.structure_name))
                    call DoDeleteAllRows
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.DELETE_INDEXES),
                begin
                    Logger.Log("Remove indexes from table " + %atrim(instruction.structure_name))
                    call DoDeleteIndexes
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.DELETE_TABLE),
                begin
                    Logger.Log("Delete table " + %atrim(instruction.structure_name))
                    call DoDeleteTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.CHANGE_INTERVAL),
                begin
                    Logger.Log("Change processing interval")
                    call ChangeInterval
                end

                (REPLICATION_INSTRUCTION.CYCLE_LOG),
                begin
                    Logger.Log("Cycle log file")
                    Logger.CycleLog()
                end

                (REPLICATION_INSTRUCTION.SHUTDOWN),
                begin
                    Logger.Log("Shutdown requested")
                    ;;Delete the shutdown instruction from the queue
                    delete(Settings.InstructionChannel)

                    xcall ReplicatorShutdown
                    stop
                end

                endusing

                ;;Delete the instruction from the instruction file
                delete(Settings.InstructionChannel)

                ;;If we're in batch commit mode, do we need to commit?
                if (Settings.CommitMode == DatabaseCommitMode.Batch)
                begin
                    ;;This logic may look a little "hokey", but there is a reason for it!
                    if ((doForceCommit && (Counters.BatchCounter+=1)) || (doCheckCommit && ((Counters.BatchCounter += 1) == Settings.CommitBatchRows)))
                    begin
                        call CommitTransaction
                    end
                end
            end

            ;;Reset to first record in instruction file and start over
            try
            begin
                find(Settings.InstructionChannel,,^FIRST)
            end
            catch (ex)
            begin
                nop
            end
            endtry
        end
    end

    ;;Close the database
    xcall DatabaseDisconnect

    ;;Release the namespace
    if (Settings.ChannelInfo)
        xcall nspc_close(Settings.ChannelInfo)

    ;;Close the instructions file
    if (Settings.InstructionChannel&&%chopen(Settings.InstructionChannel))
        close Settings.InstructionChannel

    ;;All done
    stop

;;-----------------------------------------------------------------------------
;; Commit the current transaction and start a new one (only used in batch transaction mode)
;;
CommitTransaction,
    begin
        data message, string, "Committing transaction with " + %string(Counters.BatchCounter) + " change(s)"
        Logger.VerboseLog(message)
        status = %ssc_commit(Settings.DatabaseChannel,SSQL_TXON)
        Logger.VerboseLog("Start transaction")
        Counters.BatchCommits += 1
        Counters.BatchCounter = 0
    end

    return

;;-----------------------------------------------------------------------------
;; Look for a pending instruction
;;
GetInstruction,
    begin
        repeat
        begin
            try
            begin
                reads(Settings.InstructionChannel,instruction,,LOCK:Q_AUTO_LOCK)
                noMoreInstructions = false
                exitloop
            end
            catch (ex, @EndOfFileException)
            begin
                noMoreInstructions = true
                exitloop
            end
            catch (ex, @RecordLockedException)
            begin
                sleep Settings.ErrorSleepTime
                nextloop
            end
            endtry
        end
    end

    return

;;-----------------------------------------------------------------------------
;; Check if we have already opened this file in this process
;;
CheckFileTable,
    begin
        ;;If there is an entry for the file in our namespace then we're good to go

        if (nsptr = %nspc_find(Settings.ChannelInfo,instruction.structure_name,structure_data))
        begin
            return
        end

        Logger.VerboseLog("First instruction checks for table " + %atrim(instruction.structure_name))

        ;;No, open the file and make sure it worked

        call OpenFile

        ;;If we failed to open the file then we have a serious problem!

        if (!structure_data.structure_chan)
        begin
            Logger.ErrorLog("Failed to open ISAM file for structure " + %atrim(instruction.structure_name))
            return
        end

        ;;Get the record size of the file

        try
        begin
            functionName = %atrim(instruction.structure_name) + "Length"
            structure_data.structure_size = %xsubr(functionName)
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry

        ;;Get the type of the file

        try
        begin
            functionName = %atrim(instruction.structure_name) + "Type"
            xcall xsubr(functionName,structure_data.structure_type)
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry

        using structure_data.structure_type select

        ("DBL ISAM"),
        begin
            ;;Search for the first unique key. There should always be one, because without one the
            ;;constructor in the I/O hooks class would not activate replication for the file.
            data thisKey, i4
            structure_data.structure_keynum = -1
            for thisKey from 0 thru %isinfo(structure_data.structure_chan,"NUMKEYS") - 1
            begin
                if (!%isinfo(structure_data.structure_chan,"DUPS",thisKey))
                begin
                    ;;Found it!
                    structure_data.structure_keynum = thisKey
                    exitloop
                end
            end

            ;;Did we find a unique key?
            if (structure_data.structure_keynum>=0) then
            begin
                ;;Report the key that will be used
                Logger.VerboseLog(" - Key " + %string(structure_data.structure_keynum) + " will be used to synchronize data")

                ;;And save the structure name
                structure_data.structure_name = instruction.structure_name

                ;;Record the new open file in the namespace
                nsptr = %nspc_add(Settings.ChannelInfo,instruction.structure_name,structure_data)
            end
            else
            begin
                ;;In theory we should never get here because CodeGen should not be able to create the
                ;;required code if no unique key is present.
                ;;But just in case, this will cause the replicator to abort
                close structure_data.structure_chan
                clear structure_data.structure_chan
                Logger.ErrorLog("File for structure " + %atrim(instruction.structure_name) + " has no unique key!")
            end
        end

        ("RELATIVE"),
        begin
            ;;Report that record numbers will be used
            Logger.VerboseLog(" - Record numbers will be used to synchronize data")

            ;;Set the key number to -1 to prevent it being used accidentally
            structure_data.structure_keynum = -1

            ;;And save the structure name
            structure_data.structure_name = instruction.structure_name

            ;;Record the new open file in the namespace
            nsptr = %nspc_add(Settings.ChannelInfo,instruction.structure_name,structure_data)
        end

        endusing
    end

    return

;;-----------------------------------------------------------------------------
;; Open a Synergy data file
;;
OpenFile,
    begin
        Logger.VerboseLog(" - Opening associated data file")

        try
        begin
            functionName = %atrim(instruction.structure_name) + "OpenInput"
            structure_data.structure_chan = %xsubr(functionName,dberrtxt)
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry

        if (structure_data.structure_chan) then
        begin
            Logger.VerboseLog(" - File opened")
            call CheckTable
        end
        else
        begin
            Logger.VerboseLog(" - Failed to open file!")
            Logger.LogFunctionError(functionName,status,dberrtxt)
        end
    end

    return

;;-----------------------------------------------------------------------------
;; Find out if a table exists in the SQL database. If not create and load it.
;;
CheckTable,
    begin
        Logger.VerboseLog(" - Checking if table exists")

        try
        begin
            functionName = %atrim(instruction.structure_name) + "Exists"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt)
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry

        using status select
        (1),
            Logger.VerboseLog(" - Table exists")
        (0),
        begin
            Logger.VerboseLog(" - Table not found!")
            call CreateTable
        end
        (<0),;Error
            Logger.LogFunctionError(functionName,status,dberrtxt)
        endusing
    end

    return

;;-----------------------------------------------------------------------------
;; Create and load a new table in the SQL database
;; This code is only used when doing an initial check for a table because of
;; a first replication instruction. Explicit CREATE_TABLE instructions are
;; handled by DoCreateTable.
;;
CreateTable,
    begin
        Logger.Log(" - Creating table")

        try
        begin
            functionName = %atrim(instruction.structure_name) + "Create"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt)
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry

        if (status) then
        begin
            Logger.VerboseLog(" - Table created")
            ;;Now do an initial load of the data
            if (Settings.CanBulkLoad()) then
                call BulkLoadTable
            else
                call LoadTable
        end
        else
        begin
            Logger.LogFunctionError(functionName,status,dberrtxt)
        end
    end

    return

;;-----------------------------------------------------------------------------
;; Perform an initial load of a new table in the SQL database
;;
LoadTable,
    begin
        Logger.Log(" - Load starting at " + %TimeNow)

        clear status

        try
        begin
            data successCount, int, 0
            data failCount, int, 0

            functionName = %atrim(instruction.structure_name) + "Load"

            if (Settings.RunningOnTerminal) then
                status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt,Settings.LogLoadExceptions,Settings.TerminalChannel,successCount,failCount,Settings.BulkLoadProgressReporting)
            else
                status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt,Settings.LogLoadExceptions,,successCount,failCount)

            if (status) then
            begin
                Logger.Log(" - Load complete at " + %TimeNow)
                Logger.Log(" - " + %string(successCount) + " rows inserted, " + %string(failCount) + " rows failed.")
                Counters.Inserts += successCount
                Counters.Errors  += failCount
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt)
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
        end
        endtry

        ;;Now add alternate key indexes
        if (ok && status)
        begin
            call DoAddIndexes
        end
    end

    return

;;-----------------------------------------------------------------------------
;; Perform a bulk load of a table from a delimited text file.
;;
BulkLoadTable,
    begin
        Logger.Log(" - Bulk load starting at " + %TimeNow)

        clear status

        try
        begin
            data totalRows, int
            data failRows, int

            functionName = %atrim(instruction.structure_name) + "BulkLoad"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,Settings.LocalExportPath,Settings.FileServiceHost,Settings.FileServicePort,Settings.DatabaseTimeout,Settings.BulkLoadTimeout,Settings.LogFileChannel,totalRows,failRows,dberrtxt)

            if (status) then
            begin
                Logger.Log(" - Bulk load complete at " + %TimeNow)
                Logger.Log("   - " + %string(totalRows) + " records processed, " + %string(failRows) + " failed.")
                Counters.Inserts += totalRows - failRows
                Counters.Errors  += failRows
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt)
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
        end
        endtry

        ;;Now add alternate key indexes
        if (ok && status)
        begin
            call DoAddIndexes
        end
    end

    return

;;-----------------------------------------------------------------------------
;; Add a new row (ISAM)
;;
DoInsert,
    begin
        if (switchMode) then
        begin
            Logger.VerboseLog(" - Insert row in table " + %atrim(instruction.structure_name))
            switchMode = false
        end
        else
        begin
            if (Settings.LogKeys)
            begin
                keyValue = %keyVal(structure_data.structure_chan,instruction.record,structure_data.structure_keynum)
                Logger.VerboseLog(" - Key: " + keyValue)
            end
        end

        try
        begin
            functionName = %atrim(instruction.structure_name) + "Insert"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,instruction.record(1,structure_data.structure_size),dberrtxt)
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry

        using status select
        (0),
        begin
            Logger.LogFunctionError(functionName,status,dberrtxt)
        end
        (1),
        begin
            Logger.VerboseLog(" - Row inserted")
            Counters.Inserts += 1
        end
        (2),
        begin
            Logger.VerboseLog(" - Row exists, switching to UPDATE")
            status = 1
            if (switchDone) then
            begin
                Logger.ErrorLog(" - Too many INSERT/UPDATE mode switches!")
            end
            else
            begin
                switchMode = true
                call DoUpdate
            end
        end
        endusing
    end

    return

;;-----------------------------------------------------------------------------
;; Add a new row (RELATIVE)
;;
DoInsertRelative,
    begin
        if (switchMode) then
        begin
            Logger.VerboseLog(" - Insert row in table " + %atrim(instruction.structure_name))
            switchMode = false
        end
        else
        begin
            if (Settings.LogKeys)
            begin
                data pos, i4, %instr(1,instruction.record,":")
                recordNumber = instruction.record(1:pos-1)
                instruction.record = instruction.record(pos+1:structure_data.structure_size)
                Logger.VerboseLog(" - Record #: " + %string(recordNumber))
            end
        end

        try
        begin
            functionName = %atrim(instruction.structure_name) + "Insert"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,recordNumber,instruction.record(1,structure_data.structure_size),dberrtxt)
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry

        using status select
        (0),
        begin
            Logger.LogFunctionError(functionName,status,dberrtxt)
        end
        (1),
        begin
            Logger.VerboseLog(" - Row inserted")
            Counters.Inserts += 1
        end
        (2),
        begin
            Logger.VerboseLog(" - Row exists, switching to UPDATE")
            status = 1
            if (switchDone) then
            begin
                Logger.ErrorLog(" - Too many INSERT/UPDATE mode switches!")
            end
            else
            begin
                switchMode = true
                call DoUpdateRelative
            end
        end
        endusing
    end

    return

;;-----------------------------------------------------------------------------
;; Update an existing row (ISAM)
;;
DoUpdate,
    begin
        if (switchMode) then
        begin
            Logger.VerboseLog(" - Update row in table " + %atrim(instruction.structure_name))
            switchMode = false
        end
        else
        begin
            if (Settings.LogKeys)
            begin
                keyValue = %keyVal(structure_data.structure_chan,instruction.record,structure_data.structure_keynum)
                Logger.VerboseLog(" - Key: " + keyValue)
            end
        end

        try
        begin
            functionName = %atrim(instruction.structure_name) + "Update"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,instruction.record(1,structure_data.structure_size),rows,dberrtxt)
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry

        if (status) then
        begin
            if (rows) then
            begin
                Logger.VerboseLog(" - Row updated")
                Counters.Updates += 1
            end
            else
            begin
                Logger.VerboseLog(" - Row not found, switching to INSERT")
                status = 1
                if (switchDone) then
                begin
                    Logger.ErrorLog(" - Too many INSERT/UPDATE mode switches!")
                end
                else
                begin
                    switchMode = true
                    call DoInsert
                end
            end
        end
        else
        begin
            Logger.LogFunctionError(functionName,status,dberrtxt)
        end
    end

    return

;;-----------------------------------------------------------------------------
;; Update an existing row (RELATIVE)
;;
DoUpdateRelative,
    begin
        if (switchMode) then
        begin
            Logger.VerboseLog(" - Update row in table " + %atrim(instruction.structure_name))
            switchMode = false
        end
        else
        begin
            if (Settings.LogKeys)
            begin
                data pos, i4, %instr(1,instruction.record,":")
                recordNumber = instruction.record(1:pos-1)
                instruction.record = instruction.record(pos+1:structure_data.structure_size)
                Logger.VerboseLog(" - Record #: " + %string(recordNumber))
            end
        end

        try
        begin
            functionName = %atrim(instruction.structure_name) + "Update"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,recordNumber,instruction.record(1,structure_data.structure_size),rows,dberrtxt)
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry

        if (status) then
        begin
            if (rows) then
            begin
                Logger.VerboseLog(" - Row updated")
                Counters.Updates += 1
            end
            else
            begin
                Logger.VerboseLog(" - Row not found, switching to INSERT")
                status = 1
                if (switchDone) then
                begin
                    Logger.ErrorLog(" - Too many INSERT/UPDATE mode switches!")
                end
                else
                begin
                    switchMode = true
                    call DoInsertRelative
                end
            end
        end
        else
        begin
            Logger.LogFunctionError(functionName,status,dberrtxt)
        end
    end

    return

;;-----------------------------------------------------------------------------
;; Delete a row
;;
DoDelete,
    begin
        keyValue = %keyval(structure_data.structure_chan,instruction.record,structure_data.structure_keynum)

        if (Settings.LogKeys)
            Logger.VerboseLog(" - Key: " + keyValue)

        try
        begin
            functionName = %atrim(instruction.structure_name) + "Delete"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,(a)keyValue,dberrtxt)
            if (status) then
            begin
                Logger.VerboseLog(" - Row deleted")
                Counters.Deletes += 1
            end
            else
            begin
                Logger.VerboseLog(" - " + dberrtxt)
                Logger.LogFunctionError(functionName,status,dberrtxt)
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
        end
        endtry
    end

    return

;;-----------------------------------------------------------------------------
;; Create a new table
;;
DoCreateTable,
    begin
        ;;Create a new table (only)
        ;;If the table already exists, do nothing

        Logger.VerboseLog(" - Checking if table exists")

        try
        begin
            functionName = %atrim(instruction.structure_name) + "Exists"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt)
            using status select
            (1),
            begin
                Logger.VerboseLog(" - Table exists!")
            end
            (0),
            begin
                Logger.VerboseLog(" - Creating table")

                try
                begin
                    functionName = %atrim(instruction.structure_name) + "Create"
                    status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt)
                    if (status) then
                    begin
                        Logger.VerboseLog(" - Table created")

                        if (Settings.CanSendEmail())
                        begin
                            data subject, string, "created table " + %atrim(instruction.structure_name)
                            data body = new string[#] { "A new table was created in the database." }
                            xcall SendEmail(subject,body)
                        end
                    end
                    else
                        Logger.LogFunctionError(functionName,status,dberrtxt)
                end
                catch (ex, @SynException)
                begin
                    ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
                end
                endtry
            end
            (<0),
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt)
            end
            endusing
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
        end
        endtry
    end

    return

;;-----------------------------------------------------------------------------
;; Load new data into existing table
;;
DoLoadTable,
    begin
        ;;Do a full load of an existing table with new data

        Logger.VerboseLog(" - Checking if table exists")

        try
        begin
            functionName = %atrim(instruction.structure_name) + "Exists"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt)
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry

        using status select
        (1),
        begin
            Logger.VerboseLog(" - Table exists")

            ;;Delete any and all existing data before loading new data
            call DoDeleteAllRows

            if (bulkLoad) then
                call BulkLoadTable
            else
                call LoadTable
        end
        (0),
        begin
            Logger.VerboseLog(" - Table does not exist!")
        end
        (<0),
        begin
            Logger.LogFunctionError(functionName,status,dberrtxt)
        end
        endusing
    end

    return

;;-----------------------------------------------------------------------------
;; Create a new table and load new data into it
;;
DoCreateAndLoadTable,
    begin
        ;;Create a new table, do nothing if the table already exists
        ;;We create the table, then do a full load of data
        call CheckTable
    end

    return

;;-----------------------------------------------------------------------------
;; Export ISAM file to CSV file
;;
DoCreateCsv,
    begin
        Logger.Log(" - Export starting at " + %TimeNow)

        try
        begin
            data csvFileSpec, a128, Settings.LocalExportPath
            functionName = %atrim(instruction.structure_name) + "Csv"
            status = %xsubr(functionName,csvFileSpec,dberrtxt)
            if (status) then
                Logger.VerboseLog(" - Export complete at " + %TimeNow)
            else
                Logger.LogFunctionError(functionName,status,dberrtxt)
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
        end
        endtry
    end

    return

;;-----------------------------------------------------------------------------
;; Delete all rows from an existing table
;;
DoDeleteAllRows,
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Clear"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt)
            if (status) then
            begin
                Logger.VerboseLog(" - Table truncated")

                if (Settings.CanSendEmail())
                begin
                    data subject, string, "truncated table " + %atrim(instruction.structure_name)
                    data body = new string[#] { "All rows were deleted from the table." }
                    xcall SendEmail(subject, body)
                end
            end
            else
                Logger.LogFunctionError(functionName,status,dberrtxt)
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
        end
        endtry
    end

    return

;;-----------------------------------------------------------------------------
;; Delete an existing table
;;
DoDeleteTable,
    begin
        ;;Is the file in the file table?
        if (nsptr=%nspc_find(Settings.ChannelInfo,instruction.structure_name,structure_data))
        begin

            ;Yes - close the file
            if ((structure_data.structure_chan)&&%chopen(structure_data.structure_chan))
            begin
                close structure_data.structure_chan
                clear structure_data
            end

            ;And remove it from the file table
            xcall nspc_delete(Settings.ChannelInfo,nsptr)
        end

        try
        begin
            functionName = %atrim(instruction.structure_name) + "Drop"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt)
            if (status) then
            begin
                Logger.VerboseLog(" - Table deleted")

                if (Settings.CanSendEmail())
                begin
                    data subject, string, "deleted table " + %atrim(instruction.structure_name)
                    data body = new string[#] { "The table was deleted from the database." }
                    xcall SendEmail(subject, body)
                end
            end
            else
                Logger.LogFunctionError(functionName,status,dberrtxt)
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry
    end

    return

;;-----------------------------------------------------------------------------
;; Add alternate key indexes to a table (if they don't already exist)
;;
DoAddIndexes,
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Index"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,Settings.DatabaseTimeout,Settings.BulkLoadTimeout,Settings.LogFileChannel,dberrtxt)
            if (status) then
            begin
                Logger.VerboseLog(" - Indexes added")

                if (Settings.CanSendEmail())
                begin
                    data subject, string, "added indexes to table " + %atrim(instruction.structure_name)
                    data body = new string[#] { "Alternate key indexes were added to the table." }
                    xcall SendEmail(subject, body)
                end
            end
            else
                Logger.LogFunctionError(functionName,status,dberrtxt)
        end
        catch (ex, @RoutineNotFound)
        begin
            Logger.VerboseLog(" - Addining indexes is not enabled for this table.")
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
        end
        endtry
    end

    return

;;-----------------------------------------------------------------------------
;; Delete alternate key indexes from a table
;;
DoDeleteIndexes,
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "UnIndex"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt)
            if (status) then
            begin
                Logger.VerboseLog(" - Indexes removed")

                if (Settings.CanSendEmail())
                begin
                    data subject, string, "removed indexes from table " + %atrim(instruction.structure_name)
                    data body = new string[#] { "Alternate key indexes were removed from the table." }
                    xcall SendEmail(subject, body)
                end
            end
            else
                Logger.LogFunctionError(functionName,status,dberrtxt)
        end
        catch (ex, @RoutineNotFound)
        begin
            Logger.VerboseLog(" - Removing indexes is not enabled for this table.")
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
        end
        endtry
    end

    return

;;-----------------------------------------------------------------------------
;; Change the sleep seconds interval
;;
ChangeInterval,
    begin
        data save_time, i4, Settings.SleepTime
        try
        begin
            Settings.SleepTime = %integer(%atrim(instruction.record))
            if (Settings.SleepTime >= 1) then
            begin
                Logger.Log(" - Interval changed from " + %string(save_time) + " to " + %string(Settings.SleepTime) + " seconds")
            end
            else
            begin
                Logger.ErrorLog(" - Invalid interval of " + %string(Settings.SleepTime) + " seconds requested")
                Settings.SleepTime = save_time
            end
        end
        catch (ex)
        begin
            Logger.ErrorLog(" - Invalid interval " + %atrim(instruction.record) + " requested")
            Settings.SleepTime = save_time
        end
        endtry
    end

    return

endmain
