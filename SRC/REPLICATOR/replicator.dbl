;;*****************************************************************************
;;
;; File:        replicator.dbl
;;
;; Type:        Application (replicator)
;;
;; Description: Replicates Synergy data file changes that have been recorded
;;              in the replucation log file to a SQL Server database.
;;
;;*****************************************************************************
;;
;; Copyright (c) 2008, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import SynPSG.ReplicationDemo
import System.Collections
import Tools

structure strStructureData
    structure_name      ,a32    ;;Name of structure
    structure_chan      ,i4     ;;ISAM channel being used
    structure_size      ,i4     ;;Record length
    structure_keynum    ,i4     ;;Key number of unique key being used
endstructure

main replicator

    .include "CONNECTDIR:ssql.def"
    .include "INC:structureio.def"
    .include "INC:SmtpMail.def"
    .include "REPLICATION" repository, record="instruction", end

    .define D_MAX_CURSORS   128
    .define D_MAX_COLUMNS   254

    .define D_TRANS_FILE    "DAT:REPLICATION.ISM"
    .define D_SLEEP_TIME    60                  ;;Seconds to sleep
    .define D_ERROR_TIME    0.5                 ;;Time to sleep after an error

    .define log(x)          writes(Settings.LogFileChannel,%TimeStamp+%atrim(x))
	.define debuglog(x)     if (Settings.FullLogging) writes(Settings.LogFileChannel,%TimeStamp+%atrim(x))

    .align
    record
        ok                  ,boolean            ;;Main status
        noMoreInstructions  ,boolean            ;;End of instruction file
        switchMode          ,boolean            ;;Switched from INSERT to UPDATE or vice versa
        cycleLog            ,boolean            ;;Cycle the log file
        switchDone          ,boolean            ;;Have we tried to switch modes before?
        errnum              ,i4                 ;;Error number
        nsptr               ,i4                 ;;Namespace pointer
        dberr               ,i4                 ;;Database error
        length              ,i4                 ;;Length of buffer
        status              ,i4                 ;;General working status return
        rows                ,i4                 ;;Number of rows affected
        functionName        ,string             ;;External function to call
        primaryKey          ,string             ;;Primary key of current record
        keyValue            ,string             ;;Key value of the current record
        dberrtxt            ,a1024
        structure_data      ,strStructureData
        clValues            ,@ArrayList         ;;Values of a command-line parameter
    endrecord

    external function
        xsubr               ,^val
    endexternal

proc

    ok = true
    xcall flags(7004020,1)

    ;;Do we have a terminal attached or are we a detached process or service?
    ;;If we're running on a terminal we will log to the terminal, if not we will log to a log file.
    Settings.RunningOnTerminal = (%tnmbr>=0)

    if (CommandLineParser.Parse("logdir",clValues))
    begin
        using clValues.Count select
        (1),
        begin
            data sts, i4
            xcall setlog("REPLICATOR_LOGDIR",(string)clValues[0],sts)
        end
        endusing
    end

    ;;Open the log
    call OpenLogFile

    if (ok)
    begin
        if (CommandLineParser.Parse("exportdir",clValues))
        begin
            using clValues.Count select
            (1),
            begin
                data sts, i4
                xcall setlog("REPLICATOR_EXPORT",(string)clValues[0],sts)
            end
            (0),
                nop
            (),
                nop
            endusing

        end
    end

	if (ok)
    begin
        ;;Get the name of the instance
        if (CommandLineParser.Parse("instance",clValues)) then
        begin
            using clValues.Count select
            (1),
                Settings.InstanceName = (string)clValues[0]
            (0),
            begin
                log("ERROR: Missing instance name after the -instance option")
                ok = false
            end
            (),
            begin
                log("ERROR: Only one instance name may follow the -instance option")
                ok = false
            end
            endusing
        end
        else
        begin
			data tmpval, a80
            xcall getlog("REPLICATOR_INSTANCE",tmpval,length)
            if (length) then
				Settings.InstanceName = tmpval(1:length)
            else
				Settings.InstanceName = "DEFAULT"
        end
    end

    ;;Set the sleep time between processing runs
    if (ok)
    begin
        if (CommandLineParser.Parse("interval",clValues)) then
        begin
            using clValues.Count select
            (1),
            begin
                try
                begin
					Settings.SleepTime = %integer((string)clValues[0])
                end
                catch (e, @Exception)
                begin
                    log("ERROR: Invalid sleep interval value after the -interval option")
                    ok = false
                end
                endtry
            end
            (0),
            begin
                log("ERROR: Missing sleep interval value after the -interval option")
                ok = false
            end
            (),
            begin
                log("ERROR: Only one sleep interval may follow the -interval option")
                ok = false
            end
            endusing
        end
        else
        begin
			data tmpval, a10
			xcall getlog("REPLICATOR_INTERVAL",tmpval,length)
			if (length>0) then
				Settings.SleepTime = %integer(tmpval(1:length))
			else
				Settings.SleepTime = D_SLEEP_TIME
        end
		log("Sleep interval is " + %string(Settings.SleepTime) + " seconds.")
    end

    ;;Set the logging level
    if (ok)
    begin
        if (CommandLineParser.Parse("verbose")) then
        begin
            Settings.FullLogging = true
        end
        else
        begin
			data tmpval, a3
			xcall getlog("REPLICATOR_FULL_LOG",tmpval,length)
			Settings.FullLogging = ((length>0)&&(tmpval.eq."YES"))
        end
    end

    ;;Should we log keys?
    if (ok)
    begin
        if (CommandLineParser.Parse("keyvalues")) then
        begin
            Settings.LogKeys = true
        end
        else
        begin
			data tmpval, a3
			xcall getlog("REPLICATOR_LOG_KEYS",tmpval,length)
			Settings.LogKeys = ((length>0)&&(tmpval.eq."YES"))
        end
    end

    ;;Should we log data exceptions to a log file when doing a bulk load?
    if (ok)
    begin
        if (CommandLineParser.Parse("loaderrors")) then
        begin
            Settings.LogLoadExceptions = true
        end
        else
        begin
			data tmpval, a3
			xcall getlog("REPLICATOR_LOG_BULK_LOAD_EXCEPTIONS",tmpval,length)
			Settings.LogLoadExceptions = ((length>0)&&(tmpval.eq."YES"))
        end
    end

    ;;Should we send email messages when errors occur?
    if (ok)
    begin
        if (CommandLineParser.Parse("erroremail",clValues)) then
        begin
            using clValues.Count select
            (1),
            begin
                Settings.ErrorEmail = (string)clValues[0]
            end
            (0),
            begin
                log("ERROR: Missing email address after the -erroremail option")
                ok = false
            end
            (),
            begin
                log("ERROR: Only one email address may follow the -erroremail option")
                ok = false
            end
            endusing
        end
        else
        begin
			data tmpval, a1024
			xcall getlog("REPLICATOR_ERROR_EMAIL",tmpval,length)
            if (length>0)
				Settings.ErrorEmail = tmpval(1:length)
        end
    end

    ;;Email server DNS name or IP address
    if (ok)
    begin
        if (CommandLineParser.Parse("mailserver",clValues)) then
        begin
            using clValues.Count select
            (1),
            begin
                Settings.EmailServer = (string)clValues[0]
            end
            (0),
            begin
                log("ERROR: Missing email server name or address after the -mailserver option")
                ok = false
            end
            (),
            begin
                log("ERROR: Only one email server name or address may follow the -mailserver option")
                ok = false
            end
            endusing
        end
        else
        begin
			data tmpval, a128
			xcall getlog("REPLICATOR_SMTP_SERVER",tmpval,length)
            if (length>0)
				Settings.EmailServer = tmpval(1:length)
        end
    end

    ;;Email sender address
    if (ok)
    begin
        if (CommandLineParser.Parse("mailfrom",clValues)) then
        begin
            using clValues.Count select
            (1),
            begin
				Settings.EmailSender = (string)clValues[0]
            end
            (0),
            begin
                log("ERROR: Missing email address after the -mailfrom option")
                ok = false
            end
            (),
            begin
                log("ERROR: Only one email address may follow the -mailfrom option")
                ok = false
            end
            endusing
        end
        else
        begin
			data tmpval, a128
			xcall getlog("REPLICATOR_EMAIL_SENDER",tmpval,length)
            if (length>0)
				Settings.EmailSender = tmpval(1:length)
        end
    end

    ;;Email senders domain
    if (ok)
    begin
        if (CommandLineParser.Parse("maildomain",clValues)) then
        begin
            using clValues.Count select
            (1),
            begin
				Settings.EmailDomain = (string)clValues[0]
            end
            (0),
            begin
                log("ERROR: Missing domain name after the -maildomain option")
                ok = false
            end
            (),
            begin
                log("ERROR: Only one domain name may follow the -maildomain option")
                ok = false
            end
            endusing
        end
        else
        begin
			data tmpval, a128
			xcall getlog("REPLICATOR_EMAIL_DOMAIN",tmpval,length)
            if (length>0)
				Settings.EmailDomain = tmpval(1:length)
        end
    end

    ;;Should the replicator STOP if it encounters an error
    if (ok)
    begin
        if (CommandLineParser.Parse("stoponerror")) then
        begin
            Settings.StopOnError = true
        end
        else
        begin
			data tmpval, a3
			xcall getlog("REPLICATOR_ERROR_STOP",tmpval,length)
			Settings.StopOnError = ((length>0)&&(tmpval.eq."YES"))
        end
    end

    ;;Check if the instruction file exists, if not create it
    if (ok)
	begin
		data exists = true
		try
		begin
			data tmpchn, i4, 0
			open(tmpchn,I:I,D_TRANS_FILE)
			close tmpchn
		end
		catch (e, @Exception)
		begin
			exists = false
		end
		endtry
		if (!exists)
		begin
			try
			begin
				xcall isamc(D_TRANS_FILE + ", FIXED, COMPRESS, PAGE=1024, TBYTE", 65054, 1, "START=1, LENGTH=20, NAME=TRANSACTION_ID") ;Defaults: TYPE=ALPHA, NODUPS, NOMODIFY, ASCEND
			end
			catch (e, @Exception)
			begin
				log("ERROR: Failed to create new " + D_TRANS_FILE)
				ok = false
			end
			endtry
		end
	end

	;;Check if the instruction file exists, if not create it
	if (ok)
	begin
		try
		begin
			data tmpchn, i4, 0
			open(tmpchn,I:I,D_TRANS_FILE)
			close tmpchn
		end
		catch (e, @Synergex.SynergyDE.NoFileFoundException)
		begin
			try
			begin
				xcall isamc(D_TRANS_FILE + ", FIXED, COMPRESS, PAGE=1024, TBYTE", 65054, 1, "START=1, LENGTH=20, NAME=TRANSACTION_ID") ;Defaults: TYPE=ALPHA, NODUPS, NOMODIFY, ASCEND
			end
			catch (e, @Exception)
			begin
				log("ERROR: Failed to create new " + D_TRANS_FILE + " - Error: " + e.Message)
				ok = false
			end
			endtry
		end
		catch (e, @Exception)
		begin
			log("ERROR: Failed to open " + D_TRANS_FILE + " - Error: " + e.Message)
			ok = false
		end
		endtry
	end

	;;Open the instruction file
    if (ok)
    begin
		try
        begin
			data tmpchn, i4, 0
            open(tmpchn,U:I,D_TRANS_FILE)
			Settings.InstructionChannel = tmpchn
        end
        catch (ex)
        begin
            log("ERROR: Failed to open " + D_TRANS_FILE)
            ok = false
        end
        endtry
    end

    ;;Get the database connect string from the logical REPLICATOR_DATABASE
    if (ok)
    begin
        if (CommandLineParser.Parse("database",clValues)) then
        begin
            using clValues.Count select
            (1),
            begin
                Settings.DatabaseConnectString = (string)clValues[0]
            end
            (0),
            begin
                log("ERROR: Missing connect string after the -database option")
                ok = false
            end
            (),
            begin
                log("ERROR: Only one connect string may follow the -database option")
                ok = false
            end
            endusing
        end
        else
        begin
			data tmpval, a256
			xcall getlog("REPLICATOR_DATABASE",tmpval,length)
            if (length) then
				Settings.DatabaseConnectString = tmpval(1:length)
            else
            begin
                ;;No connect string, we're dead!
                log("ERROR: No database connect string was found. Define environment variable REPLICATOR_DATABASE.")
                ok = false
            end
        end
    end

    ;;Enable and Initialize SQL Connection
    if (ok)
    begin
        .ifdef OS_VMS
        xcall init_ssql
        .else
        status = %option(48,1)
        .endc
		Settings.DatabaseChannel = 1
		if (%ssc_init(Settings.DatabaseChannel,D_MAX_CURSORS,D_MAX_COLUMNS)==SSQL_FAILURE)
        begin
            log("ERROR: Failed to initialize SQL Connection")
            ok = false
        end
    end

    ;;Connect to the database
    if (ok)
    begin
		if (%ssc_connect(Settings.DatabaseChannel,Settings.DatabaseConnectString)==SSQL_FAILURE)
        begin
			xcall ssc_getemsg(Settings.DatabaseChannel,dberrtxt,length)
            log("ERROR: Failed to connect to database")
            log(" - Connect string:")
			log("   " + Settings.DatabaseConnectString)
            log(" - Error message :")
            log("   " + dberrtxt(1,length))
            ok = false

            ;;If we're sending emails then let's record the connect failure
            if (Settings.CanSendEmail())
            begin
                data emailStatus, i4
                data body = new string[3]
                body[1] = "Failed to connect to database."
				body[2] = "Connect string: " + Settings.DatabaseConnectString
                body[3] = "Error message:  " + dberrtxt(1,length)
				if ((emailStatus=%SmtpMail(Settings.EmailServer,Settings.EmailDomain,Settings.EmailSender,"SQL Replicator ",,Settings.ErrorEmail,,"Replicator"  + Settings.InstanceName + " ERROR",body)) != SMERR_SUCCESS)
                begin
                    data errorText, string, %TimeStamp + "ERROR: Failed to send startup email. Error was " + %atrim(SmtpErrorText[emailStatus])
                    log(errorText)
                end
            end
        end
    end

    ;;Register a shutdown handler
	if (ok && !Settings.RunningOnTerminal)
        xcall syn_atexit(%xaddr("ReplicatorShutdown"))

    ;;Let the developer see the error message!
	if (!ok && Settings.RunningOnTerminal)
    begin
        data tmpchr, a1
		display(Settings.LogFileChannel,13,10,"Replicator will stop - press a key: ")
		accept(Settings.LogFileChannel,tmpchr)
    end

    ;;Main processing
    if (ok)
    begin
        ;;Create the process ID file
        call RecordProcessID

        ;;Create a namespace to record information about Synergy data files that we have opened.
        Settings.ChannelInfo = %nspc_open(,%size(structure_data))

        log("--- Processing instructions ----------------------")

        ;;If we're sending emails then let's record the server startup
        if (Settings.CanSendEmail())
        begin
            data emailStatus, i4
            data body = new string[1]
            body[1] = "The SQL replicator process was started."
			if ((emailStatus=%SmtpMail(Settings.EmailServer,Settings.EmailDomain,Settings.EmailSender,"SQL Replicator",,Settings.ErrorEmail,,"Replicator " + Settings.InstanceName + " STARTED",body)) != SMERR_SUCCESS)
            begin
                data errorText, string, %TimeStamp + "ERROR: Failed to send startup email. Error was " + %atrim(SmtpErrorText[emailStatus])
                log(errorText)
            end
        end

        ;;Main loop
        repeat
        begin
            ;;Check for outstanding instructions
            call GetInstruction

            if (noMoreInstructions) then
            begin
				sleep Settings.SleepTime
            end
            else
            begin
                switchDone = false

                ;;If this is a routine request (create/update/delete) then do
                ;;file and table checks to ensure we have the file open and the
                ;;database table exists
                if ( (instruction.action==(i)REPLICATION_INSTRUCTION.CREATE_ROW)
                & || (instruction.action==(i)REPLICATION_INSTRUCTION.UPDATE_ROW)
                & || (instruction.action==(i)REPLICATION_INSTRUCTION.DELETE_ROW)
                &   )
                begin
                    ;;Check if we already have the file open
                    call CheckFileTable

                    ;;If we don't have the file open by now then we probably have a configuration problem
                    if (!structure_data.structure_chan)
                    begin
                        log("ERROR: Abnormal replicator shutdown")
                        exitloop
                    end
                end

                ;;Execute the instruction

                using (instruction.action) select

                ;;"Routine" processing requests

                (REPLICATION_INSTRUCTION.CREATE_ROW),
                    call DoInsert

                (REPLICATION_INSTRUCTION.UPDATE_ROW),
                    call DoUpdate

                (REPLICATION_INSTRUCTION.DELETE_ROW),
                    call DoDelete

                ;;"Special" processing requests

                (REPLICATION_INSTRUCTION.CREATE_TABLE),
                    call DoCreateTable

                (REPLICATION_INSTRUCTION.LOAD_TABLE),
                    call DoLoadTable

                (REPLICATION_INSTRUCTION.CREATE_AND_LOAD_TABLE),
                    call DoCreateAndLoadTable

                (REPLICATION_INSTRUCTION.CREATE_CSV),
                    call DoCreateCsv

                (REPLICATION_INSTRUCTION.DELETE_ALL_ROWS),
                    call DoDeleteAllRows

                (REPLICATION_INSTRUCTION.DELETE_TABLE),
                    call DoDeleteTable

                (REPLICATION_INSTRUCTION.CHANGE_INTERVAL),
                    call ChangeInterval

                (REPLICATION_INSTRUCTION.CYCLE_LOG),
                begin
                    cycleLog = true
                    call OpenLogFile
                end

                (REPLICATION_INSTRUCTION.SHUTDOWN),
                begin
                    delete(Settings.InstructionChannel)
                    xcall ReplicatorShutdown
                    stop
                end

                endusing

                ;;Delete the instruction from the instruction file
				delete(Settings.InstructionChannel)

            end

            ;;Reset to first record in instruction file and start over
            try
            begin
				find(Settings.InstructionChannel,,^FIRST)
            end
            catch (ex)
            begin
                nop
            end
            endtry
        end
    end

    ;;Close the database
	if (Settings.DatabaseChannel)
		xcall ssc_release(Settings.DatabaseChannel)

    ;;Release the name space
	if (Settings.ChannelInfo)
		xcall nspc_close(Settings.ChannelInfo)

    ;;Close the instructions file
	if (Settings.InstructionChannel&&%chopen(Settings.InstructionChannel))
		close Settings.InstructionChannel

    ;;All done
    stop

;;-----------------------------------------------------------------------------
;; Look for a pending instruction
;;
GetInstruction,

    repeat
    begin
        try
        begin
			reads(Settings.InstructionChannel,instruction,,LOCK:Q_AUTO_LOCK)
            noMoreInstructions = false
            exitloop
        end
        catch (ex, @EndOfFileException)
        begin
            noMoreInstructions = true
            exitloop
        end
        catch (ex, @RecordLockedException)
        begin
            sleep D_ERROR_TIME
            nextloop
        end
        endtry
    end

    return

;;-----------------------------------------------------------------------------

CheckFileTable,

    ;;Do we already have an entry for this file in our namespace?

	if (nsptr = %nspc_find(Settings.ChannelInfo,instruction.structure_name,structure_data)) then
    begin
        ;;Yes, we're good to go!
        return
    end
    else
    begin
        ;;No, open the file and make sure it worked
        call OpenFile

        ;;If we failed to open the file then we have a serious problem!
        if (!structure_data.structure_chan)
        begin
            log("ERROR: Failed to open ISAM file for structure " + %atrim(instruction.structure_name))
            return
        end

        ;;Get the record size of the file
        try
        begin
            functionName = %atrim(instruction.structure_name) + "_LENGTH"
            structure_data.structure_size = %xsubr(functionName)
        end
        catch (ex, @SynException)
        begin
			ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry

        ;;Search the first unique key. There should always be one, because without one the
        ;;constructor in the I/O hooks class would not activate replication for the file.
        begin
            data thisKey, i4
            structure_data.structure_keynum = -1
            for thisKey from 0 thru %isinfo(structure_data.structure_chan,"NUMKEYS") - 1
            begin
                if (!%isinfo(structure_data.structure_chan,"DUPS",thisKey))
                begin
                    ;;Found it!
                    structure_data.structure_keynum = thisKey
                    exitloop
                end
            end
        end

        ;;Did we find a unique key?
        if (structure_data.structure_keynum>=0) then
        begin
            ;;Report the key that will be used
            debuglog(" - Key " + %string(structure_data.structure_keynum) + " will be used to access the ISAM file")

            ;;And save the structure name
            structure_data.structure_name = instruction.structure_name

            ;;Record the new open file in the namespace
			nsptr = %nspc_add(Settings.ChannelInfo,instruction.structure_name,structure_data)
        end
        else
        begin
            ;;In theory we should never get here because CodeGen should not be able to create the
            ;;required code if no unique key is present.
            ;;But just in case, this will cause the replicator to abort
            close structure_data.structure_chan
            clear structure_data.structure_chan
            log("ERROR: File for structure " + %atrim(instruction.structure_name) + " has no unique key!")
        end
    end

    return

;;-----------------------------------------------------------------------------
;; Open a Synergy data file
;;
OpenFile,

    debuglog("Opening file " + %atrim(instruction.structure_name))

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_IO"
        status = %xsubr(functionName,IO_OPEN_INP,structure_data.structure_chan,,,,,,dberrtxt)
    end
    catch (ex, @SynException)
    begin
		ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    if (status == IO_OK) then
    begin
        debuglog(" - File opened")
        call CheckTable
    end
    else
    begin
        debuglog(" - Failed to open file!")
        clear structure_data.structure_chan
		xcall LogFunctionError(functionName,status,dberrtxt)
    end

    return

;;-----------------------------------------------------------------------------
;; Find out if a table exists in the SQL database. If not create and load it.
;;
CheckTable,

    debuglog("Checking if table " + %atrim(instruction.structure_name) + " exists")

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_EXISTS"
		status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt)
    end
    catch (ex, @SynException)
    begin
		ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    using status select
    (1),
        debuglog(" - Table exists")
    (0),
    begin
        debuglog(" - Table not found!")
        call CreateTable
    end
    (<0),;Error
		xcall LogFunctionError(functionName,status,dberrtxt)
    endusing

    return

;;-----------------------------------------------------------------------------
;; Create and load a new table in the SQL database
;;
CreateTable,

    log("Creating table " + %atrim(instruction.structure_name))

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_CREATE"
		status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt)
    end
    catch (ex, @SynException)
    begin
		ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    if (status) then
    begin
        debuglog(" - Table created")
        call LoadTable
    end
    else
    begin
		xcall LogFunctionError(functionName,status,dberrtxt)
    end

    return

;;-----------------------------------------------------------------------------
;; Perform an initial load of a new table in the SQL database
;;
LoadTable,

    log("Load table " + %atrim(instruction.structure_name) + " starting at " + %TimeNow)

    try
    begin
        data successCount, int, 0
        data failCount, int, 0

        functionName = %atrim(instruction.structure_name) + "_LOAD"

		if (Settings.RunningOnTerminal) then
			status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt,Settings.LogLoadExceptions,Settings.LogFileChannel,successCount,failCount)
        else
			status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt,Settings.LogLoadExceptions,,successCount,failCount)

        if (status) then
        begin
            log(" - Load complete at " + %TimeNow)
            log(" - " + %string(successCount) + " rows inserted, " + %string(failCount) + " rows failed.")
            Counters.Inserts += successCount
            Counters.Errors  += failCount
        end
        else
        begin
			xcall LogFunctionError(functionName,status,dberrtxt)
        end
    end
    catch (ex, @SynException)
    begin
		ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Add a new row
;;
DoInsert,

    if (switchMode) then
    begin
        debuglog(" - Insert row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end
    else
    begin
        debuglog("Insert row in table " + %atrim(instruction.structure_name))
		if (Settings.LogKeys)
        begin
            keyValue = %keyVal(structure_data.structure_chan,instruction.record,structure_data.structure_keynum)
            debugLog(" - Key: " + keyValue)
        end
    end

    try
    begin
        functionName = %atrim(instruction.structure_name) + '_INSERT_ROW'
		status = %xsubr(functionName,Settings.DatabaseChannel,instruction.record(1,structure_data.structure_size),dberrtxt)
    end
    catch (ex, @SynException)
    begin
		ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    using status select
    (0),
    begin
		xcall LogFunctionError(functionName,status,dberrtxt)
    end
    (1),
    begin
        debuglog(" - Row inserted")
        Counters.Inserts += 1
    end
    (2),
    begin
        debuglog(" - Row already exists, switching to UPDATE")
        status = IO_OK
        if (switchDone) then
        begin
            Log("ERROR: Too many INSERT/UPDATE mode switches!")
        end
        else
        begin
            switchMode = true
            call DoUpdate
        end
    end
    endusing

    return

;;-----------------------------------------------------------------------------
;; Update an existing row
;;
DoUpdate,

    if (switchMode) then
    begin
        debuglog(" - Update row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end
    else
    begin
        debuglog("Update row in table " + %atrim(instruction.structure_name))
		if (Settings.LogKeys)
        begin
            keyValue = %keyVal(structure_data.structure_chan,instruction.record,structure_data.structure_keynum)
            debugLog(" - Key: " + keyValue)
        end
    end

    try
    begin
        functionName = %atrim(instruction.structure_name) + '_UPDATE_ROW'
		status = %xsubr(functionName,Settings.DatabaseChannel,instruction.record(1,structure_data.structure_size),rows,dberrtxt)
    end
    catch (ex, @SynException)
    begin
		ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    if (status) then
    begin
        if (rows) then
        begin
            debuglog(" - Row updated")
			Counters.Updates += 1
        end
        else
        begin
            debuglog(" - Row not found, switching to INSERT")
            status = IO_OK
            if (switchDone) then
            begin
                Log("ERROR: Too many INSERT/UPDATE mode switches!")
            end
            else
            begin
                switchDone = true
                call DoInsert
            end
        end
    end
    else
    begin
		xcall LogFunctionError(functionName,status,dberrtxt)
    end

    return

;;-----------------------------------------------------------------------------
;; Delete a row
;;
DoDelete,

    debuglog("Delete row from table " + %atrim(instruction.structure_name))

    keyValue = %keyval(structure_data.structure_chan,instruction.record,structure_data.structure_keynum)

	if (Settings.LogKeys)
        debugLog(" - Key: " + keyValue)

    try
    begin
        functionName = %atrim(instruction.structure_name) + '_DELETE_ROW'
		status = %xsubr(functionName,Settings.DatabaseChannel,(a)keyValue,dberrtxt)
        if (status) then
        begin
            debuglog(" - Row deleted")
			Counters.Deletes += 1
        end
        else
        begin
            debuglog(" - " + dberrtxt)
			xcall LogFunctionError(functionName,status,dberrtxt)
        end
    end
    catch (ex, @SynException)
    begin
		ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Create a new table
;;
DoCreateTable,

    ;;Create a new table (only)
    ;;If the table already exists, do nothing

    debuglog("Create table " + %atrim(instruction.structure_name))
    debuglog(" - Checking if table already exists")

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_EXISTS"
		status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt)
        using status select
        (1),
        begin
            debuglog(" - Table already exists!")
        end
        (0),
        begin
            debuglog(" - Creating table")

            try
            begin
                functionName = %atrim(instruction.structure_name) + "_CREATE"
				status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt)
                if (status) then
                    debuglog(" - Table created")
                else
                    xcall LogFunctionError(functionName,status,dberrtxt)
            end
            catch (ex, @SynException)
            begin
                ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
            end
            endtry
        end
        (<0),
        begin
            xcall LogFunctionError(functionName,status,dberrtxt)
        end
        endusing
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Load new data into existing table
;;
DoLoadTable,

    ;;Do a full load of an existing table with new data
    ;;Delete all existing data before loading new data

    log("Reload table " + %atrim(instruction.structure_name))
    debuglog(" - Checking if table exists")

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_EXISTS"
		status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    using status select
    (1),
    begin
        call DoDeleteAllRows
        call LoadTable
    end
    (0),
    begin
        debuglog(" - Table does not exist!")
    end
    (<0),
    begin
        xcall LogFunctionError(functionName,status,dberrtxt)
    end
    endusing

    return

;;-----------------------------------------------------------------------------
;; Create a new table and load new data into it
;;
DoCreateAndLoadTable,

    ;;Create a new table, do nothing if the table already exists
    ;;We create the table, then do a full load of data

    call CheckTable

    return

;;-----------------------------------------------------------------------------
;; Export ISAM file to CSV file
;;
DoCreateCsv,

    log("Export CSV for " + %atrim(instruction.structure_name) + " starting at " + %TimeNow)

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_CREATE_CSV"
        status = %xsubr(functionName,dberrtxt)
        if (status) then
            debuglog(" - Done at " + %TimeNow)
        else
            xcall LogFunctionError(functionName,status,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Delete all rows from an existing table
;;
DoDeleteAllRows,

    log("Truncating table " + %atrim(instruction.structure_name))

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_CLEAR"
		status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt)
        if (status) then
            debuglog(" - Done")
        else
            xcall LogFunctionError(functionName,status,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Delete an existing table
;;
DoDeleteTable,

    ;;Is the file in the file table?
	if (nsptr=%nspc_find(Settings.ChannelInfo,instruction.structure_name,structure_data))
    begin

        ;Yes - close the file
        if ((structure_data.structure_chan)&&%chopen(structure_data.structure_chan))
        begin
            close structure_data.structure_chan
            clear structure_data
        end

        ;And remove it from the file table
		xcall nspc_delete(Settings.ChannelInfo,nsptr)
    end

    log("Deleting table " + %atrim(instruction.structure_name))

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_DROP"
		status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt)
        if (status) then
            debuglog(" - Done")
        else
            xcall LogFunctionError(functionName,status,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Open the log file

OpenLogFile,

    begin
        data logChannelMode, string

        ;;Are we running on a terminal?
		if (Settings.RunningOnTerminal) then
        begin
            Settings.LogFileName = "TT:"
            logChannelMode = "O"
        end
        else
        begin
            ;;The logical will be used if defined, otherwise current directory will be used
			Settings.LogFileName = "REPLICATOR_LOGDIR:replicator_"+%datetime+".log"
            logChannelMode = "O:S"
        end

        ;;Open the log file
        try
        begin
			data tmpchn, i4

            if (cycleLog)
            begin
				log("Cycling log. New log is " + Settings.LogFileName)
                close Settings.LogFileChannel
                cycleLog = false
				if (Settings.RunningOnTerminal)
                    sleep 0.5
            end

			open(tmpchn,logChannelMode,Settings.LogFileName)
			Settings.LogFileChannel = tmpchn

			if (Settings.RunningOnTerminal)
				display(Settings.LogFileChannel,$scr_pos(1,1),$scr_clr(SCREEN))

            log("SQL Replicator Log")
        end
        catch (ex)
        begin
			if (!Settings.RunningOnTerminal)
				xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE,"Replicator failed to open log file " + Settings.LogFileName + ". Error number " + %string(%ernum))
            ok = false
        end
        endtry
    end

    return

;;-----------------------------------------------------------------------------
;; Record the process ID of the running instance

RecordProcessId,

	if (!Settings.RunningOnTerminal)
    begin
		data pidFileSpec, string, "REPLICATOR_LOGDIR:REPLICATOR_" + Settings.InstanceName + ".PID"
        data pidFileChannel, int

        ;;Open the PID file
        try
        begin
            xcall delet(pidFileSpec)
            open(pidFileChannel=0,o:s,pidFileSpec)
            writes(pidFileChannel,%string(%jbno))
        end
        catch (ex)
        begin
            log("ERROR: Failed to create or write PID file! Error was " + ex.Message)
        end
        finally
        begin
            if (pidFileChannel && %chopen(pidFileChannel))
                close pidFileChannel
        end
        endtry
    end

    return

;;-----------------------------------------------------------------------------
;; Change the sleep seconds interval

ChangeInterval,

    begin
        data save_time, i4, Settings.SleepTime
        try
        begin
			Settings.SleepTime = %integer(%atrim(instruction.record))
			if (Settings.SleepTime >= 1) then
            begin
				log("Sleep time changed from " + %string(save_time) + " to " + %string(Settings.SleepTime) + " seconds")
            end
            else
            begin
				log("ERROR: Invalid sleep time " + %string(Settings.SleepTime) + " requested")
				Settings.SleepTime = save_time
            end
        end
        catch (ex)
        begin
            log("ERROR: Invalid sleep time " + %atrim(instruction.record) + " requested")
			Settings.SleepTime = save_time
        end
        endtry
    end

    return

endmain

;;*****************************************************************************
;;
;; Routine:     ReplicatorShutdown
;;
;; Description: This routine is an event handler which is called when the
;;              replicator service is being stopped by the Windows operating
;;              system, or because a shutdown message was received via the
;;              instructions file.
;;
;; Author:      Steve Ives, Synergex Professional Services Group
;;
;; Created:     10th April 2008
;;
;;*****************************************************************************
;;
;; This code is supplied as seen and without warranty or support, and is used
;; at your own risk. Neither the author or Synergex accept any responsability
;; for any loss or damage which may result from the use of this code. This text
;; must remain unaltered in this file at all times. Possession or use of this
;; code, or any modified version of this code, indicates your acceptance of
;; these conditions.
;;
;;*****************************************************************************
;;
subroutine ReplicatorShutdown

    endparams

    .include "CONNECTDIR:ssql.def"
    .include "DBLDIR:namspc.def"
    .include "INC:structureio.def"
    .include "INC:SmtpMail.def"

    stack record
        idx                 ,i4                 ;;Loop counter
        access_code         ,i4                 ;;Namespace access code
        status              ,i4                 ;;Function return status
        functionName        ,string             ;;External function name to call
        structure_data      ,strStructureData
    endrecord

proc

    log("--------------------------------------------------")
	log("Normal shutdown of SQL replicator " + Settings.InstanceName + ". Summary of activity:")
	log("INSERTS: " + %string(Counters.Inserts,"ZZZ,ZZZ,ZZZ,ZZX"))
	log("UPDATES: " + %string(Counters.Updates,"ZZZ,ZZZ,ZZZ,ZZX"))
	log("DELETES: " + %string(Counters.Deletes,"ZZZ,ZZZ,ZZZ,ZZX"))
	log("ERRORS:  " + %string(Counters.Errors, "ZZZ,ZZZ,ZZZ,ZZX"))
    log("--------------------------------------------------")

    ;;If we're sending emails then let's record the shutdown
    if (Settings.CanSendEmail())
    begin
        data emailStatus, i4
        data body = new string[10]

		body[01] = "<html>"
		body[02] = "<head><title>Replicator Activity Summary</title></head>"
		body[03] = "<body>"
		body[04] = "<p>Summary of activity:</p>"
		body[05] = "<pre>INSERTS: " + %string(Counters.Inserts,"ZZZ,ZZZ,ZZZ,ZZX")
		body[06] =      "UPDATES: " + %string(Counters.Updates,"ZZZ,ZZZ,ZZZ,ZZX")
		body[07] =      "DELETES: " + %string(Counters.Deletes,"ZZZ,ZZZ,ZZZ,ZZX")
		body[08] =      "ERRORS:  " + %string(Counters.Errors, "ZZZ,ZZZ,ZZZ,ZZX") + "</pre>"
		body[09] = "</body>"
		body[10] = "</html>"

		if ((emailStatus=%SmtpMail(Settings.EmailServer,Settings.EmailDomain,Settings.EmailSender,"SQL Replicator",,Settings.ErrorEmail,,"Replicator " + Settings.InstanceName + " STOPPED",body,,true)) != SMERR_SUCCESS)
        begin
            data errorText, string, %TimeStamp + "ERROR: Failed to send startup email. Error was " + %atrim(SmtpErrorText[emailStatus])
            log(errorText)
        end
    end

    ;;Clean up any database cursors and data files that we have open
	if (Settings.ChannelInfo)
    begin
		for idx from 1 thru %nspc_stoa(Settings.ChannelInfo,9999)
        begin
            ;;Get the item data from the namespace
			access_code = %nspc_stoa(Settings.ChannelInfo,idx)
			xcall nspc_getdata(Settings.ChannelInfo,access_code,structure_data)

            ;;Hard close any soft-closed database cursors
            try
            begin
                functionName = %atrim(structure_data.structure_name) + "_CLOSE_CURSORS"
				xcall xsubr(functionName,Settings.DatabaseChannel)
            end
            catch (ex)
            begin
                nop
            end
            endtry

            ;;Close the channel
            if ((structure_data.structure_chan)&&%chopen(structure_data.structure_chan))
            begin
                try
                begin
                    functionName = %atrim(structure_data.structure_name) + "_IO"
                    status = %xsubr(functionName,IO_CLOSE,structure_data.structure_chan)
                end
                catch (ex)
                begin
                    nop
                end
                endtry
            end
        end

		xcall nspc_close(Settings.ChannelInfo)
		Settings.ChannelInfo = 0

    end

    ;;Close our connection to the database
	if (Settings.DatabaseChannel)
    begin
		xcall ssc_release(Settings.DatabaseChannel)
		Settings.DatabaseChannel = 0
    end

    ;;Close the instructions file
	if (Settings.InstructionChannel)
    begin
		close Settings.InstructionChannel
		Settings.InstructionChannel = 0
    end

    ;;Delete the PID file
	if (!Settings.RunningOnTerminal)
    begin
		data pidFileSpec, string, "REPLICATOR_LOGDIR:REPLICATOR_" + Settings.InstanceName + ".PID"
        xcall delet(pidFileSpec)
    end

	if (Settings.RunningOnTerminal)
    begin
        log("Replicator will stop in 2 seconds")
        sleep 2
    end

    xreturn

endsubroutine

;;*****************************************************************************
;;
subroutine LogFunctionError
    required in functionName, string
    required in errorNumber, int
    required in errorMessage, string
    endparams
    .include "INC:SmtpMail.def"
    stack record
        errorText           ,string
    endrecord
proc

    errorText = %TimeStamp+"ERROR: Function" + functionName + " returned error " + %string(errorNumber) + ": " + %atrim(errorMessage)

    ;;Log the error
	writes(Settings.LogFileChannel,errorText)

    ;;Email the error?
    if (Settings.CanSendEmail())
    begin
        data emailStatus, i4
        data body = new string[3]
        if (Settings.StopOnError) then
            body[1] = "The SQL Replicator encountered the following error and will STOP processing:"
        else
            body[1] = "The SQL Replicator encountered the following error and will CONTINUE processing:"
        body[2] = ""
        body[3] = errorText
		if ((emailStatus=%SmtpMail(Settings.EmailServer,Settings.EmailDomain,Settings.EmailSender,"SQL Replicator",,Settings.ErrorEmail,,"Replicator " + Settings.InstanceName + " ERROR",body)) != SMERR_SUCCESS)
        begin
            errorText = %TimeStamp+"ERROR: Failed to send error email. Error was " + %atrim(SmtpErrorText[emailStatus])
			writes(Settings.LogFileChannel,errorText)
        end
    end

    ;;Stop processing?
	if (Settings.StopOnError)
    begin
        xcall ReplicatorShutdown
        stop
    end

    xreturn

endsubroutine

;;*****************************************************************************
;;
function LogFunctionFail, boolean
    required in functionName, string
    required in errorNumber, int
    required in errorMessage, string
    endparams
    .include "INC:SmtpMail.def"
    stack record
        errorText           ,string
    endrecord
proc

    errorText = %TimeStamp+"ERROR: Function " + functionName + " failed with error " + %string(errorNumber) + ": " + %atrim(errorMessage)

    ;;Log the error
	writes(Settings.LogFileChannel,errorText)

    ;;Email the error?
	if (Settings.CanSendEmail())
    begin
        data emailStatus, i4
        data body = new string[3]
		if (Settings.StopOnError) then
            body[1] = "The SQL Replicator encountered the following error and will STOP processing:"
        else
            body[1] = "The SQL Replicator encountered the following error and will CONTINUE processing:"
        body[2] = ""
        body[3] = errorText
		if ((emailStatus=%SmtpMail(Settings.EmailServer,Settings.EmailDomain,Settings.EmailSender,"SQL Replicator",,Settings.ErrorEmail,,"Replicator " + Settings.InstanceName + " ERROR",body)) != SMERR_SUCCESS)
        begin
            errorText = %TimeStamp+"ERROR: Failed to send error email. Error was " + %atrim(SmtpErrorText[emailStatus])
			writes(Settings.LogFileChannel,errorText)
        end
    end

    ;;Stop processing?
	if (Settings.StopOnError)
    begin
        xcall ReplicatorShutdown
        stop
    end

    freturn false

endfunction

;;*****************************************************************************
;;
function TimeStamp, string
proc
	if (Settings.RunningOnTerminal) then
        freturn ""
    else
    begin
        freturn %TimeNow
    end
endfunction

;;*****************************************************************************
;;
function TimeNow, string
    record
        now, d20
    endrecord
proc
    now = %datetime
    freturn %string(now(1:14),"XXXX-XX-XX XX:XX:XX ")
endfunction

;;*****************************************************************************

namespace Tools

	;;; <summary>
	;;; Parses and returns information about the command line that started the program.
	;;; </summary>
    public class CommandLineParser

        public static method Parse, boolean
            required in a_opt, String           ;;Option string to search for
            endparams

            stack record
                optvals, @ArrayList             ;Returned option values
            endrecord

        proc
            mreturn Parse(a_opt,optvals=new ArrayList())
        endmethod

        public static method Parse, boolean
            required in  a_opt          ,String         ;;Option string to search for
            required out a_optvals      ,@ArrayList     ;;Returned option values
            endparams

.define MAXARGS 256

            stack record localData
                fstatus         ,boolean                ;;Function return status
                command         ,a8192                  ;;Whole command line
                num_args        ,i4                     ;;Number of arguments in whole command line
                arg_pos         ,[MAXARGS] i4           ;;Positions of arguments in whole command line
                arg_len         ,[MAXARGS] i4           ;;Lengths of arguments in whole command line
                current_arg     ,i4                     ;;Index of current argument being processed
                opt_char        ,a1                     ;;Character that precedes options (- or /)
                option_value    ,String
            endrecord

.undefine MAXARGS

        proc
            init localData

            fstatus = false
            a_optvals = new ArrayList()

            if (%option(34)) then
                opt_char = '/'
            else
                opt_char = '-'

            xcall cmdln(command, num_args, arg_pos, arg_len)

            for current_arg from 1 thru num_args
            begin
                if (arg_pos[current_arg]&&arg_len[current_arg]) then
                    option_value = command(arg_pos[current_arg]:arg_len[current_arg])
                else
                    option_value = ""

                ;;Is this the requested option?
                if (option_value.eqs.(opt_char+a_opt))
                    call process_argument
            end

            mreturn fstatus

        process_argument,

            ;;Found requested option
            fstatus = true

            ;;Process next argument
            current_arg += 1

            if (arg_pos[current_arg]&&arg_len[current_arg]) then
                option_value = command(arg_pos[current_arg]:arg_len[current_arg])
            else
                option_value = opt_char

            ;;DO NOT CHANGE THE .ne. OPERATOR to != ... THEY ARE NOT THE SAME THING WITH STRING!
            while(option_value.ne.opt_char)
            begin
                ;;Strip leading and trailing quote characters
                using option_value select
                ("'", '"'),
                begin
                    if ((option_value.Length>1)&&(option_value(option_value.Length:1)==option_value(1:1)))
                    begin
                        if (option_value.Length>2) then
                            option_value = option_value(2,option_value.Length-1)
                        else
                            option_value = ""
                    end
                end
                endusing

                ;;Add the value to the returned collection
                a_optvals.Add(option_value)

                ;;Process next argument
                current_arg+=1

                if (arg_pos[current_arg]&&arg_len[current_arg]) then
                    option_value = command(arg_pos[current_arg]:arg_len[current_arg])
                else
                    option_value = opt_char
            end

            ;;Adjust counter to stay in correct position in loop
            current_arg -= 1
            return

        endmethod

    endclass

	public class Counters

		public static Inserts, int

		public static Updates, int

		public static Deletes, int

		public static Errors, int

	endclass

	;;; <summary>
	;;; Represents various settings used within the replicator application.
	;;; </summary>
	public class Settings

		;;; <summary>
		;;; A synergy namespace used to store information about SDMS channels that the replicator currently has open
		;;; </summary>
		public static property ChannelInfo, i4
			method get
			endmethod
			method set
			endmethod
		endproperty

		;;; <summary>
		;;; The SQL Connection database channel that represents our connection to the database.
		;;; </summary>
		public static property DatabaseChannel, i4
			method get
			endmethod
			method set
			endmethod
		endproperty

		;;; <summary>
		;;; Database connection string.
		;;; </summary>
		public static property DatabaseConnectString, string
			method get
			endmethod
			method set
			endmethod
		endproperty

		private static mInstanceName, string

		;;; <summary>
		;;; The name of the replicator instance. The default instance name is DEFAULT. The instance name is used to
		;;; discriminate between multiple instances of the replicator that might be active, each processing different
		;;; data sets.
		;;; </summary>
		public static property InstanceName, string
			method get
			proc
				mreturn mInstanceName
			endmethod
			method set
			proc
				mInstanceName = value.ToUpper()
			endmethod
		endproperty

		;;; <summary>
		;;; The channel number of the replication instruction file.
		;;; </summary>
		public static property InstructionChannel, i4
			method get
			endmethod
			method set
			endmethod
		endproperty

		;;; <summary>
		;;; The email address or addresses to send status messages to.
		;;; One or more email addresses seperated by commas.
		;;; </summary>
		public static property ErrorEmail, string
			method get
			endmethod
			method set
			endmethod
		endproperty

		;;; <summary>
		;;; The DNS name or IP address of the SMTP server to use to send email messages.
		;;; The SMTP server must be configured to accept messages from unauthenticated sources.
		;;; </summary>
		public static property EmailServer, string
			method get
			endmethod
			method set
			endmethod
		endproperty

		;;; <summary>
		;;; The email address to be used as the sender of status messages.
		;;; </summary>
		public static property EmailSender, string
			method get
			endmethod
			method set
			endmethod
		endproperty

		;;; <summary>
		;;; The DNS domain name of the email sender.
		;;; </summary>
		public static property EmailDomain, string
			method get
			endmethod
			method set
			endmethod
		endproperty

		;;; <summary>
		;;; Are we doing full logging?
		;;; </summary>
		public static property FullLogging, boolean
			method get
			endmethod
			method set
			endmethod
		endproperty

		;;; <summary>
		;;; The channel number of the replicator log file.
		;;; This will be the terminal channel if the replicator is running interactively.
		;;; </summary>
		public static property LogFileChannel, i4
			method get
			endmethod
			method set
			endmethod
		endproperty

		;;; <summary>
		;;; The name of the replicator log file.
		;;; If running in interactive mode this will be TT:
		;;; </summary>
		public static property LogFileName, string
			method get
			endmethod
			method set
			endmethod
		endproperty

		;;; <summary>
		;;; Include key data in debug logs?
		;;; </summary>
		public static property LogKeys, boolean
			method get
			endmethod
			method set
			endmethod
		endproperty

		;;; <summary>
		;;; Log bulk load exceptions to a log file?
		;;; </summary>
		public static property LogLoadExceptions, boolean
			method get
			endmethod
			method set
			endmethod
		endproperty

		;;; <summary>
		;;; Are we attached to a terminal?
		;;; </summary>
		public static property RunningOnTerminal, boolean
			method get
			endmethod
			method set
			endmethod
		endproperty

		;;; <summary>
		;;; How many seconds should we sleep when we run out of instructions to process?
		;;; </summary>
		public static property SleepTime, int
			method get
			endmethod
			method set
			endmethod
		endproperty

		;;; <summary>
		;;; Should we stop processing and close if we encounter an error?
		;;; </summary>
		public static property StopOnError, boolean
			method get
			endmethod
			method set
			endmethod
		endproperty

		;;; <summary>
		;;; Are we able to send email messages. In order for this to return true we must have values
		;;; for EmailError, EmailServer, EmailSender and EmailDomain.
		;;; </summary>
		;;; <returns>Returns true if we have all the data, but does not guarantee that email can be sent!</returns>
		public static method CanSendEmail, boolean
		proc
			mreturn (ErrorEmail != ^null && ErrorEmail.Length>0 && EmailServer != ^null && EmailServer.Length>0 && EmailSender != ^null && EmailSender.Length>0 && EmailDomain != ^null && EmailDomain.Length>0)
		endmethod

	endclass

endnamespace