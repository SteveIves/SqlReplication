;;*****************************************************************************
;;
;; File:        replicator.dbl
;;
;; Type:        Application (replicator)
;;
;; Description: Replicates Synergy data file changes that have been recorded
;;              in the replucation log file to a SQL Server database.
;;
;;*****************************************************************************
;;
;; Copyright (c) 2008, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import SynPSG.ReplicationDemo

structure strStructureData
    structure_name      ,a32    ;;Name of structure
    structure_chan      ,i4     ;;ISAM channel being used
    structure_size      ,i4     ;;Record length
    structure_keynum    ,i4     ;;Key number of unique key being used
endstructure

main replicator

    .include "CONNECTDIR:ssql.def"
    .include "INC:structureio.def"
    .include "INC:SmtpMail.def"
    .include "REPLICATION" repository, record="instruction", end

    .define D_MAX_CURSORS   128
    .define D_MAX_COLUMNS   254

    .define D_TRANS_FILE    "DAT:REPLICATION.ISM"
    .define D_SLEEP_TIME    60                  ;;Seconds to sleep
    .define D_ERROR_TIME    0.5                 ;;Time to sleep after an error

    .define log(x)          writes(logFileChannel,%TimeStamp+%atrim(x))
    .define debuglog(x)     if (fullLogging) writes(logFileChannel,%TimeStamp+%atrim(x))

    .align
    global common
        instanceName        ,a40                ;;The name of the running instance
        runningOnTerminal   ,boolean            ;;Program is running on a terminal
        db                  ,i4                 ;;Database channel
        nsid                ,i4                 ;;Name space id
        instructionChannel  ,i4                 ;;Instruction file channel
        logFileChannel      ,i4                 ;;Log file channel
        inserts             ,i4                 ;;Create operations completed
        updates             ,i4                 ;;Update operations completed
        deletes             ,i4                 ;;Delete operations completed
        fails               ,i4                 ;;Failed operations
    endcommon

    global common
        errorEmail          ,a512
        emailServer         ,a80
        emailSender         ,a80
        emailDomain         ,a80
        logFileSpec         ,a80
        stopOnError         ,boolean
    endcommon

    .align
    record
        ok                  ,boolean            ;;Main status
        noMoreInstructions  ,boolean            ;;End of instruction file
        fullLogging         ,boolean            ;;Are we doing full logging?
        logKeys             ,boolean            ;;Include key data in debug logs
        switchMode          ,boolean            ;;Switched from INSERT to UPDATE or vice versa
        logLoadExceptions   ,boolean            ;;Log bulk load exceptions to a log file?
        cycleLog            ,boolean            ;;Cycle the log file
        switchDone          ,boolean            ;;Have we tried to switch modes before?
        sleep_time          ,i4                 ;;Seconds to sleep
        errnum              ,i4                 ;;Error number
        nsptr               ,i4                 ;;Namespace pointer
        dberr               ,i4                 ;;Database error
        length              ,i4                 ;;Length of buffer
        status              ,i4                 ;;General working status return
        rows                ,i4                 ;;Number of rows affected
        functionName        ,string             ;;External function to call
        primaryKey          ,string             ;;Primary key of current record
        db_connect          ,string             ;;Database connect string
        dberrtxt            ,a1024
        structure_data      ,strStructureData
        databuffer          ,a65535             ;;Data buffer used to read ISAM files
    endrecord

    external function
        xsubr               ,^val
    endexternal

proc

    ok = true
    xcall flags(7004020,1)

    ;;Open the ELB containing the SynIO and SqlIO code
    xcall openelb("EXE:library.elb")

    ;;Do we have a terminal attached or are we a detached process or service?
    ;;If we're running on a terminal we will log to the terminal, if not we will
    ;;log to a log file.
    runningOnTerminal = (%tnmbr>=0)

    if (!runningOnTerminal)
    begin
        ;;Get the name of the instance
        xcall getlog("REPLICATOR_INSTANCE",databuffer,length)
        if (length) then
            instanceName = databuffer(1:length)
        else
            instanceName = %string(%jbno)
    end

    ;;Set the sleep time between processing runs
    xcall getlog("REPLICATOR_INTERVAL",databuffer,length)
    sleep_time = length ? %integer(databuffer(1:length)) : D_SLEEP_TIME

    ;;Set the logging level
    xcall getlog("REPLICATOR_FULL_LOG",databuffer,length)
    fullLogging = ((length>0)&&(databuffer.eq."YES"))

    ;;Should we log keys?
    xcall getlog("REPLICATOR_LOG_KEYS",databuffer,length)
    logKeys = ((length>0)&&(databuffer.eq."YES"))

    ;;Should we log data exceptions to a log file when doing a bulk load?
    xcall getlog("REPLICATOR_LOG_BULK_LOAD_EXCEPTIONS",databuffer,length)
    logLoadExceptions = ((length>0)&&(databuffer.eq."YES"))

    ;;Open the log
    call OpenLogFile

    ;;Should we send email messages when errors occur?
    xcall getlog("REPLICATOR_ERROR_EMAIL",databuffer,length)
    if ((length>0)&&databuffer)
        errorEmail = databuffer

    ;;Email server DNS name or IP address
    xcall getlog("REPLICATOR_SMTP_SERVER",databuffer,length)
    if ((length>0)&&databuffer)
        emailServer = databuffer

    ;;Email sender address
    xcall getlog("REPLICATOR_EMAIL_SENDER",databuffer,length)
    if ((length>0)&&databuffer)
        emailSender = databuffer

    ;;Email senders domain
    xcall getlog("REPLICATOR_EMAIL_DOMAIN",databuffer,length)
    if ((length>0)&&databuffer)
        emailDomain = databuffer

    ;;Should the replicator STOP if it encounters an error
    xcall getlog("REPLICATOR_ERROR_STOP",databuffer,length)
    stopOnError = ((length>0)&&(databuffer.eq."YES"))

    ;;Open the instruction file
    if (ok)
    begin
        try
        begin
            open(instructionChannel=0,U:I,D_TRANS_FILE)
        end
        catch (ex)
        begin
            log("ERROR: Failed to open " + D_TRANS_FILE)
            ok = false
        end
        endtry
    end

    ;;Get the database connect string from the logical REPLICATOR_DATABASE
    if (ok)
    begin
        xcall getlog("REPLICATOR_DATABASE",databuffer,length)
        if (length) then
            db_connect = databuffer(1:length)
        else
        begin
            ;;No connect string, we're dead!
            log("ERROR: No database connect string was found. Define environment variable REPLICATOR_DATABASE.")
            ok = false
        end
    end

    ;;Enable and Initialize SQL Connection
    if (ok)
    begin
        .ifdef OS_VMS
        xcall init_ssql
        .else
        status = %option(48,1)
        .endc
        if (%ssc_init(db=1,D_MAX_CURSORS,D_MAX_COLUMNS)==SSQL_FAILURE)
        begin
            log("ERROR: Failed to initialize SQL Connection")
            ok = false
        end
    end

    ;;Connect to the database
    if (ok)
    begin
        if (%ssc_connect(db,db_connect)==SSQL_FAILURE)
        begin
            xcall ssc_getemsg(db,dberrtxt,length)
            log("ERROR: Failed to connect to database")
            log(" - Connect string:")
            log("   " + db_connect)
            log(" - Error message :")
            log("   " + dberrtxt(1,length))
            ok = false

            ;;If we're sending emails then let's record the connect failure
            if (errorEmail && emailServer && emailSender && emailDomain)
            begin
                data emailStatus, i4
                data body, [3]a512
                body[1] = "The SQL replicator process failed to connect to the database."
                body[2] = "Connect string: " + db_connect
                body[3] = "Error message:  " + dberrtxt(1,length)
                if ((emailStatus=%SmtpMail(emailServer,emailDomain,emailSender,"SQL Replicator",,errorEmail,,"Replicator FAILED TO CONNECT TO DATABASE",body)) != SMERR_SUCCESS)
                begin
                    data errorText, string, %TimeStamp + "ERROR: Failed to send startup email. Error was " + %atrim(SmtpErrorText[emailStatus])
                    log(errorText)
                end
            end
        end
    end

    ;;Register a shutdown handler
    if (ok && !runningOnTerminal)
        xcall syn_atexit(%xaddr("ReplicatorShutdown"))

    ;;Let the developer see the error message!
    if (!ok && runningOnTerminal)
    begin
        data tmpchr, a1
        display(logFileChannel,13,10,"Replicator will stop - press a key: ")
        accept(logFileChannel,tmpchr)
    end

    ;;Main processing
    if (ok)
    begin
        ;;Create the process ID file
        call RecordProcessID

        ;;Create a namespace to record information about Synergy data files that we have opened.
        nsid = %nspc_open(,%size(structure_data))

        log("--- Processing instructions ----------------------")

        ;;If we're sending emails then let's record the server startup
        if (errorEmail && emailServer && emailSender && emailDomain)
        begin
            data emailStatus, i4
            data body, [1]a80
            body[1] = "The SQL replicator process was started."
            if ((emailStatus=%SmtpMail(emailServer,emailDomain,emailSender,"SQL Replicator",,errorEmail,,"Replicator STARTED",body)) != SMERR_SUCCESS)
            begin
                data errorText, string, %TimeStamp + "ERROR: Failed to send startup email. Error was " + %atrim(SmtpErrorText[emailStatus])
                log(errorText)
            end
        end

        ;;Main loop
        repeat
        begin
            ;;Check for outstanding instructions
            call GetInstruction

            if (noMoreInstructions) then
            begin
                ;if (runningOnTerminal)
                ;    debuglog("Sleeping for " + %string(sleep_time) + " seconds...")
                sleep sleep_time
            end
            else
            begin
                switchDone = false

                ;;If this is a routine request (create/update/delete) then do
                ;;file and table checks to ensure we have the file open and the
                ;;database table exists
                if ( (instruction.action==(i)REPLICATION_INSTRUCTION.CREATE_ROW)
                & || (instruction.action==(i)REPLICATION_INSTRUCTION.UPDATE_ROW)
                & || (instruction.action==(i)REPLICATION_INSTRUCTION.DELETE_ROW)
                &   )
                begin
                    ;;Check if we already have the file open
                    call CheckFileTable

                    ;;If we don't have the file open by now then we probably have a configuration problem
                    if (!structure_data.structure_chan)
                    begin
                        log("ERROR: Abnormal replicator shutdown")
                        exitloop
                    end
                end

                ;;Execute the instruction

                using (instruction.action) select

                ;;"Routine" processing requests

                (REPLICATION_INSTRUCTION.CREATE_ROW),
                    call DoInsert

                (REPLICATION_INSTRUCTION.UPDATE_ROW),
                    call DoUpdate

                (REPLICATION_INSTRUCTION.DELETE_ROW),
                    call DoDelete

                ;;"Special" processing requests

                (REPLICATION_INSTRUCTION.CREATE_TABLE),
                    call DoCreateTable

                (REPLICATION_INSTRUCTION.LOAD_TABLE),
                    call DoLoadTable

                (REPLICATION_INSTRUCTION.CREATE_AND_LOAD_TABLE),
                    call DoCreateAndLoadTable

                (REPLICATION_INSTRUCTION.CREATE_CSV),
                    call DoCreateCsv

                (REPLICATION_INSTRUCTION.DELETE_ALL_ROWS),
                    call DoDeleteAllRows

                (REPLICATION_INSTRUCTION.DELETE_TABLE),
                    call DoDeleteTable

                (REPLICATION_INSTRUCTION.CHANGE_INTERVAL),
                    call ChangeInterval

                (REPLICATION_INSTRUCTION.CYCLE_LOG),
                begin
                    cycleLog = true
                    call OpenLogFile
                end

                (REPLICATION_INSTRUCTION.SHUTDOWN),
                begin
                    delete(instructionChannel)
                    xcall ReplicatorShutdown
                    stop
                end

                endusing

                ;;Delete the instruction from the instruction file
                delete(instructionChannel)

            end

            ;;Reset to first record in instruction file and start over
            try
            begin
                find(instructionChannel,,^FIRST)
            end
            catch (ex)
            begin
                nop
            end
            endtry
        end
    end

    ;;Close the database
    if (db)
        xcall ssc_release(db)

    ;;Release the name space
    if (nsid)
        xcall nspc_close(nsid)

    ;;Close the instructions file
    if (instructionChannel&&%chopen(instructionChannel))
        close instructionChannel

    ;;All done
    stop

;;-----------------------------------------------------------------------------
;; Look for a pending instruction
;;
GetInstruction,

    repeat
    begin
        try
        begin
            reads(instructionChannel,instruction,,LOCK:Q_AUTO_LOCK)
            noMoreInstructions = false
            exitloop
        end
        catch (ex, @EndOfFileException)
        begin
            noMoreInstructions = true
            exitloop
        end
        catch (ex, @RecordLockedException)
        begin
            sleep D_ERROR_TIME
            nextloop
        end
        endtry
    end

    return

;;-----------------------------------------------------------------------------

CheckFileTable,

    ;;Do we already have an entry for this file in our namespace?

    if (nsptr = %nspc_find(nsid,instruction.structure_name,structure_data)) then
    begin
        ;;Yes, we're good to go!
        return
    end
    else
    begin
        ;;No, open the file and make sure it worked
        call OpenFile

        ;;If we failed to open the file then we have a serious problem!
        if (!structure_data.structure_chan)
        begin
            log("ERROR: Failed to open ISAM file for structure " + %atrim(instruction.structure_name))
            return
        end

        ;;Get the record size of the file
        try
        begin
            functionName = %atrim(instruction.structure_name) + "_LENGTH"
            structure_data.structure_size = %xsubr(functionName)
        end
        catch (ex, @SynException)
        begin
            ok = %LogFunctionFail(logFileChannel,functionName,ex.Errno,ex.Message)
            return
        end
        endtry

        ;;Search the first unique key. There should always be one, because without one the
        ;;constructor in the I/O hooks class would not activate replication for the channel.
        begin
            data thisKey, i4
            structure_data.structure_keynum = -1
            for thisKey from 0 thru %isinfo(structure_data.structure_chan,"NUMKEYS") - 1
            begin
                if (!%isinfo(structure_data.structure_chan,"DUPS",thisKey))
                begin
                    ;;Found it!
                    structure_data.structure_keynum = thisKey
                    exitloop
                end
            end
        end

        ;;Did we find a unique key?
        if (structure_data.structure_keynum>=0) then
        begin
            ;;Report the key that will be used
            debuglog(" - Key " + %string(structure_data.structure_keynum) + " will be used to access the ISAM file")

            ;;And save the structure name
            structure_data.structure_name = instruction.structure_name

            ;;Record the new open file in the namespace
            nsptr = %nspc_add(nsid,instruction.structure_name,structure_data)
        end
        else
        begin
            ;;In theory we should never get here because CodeGen should not be able to create the
            ;;required code if no unique key is present.
            ;;But just in case, this will cause the replicator to abort
            close structure_data.structure_chan
            clear structure_data.structure_chan
            log("ERROR: File for structure " + %atrim(instruction.structure_name) + " has no unique key!")
        end
    end

    return

;;-----------------------------------------------------------------------------
;; Open a Synergy data file
;;
OpenFile,

    debuglog("Opening file " + %atrim(instruction.structure_name))

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_IO"
        status = %xsubr(functionName,IO_OPEN_INP,structure_data.structure_chan,,,,,,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logFileChannel,functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    if (status == IO_OK) then
    begin
        debuglog(" - File opened")
        call CheckTable
    end
    else
    begin
        debuglog(" - Failed to open file!")
        clear structure_data.structure_chan
        xcall LogFunctionError(logFileChannel,functionName,status,dberrtxt)
    end

    return

;;-----------------------------------------------------------------------------
;; Find out if a table exists in the SQL database. If not create and load it.
;;
CheckTable,

    debuglog("Checking if table " + %atrim(instruction.structure_name) + " exists")

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_EXISTS"
        status = %xsubr(functionName,db,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logFileChannel,functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    using status select
    (1),
        debuglog(" - Table exists")
    (0),
    begin
        debuglog(" - Table not found!")
        call CreateTable
    end
    (<0),;Error
        xcall LogFunctionError(logFileChannel,functionName,status,dberrtxt)
    endusing

    return

;;-----------------------------------------------------------------------------
;; Create and load a new table in the SQL database
;;
CreateTable,

    log("Creating table " + %atrim(instruction.structure_name))

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_CREATE"
        status = %xsubr(functionName,db,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logFileChannel,functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    if (status) then
    begin
        debuglog(" - Table created")
        call LoadTable
    end
    else
    begin
        xcall LogFunctionError(logFileChannel,functionName,status,dberrtxt)
    end

    return

;;-----------------------------------------------------------------------------
;; Perform an initial load of a new table in the SQL database
;;
LoadTable,

    log("Load table " + %atrim(instruction.structure_name) + " starting at " + %TimeNow)

    try
    begin
        data successCount, int, 0
        data failCount, int, 0

        functionName = %atrim(instruction.structure_name) + "_LOAD"

        if (runningOnTerminal) then
            status = %xsubr(functionName,db,dberrtxt,logLoadExceptions,logFileChannel,successCount,failCount)
        else
            status = %xsubr(functionName,db,dberrtxt,logLoadExceptions,,successCount,failCount)

        if (status) then
        begin
            log(" - Load complete at " + %TimeNow)
            log(" - " + %string(successCount) + " rows inserted, " + %string(failCount) + " rows failed.")
            inserts += successCount
            fails   += failCount
        end
        else
        begin
            xcall LogFunctionError(logFileChannel,functionName,status,dberrtxt)
        end
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logFileChannel,functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Add a new row
;;
DoInsert,

    if (switchMode) then
    begin
        debuglog(" - Insert row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end
    else
    begin
        debuglog("Insert row in table " + %atrim(instruction.structure_name))
        call ReadSynergyRecord
    end

    if ((status==IO_OK)&&(databuffer))
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + '_INSERT_ROW'
            status = %xsubr(functionName,db,databuffer(1,structure_data.structure_size),dberrtxt)
        end
        catch (ex, @SynException)
        begin
            ok = %LogFunctionFail(logFileChannel,functionName,ex.Errno,ex.Message)
            return
        end
        endtry
    end

    using status select
    (0),
    begin
        xcall LogFunctionError(logFileChannel,functionName,status,dberrtxt)
    end
    (1),
    begin
        debuglog(" - Row inserted")
        inserts+=1
    end
    (2),
    begin
        debuglog(" - Row already exists, switching to UPDATE")
        status = IO_OK
        if (switchDone) then
        begin
            Log("ERROR: Too many INSERT/UPDATE mode switches!")
        end
        else
        begin
            switchMode = true
            call DoUpdate
        end
    end
    endusing

    return

;;-----------------------------------------------------------------------------
;; Update an existing row
;;
DoUpdate,

    if (switchMode) then
    begin
        debuglog(" - Update row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end
    else
    begin
        debuglog("Update row in table " + %atrim(instruction.structure_name))
        call ReadSynergyRecord
    end

    ;; Check that a record was returned before calling update because the record
    ;; may have been deleted since. If so just ignore the instruction.

    if ((status==IO_OK)&&(databuffer))
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + '_UPDATE_ROW'
            status = %xsubr(functionName,db,databuffer(1,structure_data.structure_size),rows,dberrtxt)
        end
        catch (ex, @SynException)
        begin
            ok = %LogFunctionFail(logFileChannel,functionName,ex.Errno,ex.Message)
            return
        end
        endtry
    end

    if (status) then
    begin
        if (rows) then
        begin
            debuglog(" - Row updated")
            updates+=1
        end
        else
        begin
            debuglog(" - Row not found, switching to INSERT")
            status = IO_OK
            if (switchDone) then
            begin
                Log("ERROR: Too many INSERT/UPDATE mode switches!")
            end
            else
            begin
                switchDone = true
                call DoInsert
            end
        end
    end
    else
    begin
        xcall LogFunctionError(logFileChannel,functionName,status,dberrtxt)
    end

    return

;;-----------------------------------------------------------------------------
;; Delete a row
;;
DoDelete,

    debuglog("Delete row from table " + %atrim(instruction.structure_name))

    if (logKeys)
        debugLog(" - Key: " + %atrim(instruction.key))

    try
    begin
        functionName = %atrim(instruction.structure_name) + '_DELETE_ROW'
        status = %xsubr(functionName,db,instruction.key,dberrtxt)
        if (status) then
        begin
            debuglog(" - Row deleted")
            deletes+=1
        end
        else
        begin
            debuglog(" - " + dberrtxt)
            xcall LogFunctionError(logFileChannel,functionName,status,dberrtxt)
        end
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logFileChannel,functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Create a new table
;;
DoCreateTable,

    ;;Create a new table (only)
    ;;If the table already exists, do nothing

    debuglog("Create table " + %atrim(instruction.structure_name))
    debuglog(" - Checking if table already exists")

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_EXISTS"
        status = %xsubr(functionName,db,dberrtxt)
        using status select
        (1),
        begin
            debuglog(" - Table already exists!")
        end
        (0),
        begin
            debuglog(" - Creating table")

            try
            begin
                functionName = %atrim(instruction.structure_name) + "_CREATE"
                status = %xsubr(functionName,db,dberrtxt)
                if (status) then
                    debuglog(" - Table created")
                else
                    xcall LogFunctionError(logFileChannel,functionName,status,dberrtxt)
            end
            catch (ex, @SynException)
            begin
                ok = %LogFunctionFail(logFileChannel,functionName,ex.Errno,ex.Message)
            end
            endtry
        end
        (<0),
        begin
            xcall LogFunctionError(logFileChannel,functionName,status,dberrtxt)
        end
        endusing
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logFileChannel,functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Load new data into existing table
;;
DoLoadTable,

    ;;Do a full load of an existing table with new data
    ;;Delete all existing data before loading new data

    log("Reload table " + %atrim(instruction.structure_name))
    debuglog(" - Checking if table exists")

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_EXISTS"
        status = %xsubr(functionName,db,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logFileChannel,functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    using status select
    (1),
    begin
        call DoDeleteAllRows
        call LoadTable
    end
    (0),
    begin
        debuglog(" - Table does not exist!")
    end
    (<0),
    begin
        xcall LogFunctionError(logFileChannel,functionName,status,dberrtxt)
    end
    endusing

    return

;;-----------------------------------------------------------------------------
;; Create a new table and load new data into it
;;
DoCreateAndLoadTable,

    ;;Create a new table, do nothing if the table already exists
    ;;We create the table, then do a full load of data

    call CheckTable

    return

;;-----------------------------------------------------------------------------
;; Export ISAM file to CSV file
;;
DoCreateCsv,

    log("Export CSV for " + %atrim(instruction.structure_name) + " starting at " + %TimeNow)

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_CREATE_CSV"
        status = %xsubr(functionName,dberrtxt)
        if (status) then
            debuglog(" - Done at " + %TimeNow)
        else
            xcall LogFunctionError(logFileChannel,functionName,status,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logFileChannel,functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Delete all rows from an existing table
;;
DoDeleteAllRows,

    log("Truncating table " + %atrim(instruction.structure_name))

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_CLEAR"
        status = %xsubr(functionName,db,dberrtxt)
        if (status) then
            debuglog(" - Done")
        else
            xcall LogFunctionError(logFileChannel,functionName,status,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logFileChannel,functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Delete an existing table
;;
DoDeleteTable,

    ;;Is the file in the file table?
    if (nsptr=%nspc_find(nsid,instruction.structure_name,structure_data))
    begin

        ;Yes - close the file
        if ((structure_data.structure_chan)&&%chopen(structure_data.structure_chan))
        begin
            close structure_data.structure_chan
            clear structure_data
        end

        ;And remove it from the file table
        xcall nspc_delete(nsid,nsptr)
    end

    log("Deleting table " + %atrim(instruction.structure_name))

    try
    begin
        functionName = %atrim(instruction.structure_name) + "_DROP"
        status = %xsubr(functionName,db,dberrtxt)
        if (status) then
            debuglog(" - Done")
        else
            xcall LogFunctionError(logFileChannel,functionName,status,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logFileChannel,functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Read the record associated with the key obtained from the instruction file.
;;
ReadSynergyRecord,

    ;;Find the master record details
    try
    begin
        functionName = %atrim(instruction.structure_name) + "_IO"
        status = %xsubr(functionName,IO_READ,structure_data.structure_chan,instruction.key,structure_data.structure_keynum,databuffer(1,structure_data.structure_size),,,dberrtxt)
        using status select
        (IO_OK),
        begin
            if (logKeys)
                debugLog(" - Key: " + %atrim(instruction.key))
        end
        (IO_NOT_FOUND,IO_EOF),
            debuglog(" - Record not found in ISAM file!")
        (),
            xcall LogFunctionError(logFileChannel,functionName,status,dberrtxt)
        endusing
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(logFileChannel,functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Open the log file

OpenLogFile,

    begin
        data logChannelMode, string

        ;;Are we running on a terminal?
        if (runningOnTerminal) then
        begin
            logFileSpec = "TT:"
            logChannelMode = "O"
        end
        else
        begin
            ;;The logical will be used if defined, otherwise current directory will be used
            logFileSpec = "REPLICATOR_LOGDIR:replicator_"+%datetime+".log"
            logChannelMode = "O:S"
        end

        ;;Open the log file
        try
        begin
            if (cycleLog)
            begin
                log("Cycling log. New log is " + %atrim(logFileSpec))
                close logFileChannel
                cycleLog = false
                if (runningOnTerminal)
                    sleep 0.5
            end

            open(logFileChannel=0,logChannelMode,logFileSpec)

            if (runningOnTerminal)
                display(logFileChannel,$scr_pos(1,1),$scr_clr(SCREEN))

            log("SQL Replicator Log")
            log("Sleep interval is " + %string(sleep_time) + " seconds.")
        end
        catch (ex)
        begin
            if (!runningOnTerminal)
                xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE,"Replicator failed to open log file " + %atrim(logFileSpec) + ". Error number " + %string(%ernum))
            ok = false
        end
        endtry
    end

    return

;;-----------------------------------------------------------------------------
;; Record the process ID of the running instance

RecordProcessId,

    if (!runningOnTerminal)
    begin
        data pidFileSpec, string, "REPLICATOR_LOGDIR:REPLICATOR_" + %atrim(instanceName) + ".PID"
        data pidFileChannel, int

        ;;Open the PID file
        try
        begin
            xcall delet(pidFileSpec)
            open(pidFileChannel=0,o:s,pidFileSpec)
            writes(pidFileChannel,%string(%jbno))
        end
        catch (ex)
        begin
            log("ERROR: Failed to create or write PID file! Error was " + ex.Message)
        end
        finally
        begin
            if (pidFileChannel && %chopen(pidFileChannel))
                close pidFileChannel
        end
        endtry
    end

    return

;;-----------------------------------------------------------------------------
;; Change the sleep seconds interval

ChangeInterval,

    begin
        data save_time, i4, sleep_time
        try
        begin
            sleep_time = %integer(instruction.key)
            if (sleep_time >= 1) then
            begin
                log("Sleep time changed from " + %string(save_time) + " to " + %string(sleep_time) + " seconds")
            end
            else
            begin
                log("ERROR: Invalid sleep time " + %string(sleep_time) + " requested")
                sleep_time = save_time
            end
        end
        catch (ex)
        begin
            log("ERROR: Invalid sleep time " + %atrim(instruction.key) + " requested")
            sleep_time = save_time
        end
        endtry
    end

    return

endmain

;;*****************************************************************************
;;
;; Routine:     ReplicatorShutdown
;;
;; Description: This routine is an event handler which is called when the
;;              replicator service is being stopped by the Windows operating
;;              system, or because a shutdown message was received via the
;;              instructions file.
;;
;; Author:      Steve Ives, Synergex Professional Services Group
;;
;; Created:     10th April 2008
;;
;;*****************************************************************************
;;
;; This code is supplied as seen and without warranty or support, and is used
;; at your own risk. Neither the author or Synergex accept any responsability
;; for any loss or damage which may result from the use of this code. This text
;; must remain unaltered in this file at all times. Possession or use of this
;; code, or any modified version of this code, indicates your acceptance of
;; these conditions.
;;
;;*****************************************************************************
;;
subroutine ReplicatorShutdown

    endparams

    .include "CONNECTDIR:ssql.def"
    .include "DBLDIR:namspc.def"
    .include "INC:structureio.def"
    .include "INC:SmtpMail.def"

    external common
        instanceName        ,a40                ;;The name of the running instance
        runningOnTerminal   ,boolean            ;;Program is running on a terminal
        db                  ,i4                 ;;Database channel
        nsid                ,i4                 ;;Name space id
        instructionChannel  ,i4                 ;;Instruction file channel
        logFileChannel      ,i4                 ;;Log file channel
        inserts             ,i4                 ;;Create operations completed
        updates             ,i4                 ;;Update operations completed
        deletes             ,i4                 ;;Delete operations completed
        fails               ,i4                 ;;Failed operations
    endcommon

    external common
        errorEmail          ,a512
        emailServer         ,a80
        emailSender         ,a80
        emailDomain         ,a80
        logFileSpec         ,a80
        stopOnError         ,boolean
    endcommon

    stack record
        idx                 ,i4                 ;;Loop counter
        access_code         ,i4                 ;;Namespace access code
        status              ,i4                 ;;Function return status
        functionName        ,string             ;;External function name to call
        structure_data      ,strStructureData
    endrecord

proc

    log("--------------------------------------------------")
    log("Normal replicator shutdown. Session summary:")
    log("INSERTS: " + %string(inserts,"ZZZ,ZZZ,ZZZ,ZZX"))
    log("UPDATES: " + %string(updates,"ZZZ,ZZZ,ZZZ,ZZX"))
    log("DELETES: " + %string(deletes,"ZZZ,ZZZ,ZZZ,ZZX"))
    log("ERRORS:  " + %string(fails,  "ZZZ,ZZZ,ZZZ,ZZX"))
    log("--------------------------------------------------")

    ;;If we're sending emails then let's record the shutdown
    if (errorEmail && emailServer && emailSender && emailDomain)
    begin
        data emailStatus, i4
        data body, [6]a80

        body[1] = "The SQL Replicator was stopped. Session summary:"
        body[2] = ""
        body[3] = "INSERTS: " + %string(inserts,"ZZZ,ZZZ,ZZZ,ZZX")
        body[4] = "UPDATES: " + %string(updates,"ZZZ,ZZZ,ZZZ,ZZX")
        body[5] = "DELETES: " + %string(deletes,"ZZZ,ZZZ,ZZZ,ZZX")
        body[6] = "ERRORS:  " + %string(fails,  "ZZZ,ZZZ,ZZZ,ZZX")

        if ((emailStatus=%SmtpMail(emailServer,emailDomain,emailSender,"SQL Replicator",,errorEmail,,"Replicator STOPPED",body)) != SMERR_SUCCESS)
        begin
            data errorText, string, %TimeStamp + "ERROR: Failed to send startup email. Error was " + %atrim(SmtpErrorText[emailStatus])
            log(errorText)
        end
    end

    ;;Clean up any database cursors and data files that we have open
    if (nsid)
    begin
        for idx from 1 thru %nspc_stoa(nsid,9999)
        begin
            ;;Get the item data from the namespace
            access_code = %nspc_stoa(nsid,idx)
            xcall nspc_getdata(nsid,access_code,structure_data)

            ;;Hard close any soft-closed database cursors
            try
            begin
                functionName = %atrim(structure_data.structure_name) + "_CLOSE_CURSORS"
                xcall xsubr(functionName,db)
            end
            catch (ex)
            begin
                nop
            end
            endtry

            ;;Close the channel
            if ((structure_data.structure_chan)&&%chopen(structure_data.structure_chan))
            begin
                try
                begin
                    functionName = %atrim(structure_data.structure_name) + "_IO"
                    status = %xsubr(functionName,IO_CLOSE,structure_data.structure_chan)
                end
                catch (ex)
                begin
                    nop
                end
                endtry
            end
        end

        xcall nspc_close(nsid)
        clear nsid

    end

    ;;Close our connection to the database
    if (db)
    begin
        xcall ssc_release(db)
        clear db
    end

    ;;Close the instructions file
    if (instructionChannel)
    begin
        close instructionChannel
        clear instructionChannel
    end

    ;;Delete the PID file
    if (!runningOnTerminal)
    begin
        data pidFileSpec, string, "REPLICATOR_LOGDIR:REPLICATOR_" + %atrim(instanceName) + ".PID"
        xcall delet(pidFileSpec)
    end

    if (runningOnTerminal)
    begin
        log("Replicator will stop in 2 seconds")
        sleep 2
    end

    xreturn

endsubroutine

;;*****************************************************************************
;;
subroutine LogFunctionError
    required in logChannel, int
    required in functionName, string
    required in errorNumber, int
    required in errorMessage, string
    endparams
    .include "INC:SmtpMail.def"
    external common
        errorEmail          ,a512
        emailServer         ,a80
        emailSender         ,a80
        emailDomain         ,a80
        logFileSpec         ,a80
        stopOnError         ,boolean
    endcommon
    stack record
        errorText           ,string
    endrecord
proc

    errorText = %TimeStamp+"ERROR: Function" + functionName + " returned error " + %string(errorNumber) + ": " + %atrim(errorMessage)

    ;;Log the error
    writes(logChannel,errorText)

    ;;Email the error?
    if (errorEmail && emailServer && emailSender && emailDomain)
    begin
        data emailStatus, i4
        data body, [3]a256
        if (stopOnError) then
            body[1] = "The SQL Replicator encountered the following error and will STOP processing:"
        else
            body[1] = "The SQL Replicator encountered the following error and will CONTINUE processing:"
        body[2] = ""
        body[3] = errorText
        if ((emailStatus=%SmtpMail(emailServer,emailDomain,emailSender,"SQL Replicator",,errorEmail,,"Replicator ERROR",body)) != SMERR_SUCCESS)
        begin
            errorText = %TimeStamp+"ERROR: Failed to send error email. Error was " + %atrim(SmtpErrorText[emailStatus])
            writes(logChannel,errorText)
        end
    end

    ;;Stop processing?
    if (stopOnError)
    begin
        xcall ReplicatorShutdown
        stop
    end

    xreturn

endsubroutine

;;*****************************************************************************
;;
function LogFunctionFail, boolean
    required in logChannel, int
    required in functionName, string
    required in errorNumber, int
    required in errorMessage, string
    endparams
    .include "INC:SmtpMail.def"
    external common
        errorEmail          ,a512
        emailServer         ,a80
        emailSender         ,a80
        emailDomain         ,a80
        logFileSpec         ,a80
        stopOnError         ,boolean
    endcommon
    stack record
        errorText           ,string
    endrecord
proc

    errorText = %TimeStamp+"ERROR: Function " + functionName + " failed with error " + %string(errorNumber) + ": " + %atrim(errorMessage)

    ;;Log the error
    writes(logChannel,errorText)

    ;;Email the error?
    if (errorEmail && emailServer && emailSender && emailDomain)
    begin
        data emailStatus, i4
        data body, [3]a256
        if (stopOnError) then
            body[1] = "The SQL Replicator encountered the following error and will STOP processing:"
        else
            body[1] = "The SQL Replicator encountered the following error and will CONTINUE processing:"
        body[2] = ""
        body[3] = errorText
        if ((emailStatus=%SmtpMail(emailServer,emailDomain,emailSender,"SQL Replicator",,errorEmail,,"Replicator ERROR",body)) != SMERR_SUCCESS)
        begin
            errorText = %TimeStamp+"ERROR: Failed to send error email. Error was " + %atrim(SmtpErrorText[emailStatus])
            writes(logChannel,errorText)
        end
    end

    ;;Stop processing?
    if (stopOnError)
    begin
        xcall ReplicatorShutdown
        stop
    end

    freturn false

endfunction

;;*****************************************************************************
;;
function TimeStamp, string
    external common
        instanceName        ,a40                ;;The name of the running instance
        runningOnTerminal   ,boolean            ;;Program is running on a terminal
        db                  ,i4                 ;;Database channel
        nsid                ,i4                 ;;Name space id
        instructionChannel  ,i4                 ;;Instruction file channel
        logFileChannel      ,i4                 ;;Log file channel
        inserts             ,i4                 ;;Create operations completed
        updates             ,i4                 ;;Update operations completed
        deletes             ,i4                 ;;Delete operations completed
        fails               ,i4                 ;;Failed operations
    endcommon
    record
        now                 ,d20
    endrecord
proc
    if (runningOnTerminal) then
        freturn ""
    else
    begin
        freturn %TimeNow
    end
endfunction

;;*****************************************************************************
;;
function TimeNow, string
    record
        now, d20
    endrecord
proc
    now = %datetime
    freturn %string(now(1:14),"XXXX-XX-XX XX:XX:XX ")
endfunction

