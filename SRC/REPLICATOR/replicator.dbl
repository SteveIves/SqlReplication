;;*****************************************************************************
;;
;; File:        replicator.dbl
;;
;; Type:        Application (replicator)
;;
;; Description: Replicates Synergy data file changes that have been recorded
;;              in the replucation log file to a SQL Server database.
;;
;;*****************************************************************************
;;
;; Copyright (c) 2008, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import ReplicationLibrary
import System.Collections
import Tools

structure strStructureData
    structure_name      ,a32    ;;Name of structure
    structure_chan      ,i4     ;;ISAM channel being used
    structure_size      ,i4     ;;Record length
    structure_type      ,a10    ;;Type (DBL ISAM, RELATIVE)
    structure_keynum    ,i4     ;;Key number of unique key being used
endstructure

main replicator

    .include "CONNECTDIR:ssql.def"
    .include "INC:structureio.def"
    .include "INC:SmtpMail.def"
    .ifdef D_VMS
    .include "REPLICATION_VMS" repository, record="instruction", end
    .else
    .include "REPLICATION" repository, record="instruction", end
    .endc

    .align
    record
        ok,					boolean            ;;Main status
        noMoreInstructions,	boolean            ;;End of instruction file
        switchMode,			boolean            ;;Switched from INSERT to UPDATE or vice versa
		switchDone,			boolean            ;;Have we tried to switch modes before?
		bulkLoad,			boolean			   ;;Use bulk load?
        errnum,				i4                 ;;Error number
        nsptr,				i4                 ;;Namespace pointer
        dberr,				i4                 ;;Database error
        length,				i4                 ;;Length of buffer
        status,				i4                 ;;General working status return
        rows,				i4                 ;;Number of rows affected
        functionName,		string             ;;External function to call
        primaryKey,			string             ;;Primary key of current record
        keyValue,			string             ;;Key value of the current ISAM record
        recordNumber,		d28                ;;Record number of the current relative record
        dberrtxt,			a1024
        structure_data,		strStructureData
        clValues,			@ArrayList         ;;Values of a command-line parameter
    endrecord

    external function
        xsubr               ,^val
    endexternal

proc

	call ConfigureEnvironment

	if (ok)
	begin
        ;;Main processing loop
        repeat
        begin
            ;;Check for outstanding instructions
            call GetInstruction

			;;If there are no more we'll just wait a while
            if (noMoreInstructions) then
            begin
                sleep Settings.SleepTime
            end
            else
            begin
                switchDone = false

                ;;If this is a routine request (create/update/delete) then do
                ;;file and table checks to ensure we have the file open and the
                ;;database table exists
                if    ((instruction.action==(i)REPLICATION_INSTRUCTION.CREATE_ROW)
                &   || (instruction.action==(i)REPLICATION_INSTRUCTION.UPDATE_ROW)
                &   || (instruction.action==(i)REPLICATION_INSTRUCTION.DELETE_ROW)
                &   || (instruction.action==(i)REPLICATION_INSTRUCTION.INSERT_RELATIVE)
                &   || (instruction.action==(i)REPLICATION_INSTRUCTION.UPDATE_RELATIVE)
                &   )
                begin
                    ;;Check if we already have the file open
                    call CheckFileTable

                    ;;If we don't have the file open by now then we probably have a configuration problem
                    if (!structure_data.structure_chan)
                    begin
                        xcall errorlog("Abnormal replicator shutdown")
                        exitloop
                    end
                end

                ;;Execute the instruction

                using (instruction.action) select

                ;;"Routine" processing requests

				(REPLICATION_INSTRUCTION.CREATE_ROW),
				begin
					xcall verboselog("Insert row in table " + %atrim(instruction.structure_name))
					call DoInsert
				end

				(REPLICATION_INSTRUCTION.UPDATE_ROW),
				begin
					xcall verboselog("Update row in table " + %atrim(instruction.structure_name))
					call DoUpdate
				end

				(REPLICATION_INSTRUCTION.DELETE_ROW),
				begin
					xcall verboselog("Delete row from table " + %atrim(instruction.structure_name))
					call DoDelete
				end

				(REPLICATION_INSTRUCTION.INSERT_RELATIVE),
				begin
					xcall verboselog("Insert row in table " + %atrim(instruction.structure_name))
					call DoInsertRelative
				end

				(REPLICATION_INSTRUCTION.UPDATE_RELATIVE),
				begin
					xcall verboselog("Update row in table " + %atrim(instruction.structure_name))
					call DoUpdateRelative
				end

                ;;"Special" processing requests

				(REPLICATION_INSTRUCTION.ADD_INDEXES),
				begin
					xcall log("Add indexes to table " + %atrim(instruction.structure_name))
					call DoAddIndexes
				end

				(REPLICATION_INSTRUCTION.CREATE_TABLE),
				begin
					xcall log("Create table " + %atrim(instruction.structure_name))
					call DoCreateTable
				end

				(REPLICATION_INSTRUCTION.LOAD_TABLE),
				begin
					xcall log("Load table " + %atrim(instruction.structure_name))
					bulkLoad = false
					call DoLoadTable
				end

				(REPLICATION_INSTRUCTION.BULK_LOAD_TABLE),
				begin
					if (bulkLoad = Settings.CanBulkLoad()) then
						xcall log("Bulk load table " + %atrim(instruction.structure_name))
					else
					begin
						xcall log("Bulk load requested but unavailable!")
						xcall log("Load table " + %atrim(instruction.structure_name))
					end
					call DoLoadTable
				end

				(REPLICATION_INSTRUCTION.CREATE_AND_LOAD_TABLE),
				begin
					xcall log("Create and load table " + %atrim(instruction.structure_name))
					call DoCreateAndLoadTable
				end

                (REPLICATION_INSTRUCTION.CREATE_CSV),
				begin
					xcall log("Export table " + %atrim(instruction.structure_name) + " to delimited file")
					call DoCreateCsv
				end

                (REPLICATION_INSTRUCTION.DELETE_ALL_ROWS),
				begin
					xcall log("Truncate table " + %atrim(instruction.structure_name))
					call DoDeleteAllRows
				end

				(REPLICATION_INSTRUCTION.DELETE_INDEXES),
				begin
					xcall log("Remove indexes from table " + %atrim(instruction.structure_name))
					call DoDeleteIndexes
				end

				(REPLICATION_INSTRUCTION.DELETE_TABLE),
				begin
					xcall log("Delete table " + %atrim(instruction.structure_name))
					call DoDeleteTable
				end

				(REPLICATION_INSTRUCTION.CHANGE_INTERVAL),
				begin
					xcall log("Change processing interval")
					call ChangeInterval
				end

                (REPLICATION_INSTRUCTION.SHUTDOWN),
                begin
					xcall log("Shutdown requested")
					delete(Settings.InstructionChannel)
                    xcall ReplicatorShutdown
                    stop
                end

                endusing

                ;;Delete the instruction from the instruction file
                delete(Settings.InstructionChannel)

            end

            ;;Reset to first record in instruction file and start over
            try
            begin
                find(Settings.InstructionChannel,,^FIRST)
            end
            catch (ex)
            begin
                nop
            end
            endtry
        end
    end

    ;;Close the database
    if (Settings.DatabaseChannel)
        xcall ssc_release(Settings.DatabaseChannel)

    ;;Release the namespace
    if (Settings.ChannelInfo)
        xcall nspc_close(Settings.ChannelInfo)

    ;;Close the instructions file
    if (Settings.InstructionChannel&&%chopen(Settings.InstructionChannel))
        close Settings.InstructionChannel

    ;;All done
    stop

;;-----------------------------------------------------------------------------
;; Look for a pending instruction
;;
GetInstruction,

    repeat
    begin
        try
        begin
            reads(Settings.InstructionChannel,instruction,,LOCK:Q_AUTO_LOCK)
            noMoreInstructions = false
            exitloop
        end
        catch (ex, @EndOfFileException)
        begin
            noMoreInstructions = true
            exitloop
        end
        catch (ex, @RecordLockedException)
        begin
            sleep Settings.ErrorSleepTime
            nextloop
        end
        endtry
    end

    return

;;-----------------------------------------------------------------------------

CheckFileTable,

    ;;Do we already have an entry for this file in our namespace?

    if (nsptr = %nspc_find(Settings.ChannelInfo,instruction.structure_name,structure_data)) then
    begin
        ;;Yes, we're good to go!
        return
    end
    else
    begin
		xcall verboselog("First instruction checks for table " + %atrim(instruction.structure_name))
		
		;;No, open the file and make sure it worked
        call OpenFile

        ;;If we failed to open the file then we have a serious problem!
        if (!structure_data.structure_chan)
        begin
            xcall errorlog("Failed to open ISAM file for structure " + %atrim(instruction.structure_name))
            return
        end

        ;;Get the record size of the file
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Length"
            structure_data.structure_size = %xsubr(functionName)
        end
        catch (ex, @SynException)
        begin
            ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry

        ;;Get the type of the file
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Type"
            xcall xsubr(functionName,structure_data.structure_type)
        end
        catch (ex, @SynException)
        begin
            ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry

        using structure_data.structure_type select
            
        ("DBL ISAM"),
        begin
            ;;Search for the first unique key. There should always be one, because without one the
            ;;constructor in the I/O hooks class would not activate replication for the file.
            data thisKey, i4
            structure_data.structure_keynum = -1
            for thisKey from 0 thru %isinfo(structure_data.structure_chan,"NUMKEYS") - 1
            begin
                if (!%isinfo(structure_data.structure_chan,"DUPS",thisKey))
                begin
                    ;;Found it!
                    structure_data.structure_keynum = thisKey
                    exitloop
                end
            end

            ;;Did we find a unique key?
            if (structure_data.structure_keynum>=0) then
            begin
                ;;Report the key that will be used
                xcall verboselog(" - Key " + %string(structure_data.structure_keynum) + " will be used to synchronize data")

                ;;And save the structure name
                structure_data.structure_name = instruction.structure_name

                ;;Record the new open file in the namespace
                nsptr = %nspc_add(Settings.ChannelInfo,instruction.structure_name,structure_data)
            end
            else
            begin
                ;;In theory we should never get here because CodeGen should not be able to create the
                ;;required code if no unique key is present.
                ;;But just in case, this will cause the replicator to abort
                close structure_data.structure_chan
                clear structure_data.structure_chan
                xcall errorlog("File for structure " + %atrim(instruction.structure_name) + " has no unique key!")
            end
        end
        
        ("RELATIVE"),
        begin
            ;;Report that record numbers will be used
            xcall verboselog(" - Record numbers will be used to synchronize data")

            ;;Set the key number to -1 to prevent it being used accidentally
            structure_data.structure_keynum = -1

            ;;And save the structure name
            structure_data.structure_name = instruction.structure_name

            ;;Record the new open file in the namespace
            nsptr = %nspc_add(Settings.ChannelInfo,instruction.structure_name,structure_data)
        end
        
        endusing
    end

    return

;;-----------------------------------------------------------------------------
;; Open a Synergy data file
;;
OpenFile,

    xcall log(" - Opening associated data file")

    try
    begin
        functionName = %atrim(instruction.structure_name) + "OpenInput"
		structure_data.structure_chan = %xsubr(functionName,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
        return
    end
    endtry

	if (structure_data.structure_chan) then
    begin
        xcall verboselog(" - File opened")
        call CheckTable
    end
    else
    begin
        xcall verboselog(" - Failed to open file!")
        xcall LogFunctionError(functionName,status,dberrtxt)
    end

    return

;;-----------------------------------------------------------------------------
;; Find out if a table exists in the SQL database. If not create and load it.
;;
CheckTable,

    xcall verboselog(" - Checking if table exists")

    try
    begin
        functionName = %atrim(instruction.structure_name) + "Exists"
        status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    using status select
    (1),
        xcall verboselog(" - Table exists")
    (0),
    begin
        xcall verboselog(" - Table not found!")
        call CreateTable
    end
    (<0),;Error
        xcall LogFunctionError(functionName,status,dberrtxt)
    endusing

    return

;;-----------------------------------------------------------------------------
;; Create and load a new table in the SQL database
;; This code is only used when doing an initial check for a table because of
;; a first replication instruction. Explicit CREATE_TABLE instructions are
;; handled by DoCreateTable.
;;
CreateTable,

    xcall log(" - Creating table")

    try
    begin
        functionName = %atrim(instruction.structure_name) + "Create"
        status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    if (status) then
    begin
        xcall verboselog(" - Table created")
		;;Now do an initial load of the data
		if (Settings.CanBulkLoad()) then
			call BulkLoadTable
		else
			call LoadTable
	end
    else
    begin
        xcall LogFunctionError(functionName,status,dberrtxt)
    end

    return

;;-----------------------------------------------------------------------------
;; Perform an initial load of a new table in the SQL database
;;
LoadTable,

    xcall log(" - Load starting at " + %TimeNow)

    try
    begin
        data successCount, int, 0
        data failCount, int, 0

        functionName = %atrim(instruction.structure_name) + "Load"

        if (Settings.RunningOnTerminal) then
            status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt,Settings.LogLoadExceptions,Settings.TerminalChannel,successCount,failCount,Settings.BulkLoadProgressReporting)
        else
            status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt,Settings.LogLoadExceptions,,successCount,failCount)

        if (status) then
        begin
            xcall log(" - Load complete at " + %TimeNow)
            xcall log(" - " + %string(successCount) + " rows inserted, " + %string(failCount) + " rows failed.")
            Counters.Inserts += successCount
            Counters.Errors  += failCount

			;;Now add alternate key indexes
			xcall log(" - Adding indexes...")
			functionName = %atrim(instruction.structure_name) + "Index"
			status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt)
			
			if (status) then
			begin
				xcall log(" - Indexes added")
				if (Settings.CanSendEmail())
				begin
					data subject, string, "loaded table " + %atrim(instruction.structure_name)
					data body = new string[#] { "A full table load completed. " + %string(successCount) + " rows inserted, " + %string(failCount) + " rows failed." }
					xcall SendEmail(subject,body)
				end
			end
			else
			begin
				xcall LogFunctionError(functionName,status,dberrtxt)
			end

        end
        else
        begin
            xcall LogFunctionError(functionName,status,dberrtxt)
        end
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Perform a bulk load of a table from a delimited text file.
;;
BulkLoadTable,

	xcall log(" - Bulk load starting at " + %TimeNow)

	try
	begin
		data totalRows, int
		data failRows, int
		data tt, int, 0

		if (Settings.RunningOnTerminal)
			tt = Settings.TerminalChannel

		functionName = %atrim(instruction.structure_name) + "BulkLoad"
		status = %xsubr(functionName,Settings.DatabaseChannel,Settings.LocalExportPath,Settings.RemoteExportPath,tt,totalRows,failRows,dberrtxt)

		if (status) then
		begin
			xcall log(" - Bulk load complete at " + %TimeNow)
			xcall log("   - " + %string(totalRows) + " records processed, " + %string(failRows) + " failed.")
			Counters.Inserts += totalRows - failRows
			Counters.Errors  += failRows

			;;Now add alternate key indexes
			xcall log(" - Adding indexes...")
			functionName = %atrim(instruction.structure_name) + "Index"
			status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt)
			
			if (status) then
			begin
				xcall log("   - Indexes added")
				if (Settings.CanSendEmail())
				begin
					data subject, string, "bulk loaded table " + %atrim(instruction.structure_name)
					data body = new string[#] { "A table bulk load completed." }
					xcall SendEmail(subject,body)
				end
			end
			else
			begin
				xcall LogFunctionError(functionName,status,dberrtxt)
			end

		end
		else
		begin
			xcall LogFunctionError(functionName,status,dberrtxt)
		end
	end
	catch (ex, @SynException)
	begin
		ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
	end
	endtry

	return

;;-----------------------------------------------------------------------------
;; Add a new row (ISAM)
;;
DoInsert,

    if (switchMode) then
    begin
        xcall verboselog(" - Insert row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end
    else
    begin
        if (Settings.LogKeys)
        begin
            keyValue = %keyVal(structure_data.structure_chan,instruction.record,structure_data.structure_keynum)
            xcall verboselog(" - Key: " + keyValue)
        end
    end

    try
    begin
        functionName = %atrim(instruction.structure_name) + 'Insert'
        status = %xsubr(functionName,Settings.DatabaseChannel,instruction.record(1,structure_data.structure_size),dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    using status select
    (0),
    begin
        xcall LogFunctionError(functionName,status,dberrtxt)
    end
    (1),
    begin
        xcall verboselog(" - Row inserted")
        Counters.Inserts += 1
    end
    (2),
    begin
        xcall verboselog(" - Row exists, switching to UPDATE")
        status = IO_OK
        if (switchDone) then
        begin
            xcall errorlog(" - Too many INSERT/UPDATE mode switches!")
        end
        else
        begin
            switchMode = true
            call DoUpdate
        end
    end
    endusing

    return

;;-----------------------------------------------------------------------------
;; Add a new row (RELATIVE)
;;
DoInsertRelative,

    if (switchMode) then
    begin
        xcall verboselog(" - Insert row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end
    else
    begin
        if (Settings.LogKeys)
        begin
            data pos, i4, %instr(1,instruction.record,":")
            recordNumber = instruction.record(1:pos-1)
            instruction.record = instruction.record(pos+1:structure_data.structure_size)
            xcall verboselog(" - Record #: " + %string(recordNumber))
        end
    end

    try
    begin
        functionName = %atrim(instruction.structure_name) + 'Insert'
        status = %xsubr(functionName,Settings.DatabaseChannel,recordNumber,instruction.record(1,structure_data.structure_size),dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    using status select
    (0),
    begin
        xcall LogFunctionError(functionName,status,dberrtxt)
    end
    (1),
    begin
        xcall verboselog(" - Row inserted")
        Counters.Inserts += 1
    end
    (2),
    begin
        xcall verboselog(" - Row exists, switching to UPDATE")
        status = IO_OK
        if (switchDone) then
        begin
            xcall errorlog(" - Too many INSERT/UPDATE mode switches!")
        end
        else
        begin
            switchMode = true
            call DoUpdateRelative
        end
    end
    endusing

    return

;;-----------------------------------------------------------------------------
;; Update an existing row (ISAM)
;;
DoUpdate,

    if (switchMode) then
    begin
        xcall verboselog(" - Update row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end
    else
    begin
        if (Settings.LogKeys)
        begin
            keyValue = %keyVal(structure_data.structure_chan,instruction.record,structure_data.structure_keynum)
            xcall verboselog(" - Key: " + keyValue)
        end
    end

    try
    begin
        functionName = %atrim(instruction.structure_name) + 'Update'
        status = %xsubr(functionName,Settings.DatabaseChannel,instruction.record(1,structure_data.structure_size),rows,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    if (status) then
    begin
        if (rows) then
        begin
            xcall verboselog(" - Row updated")
            Counters.Updates += 1
        end
        else
        begin
            xcall verboselog(" - Row not found, switching to INSERT")
            status = IO_OK
            if (switchDone) then
            begin
                xcall errorlog(" - Too many INSERT/UPDATE mode switches!")
            end
            else
            begin
                switchMode = true
                call DoInsert
            end
        end
    end
    else
    begin
        xcall LogFunctionError(functionName,status,dberrtxt)
    end

    return

;;-----------------------------------------------------------------------------
;; Update an existing row (RELATIVE)
;;
DoUpdateRelative,

    if (switchMode) then
    begin
        xcall verboselog(" - Update row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end
    else
    begin
        if (Settings.LogKeys)
        begin
            data pos, i4, %instr(1,instruction.record,":")
            recordNumber = instruction.record(1:pos-1)
            instruction.record = instruction.record(pos+1:structure_data.structure_size)
            xcall verboselog(" - Record #: " + %string(recordNumber))
        end
    end

    try
    begin
        functionName = %atrim(instruction.structure_name) + 'Update'
        status = %xsubr(functionName,Settings.DatabaseChannel,recordNumber,instruction.record(1,structure_data.structure_size),rows,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    if (status) then
    begin
        if (rows) then
        begin
            xcall verboselog(" - Row updated")
            Counters.Updates += 1
        end
        else
        begin
            xcall verboselog(" - Row not found, switching to INSERT")
            status = IO_OK
            if (switchDone) then
            begin
                xcall errorlog(" - Too many INSERT/UPDATE mode switches!")
            end
            else
            begin
                switchMode = true
                call DoInsertRelative
            end
        end
    end
    else
    begin
        xcall LogFunctionError(functionName,status,dberrtxt)
    end

    return

;;-----------------------------------------------------------------------------
;; Delete a row
;;
DoDelete,

    keyValue = %keyval(structure_data.structure_chan,instruction.record,structure_data.structure_keynum)

    if (Settings.LogKeys)
        xcall verboselog(" - Key: " + keyValue)

    try
    begin
        functionName = %atrim(instruction.structure_name) + 'Delete'
        status = %xsubr(functionName,Settings.DatabaseChannel,(a)keyValue,dberrtxt)
        if (status) then
        begin
            xcall verboselog(" - Row deleted")
            Counters.Deletes += 1
        end
        else
        begin
            xcall verboselog(" - " + dberrtxt)
            xcall LogFunctionError(functionName,status,dberrtxt)
        end
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Create a new table
;;
DoCreateTable,

    ;;Create a new table (only)
    ;;If the table already exists, do nothing

    xcall verboselog(" - Checking if table exists")

    try
    begin
        functionName = %atrim(instruction.structure_name) + "Exists"
        status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt)
        using status select
        (1),
        begin
            xcall verboselog(" - Table exists!")
        end
        (0),
        begin
            xcall verboselog(" - Creating table")

            try
            begin
                functionName = %atrim(instruction.structure_name) + "Create"
                status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt)
                if (status) then
                begin
                    xcall verboselog(" - Table created")

                    if (Settings.CanSendEmail())
                    begin
                        data subject, string, "created table " + %atrim(instruction.structure_name)
                        data body = new string[#] { "A new table was created in the database." }
                        xcall SendEmail(subject,body)
                    end
                end
                else
                    xcall LogFunctionError(functionName,status,dberrtxt)
            end
            catch (ex, @SynException)
            begin
                ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
            end
            endtry
        end
        (<0),
        begin
            xcall LogFunctionError(functionName,status,dberrtxt)
        end
        endusing
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Load new data into existing table
;;
DoLoadTable,

    ;;Do a full load of an existing table with new data

	xcall verboselog(" - Checking if table exists")

    try
    begin
        functionName = %atrim(instruction.structure_name) + "Exists"
        status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    using status select
    (1),
    begin
		xcall verboselog(" - Table exists")

		;;Delete any and all existing data before loading new data
		call DoDeleteAllRows

		if (bulkLoad) then
			call BulkLoadTable
		else
	        call LoadTable
    end
    (0),
    begin
        xcall verboselog(" - Table does not exist!")
    end
    (<0),
    begin
        xcall LogFunctionError(functionName,status,dberrtxt)
    end
    endusing

    return

;;-----------------------------------------------------------------------------
;; Create a new table and load new data into it
;;
DoCreateAndLoadTable,

    ;;Create a new table, do nothing if the table already exists
    ;;We create the table, then do a full load of data

    call CheckTable

    return

;;-----------------------------------------------------------------------------
;; Export ISAM file to CSV file
;;
DoCreateCsv,

    xcall log(" - Export starting at " + %TimeNow)

    try
	begin
		data csvFileSpec, a128, Settings.LocalExportPath
		functionName = %atrim(instruction.structure_name) + "Csv"		
		status = %xsubr(functionName,csvFileSpec,dberrtxt)
        if (status) then
            xcall verboselog(" - Export complete at " + %TimeNow)
        else
            xcall LogFunctionError(functionName,status,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Delete all rows from an existing table
;;
DoDeleteAllRows,

    try
    begin
        functionName = %atrim(instruction.structure_name) + "Clear"
        status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt)
        if (status) then
        begin
            xcall verboselog(" - Table truncated")

            if (Settings.CanSendEmail())
            begin
                data subject, string, "truncated table " + %atrim(instruction.structure_name)
                data body = new string[#] { "All rows were deleted from the table." }
                xcall SendEmail(subject, body)
            end
        end
        else
            xcall LogFunctionError(functionName,status,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Delete an existing table
;;
DoDeleteTable,

    ;;Is the file in the file table?
    if (nsptr=%nspc_find(Settings.ChannelInfo,instruction.structure_name,structure_data))
    begin

        ;Yes - close the file
        if ((structure_data.structure_chan)&&%chopen(structure_data.structure_chan))
        begin
            close structure_data.structure_chan
            clear structure_data
        end

        ;And remove it from the file table
        xcall nspc_delete(Settings.ChannelInfo,nsptr)
    end

    try
    begin
        functionName = %atrim(instruction.structure_name) + "Drop"
        status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt)
        if (status) then
        begin
            xcall verboselog(" - Table deleted")

            if (Settings.CanSendEmail())
            begin
                data subject, string, "deleted table " + %atrim(instruction.structure_name)
                data body = new string[#] { "The table was deleted from the database." }
                xcall SendEmail(subject, body)
            end
        end
        else
            xcall LogFunctionError(functionName,status,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
        return
    end
    endtry

    return

;;-----------------------------------------------------------------------------
;; Add alternate key indexes to a table (if they don't already exist)
;;
DoAddIndexes,

	try
	begin
		functionName = %atrim(instruction.structure_name) + "Index"
		status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt)
		if (status) then
		begin
			xcall verboselog(" - Indexes added")

			if (Settings.CanSendEmail())
			begin
				data subject, string, "added indexes to table " + %atrim(instruction.structure_name)
				data body = new string[#] { "Alternate key indexes were added to the table." }
				xcall SendEmail(subject, body)
			end
		end
		else
			xcall LogFunctionError(functionName,status,dberrtxt)
	end
	catch (ex, @SynException)
	begin
		ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
	end
	endtry

	return

;;-----------------------------------------------------------------------------
;; Delete alternate key indexes from a table
;;
DoDeleteIndexes,

	try
	begin
		functionName = %atrim(instruction.structure_name) + "UnIndex"
		status = %xsubr(functionName,Settings.DatabaseChannel,dberrtxt)
		if (status) then
		begin
			xcall verboselog(" - Indexes removed")

			if (Settings.CanSendEmail())
			begin
				data subject, string, "removed indexes from table " + %atrim(instruction.structure_name)
				data body = new string[#] { "Alternate key indexes were removed from the table." }
				xcall SendEmail(subject, body)
			end
		end
		else
			xcall LogFunctionError(functionName,status,dberrtxt)
	end
	catch (ex, @SynException)
	begin
		ok = %LogFunctionFail(functionName,ex.Errno,ex.Message)
	end
	endtry

	return

;;-----------------------------------------------------------------------------
;; Change the sleep seconds interval

ChangeInterval,

    begin
        data save_time, i4, Settings.SleepTime
        try
        begin
            Settings.SleepTime = %integer(%atrim(instruction.record))
            if (Settings.SleepTime >= 1) then
            begin
                xcall log(" - Interval changed from " + %string(save_time) + " to " + %string(Settings.SleepTime) + " seconds")
            end
            else
            begin
                xcall errorlog(" - Invalid interval of " + %string(Settings.SleepTime) + " seconds requested")
                Settings.SleepTime = save_time
            end
        end
        catch (ex)
        begin
            xcall errorlog(" - Invalid interval " + %atrim(instruction.record) + " requested")
            Settings.SleepTime = save_time
        end
        endtry
    end

    return

;;-----------------------------------------------------------------------------
;; Called first to set everything up

ConfigureEnvironment,

	.ifdef D_VMS
	xcall openelb("REPLICATOR_SH")
	.endc

	ok = true
	xcall flags(7004020,1)

	;;Configure defaults
	Settings.Initialize()

	;;If we're running on the terminal, open the terminal channel
	if (Settings.RunningOnTerminal)
	begin
		data tmpchn, i4, 0
		open(tmpchn,o,"tt:")
		Settings.TerminalChannel = tmpchn
		display(Settings.TerminalChannel,$scr_pos(1,1),$scr_clr(SCREEN))
		writes(Settings.TerminalChannel,"SQL Replicator Log")
	end

	;;Should we log major events to the system log in addition to the log file?
	if (CommandLineParser.Parse("syslog")) then
	begin
		Settings.SystemLog = true
	end
	else
	begin
		;;Or via an environment variable?
		data tmpval, a3
		xcall getlog("REPLICATOR_SYSTEM_LOG",tmpval,length)
		Settings.SystemLog = ((length>0)&&(tmpval.eq."YES"))
	end

	;;Do we have a log file location on the command line?
	if (CommandLineParser.Parse("logdir",clValues))
	begin
		using clValues.Count select
		(1),
		begin
			data sts, i4
			xcall setlog("REPLICATOR_LOGDIR",(string)clValues[0],sts)
		end
		endusing
	end

	;;Create a new log file
	try
	begin
		data tmpchn, i4, 0
		open(tmpchn,o:s,Settings.LogFileName)
		close tmpchn
		;;Record the startup
		xcall log("Replicator startup")
	end
	catch (ex)
	begin
		data tmpmsg = "Replicator failed to open log file " + Settings.LogFileName + ". Error number " + %string(%ernum)
		if (Settings.RunningOnTerminal) then
			writes(Settings.TerminalChannel,tmpmsg)
		else
			xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE,tmpmsg)
		ok = false
	end
	endtry

	if (ok)
	begin
		;;Is a local export directory specified via the command line?
		if (CommandLineParser.Parse("localexport",clValues)) then
		begin
			using clValues.Count select
			(1),
				Settings.LocalExportPath = (string)clValues[0]
			(0),
			begin
				xcall errorlog("Missing value after the -localexport option")
				ok = false
			end
			(),
			begin
				xcall errorlog("Only one value may follow the -localexport option")
				ok = false
			end
			endusing
		end
		else
		begin
			;;Or via an environment variable?
			data tmpval, a80
			xcall getlog("REPLICATOR_EXPORT_LOCAL",tmpval,length)
			if (length)
				Settings.LocalExportPath = tmpval(1:length)
		end
	end

	if (ok)
	begin
		data tmpPath, string
		;;Is a remote export directory specified via the command line?
		if (CommandLineParser.Parse("remoteexport",clValues)) then
		begin
			using clValues.Count select
			(1),
				tmpPath = (string)clValues[0]
			(0),
			begin
				xcall errorlog("Missing value after the -remoteexport option")
				ok = false
			end
			(),
			begin
				xcall errorlog("Only one value may follow the -remoteexport option")
				ok = false
			end
			endusing
		end
		else
		begin
			;;Or via an environment variable?
			data tmpval, a80
			xcall getlog("REPLICATOR_EXPORT_REMOTE",tmpval,length)
			if (length)
				tmpPath = tmpval(1:length)
		end

		.ifdef D_VMS
		if (tmpPath!=^null)
		begin
			;;On VMS, if a URL value is specified it must be enclosed in quotes. Remove them.
			if (tmpPath(1:1)=='"')
				tmpPath = tmpPath(2:%trim(tmpPath))
			if (tmpPath(%trim(tmpPath):1)=='"')
				tmpPath = tmpPath(1:%trim(tmpPath)-1)
		end
		.endc

		Settings.RemoteExportPath = tmpPath
	end

	if (ok)
	begin
		;;Is an instance name specified via the command line?
		if (CommandLineParser.Parse("instance",clValues)) then
		begin
			using clValues.Count select
			(1),
				Settings.InstanceName = (string)clValues[0]
			(0),
			begin
				xcall errorlog("Missing value after the -instance option")
				ok = false
			end
			(),
			begin
				xcall errorlog("Only one value may follow the -instance option")
				ok = false
			end
			endusing
		end
		else
		begin
			;;Or via an environment variable?
			data tmpval, a80
			xcall getlog("REPLICATOR_INSTANCE",tmpval,length)
			if (length)
				Settings.InstanceName = tmpval(1:length)
		end
	end

	if (ok)
	begin
		;;Is a sleep interval specified via the command line?
		if (CommandLineParser.Parse("interval",clValues)) then
		begin
			using clValues.Count select
			(1),
			begin
				try
				begin
					Settings.SleepTime = %integer((string)clValues[0])
				end
				catch (e, @Exception)
				begin
					xcall errorlog("Invalid value after the -interval option")
					ok = false
				end
				endtry
			end
			(0),
			begin
				xcall errorlog("Missing value after the -interval option")
				ok = false
			end
			(),
			begin
				xcall errorlog("Only one value may follow the -interval option")
				ok = false
			end
			endusing
		end
		else
		begin
			;;Or via an environment variable?
			data tmpval, a10
			xcall getlog("REPLICATOR_INTERVAL",tmpval,length)
			if (length>0)
				Settings.SleepTime = %integer(tmpval(1:length))
		end
		xcall log("Processing interval is " + %string(Settings.SleepTime) + " seconds.")
	end

	if (ok)
	begin
		;;Is load progress reporting enabled via the command line?
		if (CommandLineParser.Parse("progress")) then
		begin
			Settings.BulkLoadProgressReporting = true
		end
		else
		begin
			;;Or via an environment variable?
			data tmpval, a10
			xcall getlog("REPLICATOR_LOAD_PROGRESS",tmpval,length)
			Settings.BulkLoadProgressReporting = ((length>0)&&(tmpval.eq."YES"))
		end
	end

	if (ok)
	begin
		;;Is verbose logging enabled via the command line?
		if (CommandLineParser.Parse("verbose")) then
		begin
			Settings.FullLogging = true
		end
		else
		begin
			;;Or via an environment variable?
			data tmpval, a3
			xcall getlog("REPLICATOR_FULL_LOG",tmpval,length)
			Settings.FullLogging = ((length>0)&&(tmpval.eq."YES"))
		end
	end

	if (ok)
	begin
		;;Is key value logging enabled via the command line?
		if (CommandLineParser.Parse("keyvalues")) then
		begin
			Settings.LogKeys = true
		end
		else
		begin
			;;Or via an environment variable?
			data tmpval, a3
			xcall getlog("REPLICATOR_LOG_KEYS",tmpval,length)
			Settings.LogKeys = ((length>0)&&(tmpval.eq."YES"))
		end
	end

	if (ok)
	begin
		;;Is bulk load exception logging enabled via the command line?
		if (CommandLineParser.Parse("loaderrors")) then
		begin
			Settings.LogLoadExceptions = true
		end
		else
		begin
			;;Or via an environment variable?
			data tmpval, a3
			xcall getlog("REPLICATOR_LOG_BULK_LOAD_EXCEPTIONS",tmpval,length)
			Settings.LogLoadExceptions = ((length>0)&&(tmpval.eq."YES"))
		end
	end

	if (ok)
	begin
		;;Are email notifications enabled via the command line?
		if (CommandLineParser.Parse("erroremail",clValues)) then
		begin
			using clValues.Count select
			(1),
			begin
				Settings.ErrorEmail = (string)clValues[0]
			end
			(0),
			begin
				xcall errorlog("Missing value after the -erroremail option")
				ok = false
			end
			(),
			begin
				xcall errorlog("Only one value may follow the -erroremail option")
				ok = false
			end
			endusing
		end
		else
		begin
			;;Or via an environment variable?
			data tmpval, a1024
			xcall getlog("REPLICATOR_ERROR_EMAIL",tmpval,length)
			if (length>0)
				Settings.ErrorEmail = tmpval(1:length)
		end
	end

	if (ok)
	begin
		;;Is an email server DNS name or IP address specified via the command line?
		if (CommandLineParser.Parse("mailserver",clValues)) then
		begin
			using clValues.Count select
			(1),
			begin
				Settings.EmailServer = (string)clValues[0]
			end
			(0),
			begin
				xcall errorlog("Missing value after the -mailserver option")
				ok = false
			end
			(),
			begin
				xcall errorlog("Only one value may follow the -mailserver option")
				ok = false
			end
			endusing
		end
		else
		begin
			;;Or via an environment variable?
			data tmpval, a128
			xcall getlog("REPLICATOR_SMTP_SERVER",tmpval,length)
			if (length>0)
				Settings.EmailServer = tmpval(1:length)
		end
	end

	if (ok)
	begin
		;;Is an email sender address specified via the command line?
		if (CommandLineParser.Parse("mailfrom",clValues)) then
		begin
			using clValues.Count select
			(1),
			begin
				Settings.EmailSender = (string)clValues[0]
			end
			(0),
			begin
				xcall errorlog("Missing value after the -mailfrom option")
				ok = false
			end
			(),
			begin
				xcall errorlog("Only one value may follow the -mailfrom option")
				ok = false
			end
			endusing
		end
		else
		begin
			;;Or via an environment variable?
			data tmpval, a128
			xcall getlog("REPLICATOR_EMAIL_SENDER",tmpval,length)
			if (length>0)
				Settings.EmailSender = tmpval(1:length)
		end
	end

	if (ok)
	begin
		;;Should the replicator STOP if it encounters an error?
		if (CommandLineParser.Parse("stoponerror")) then
		begin
			Settings.StopOnError = true
		end
		else
		begin
			data tmpval, a3
			xcall getlog("REPLICATOR_ERROR_STOP",tmpval,length)
			Settings.StopOnError = ((length>0)&&(tmpval.eq."YES"))
		end
	end

	if (ok)
	begin
		;;Do we have a max columns value  via the command line?
		if (CommandLineParser.Parse("maxcols",clValues)) then
		begin
			using clValues.Count select
			(1),
			begin
				try
				begin
					Settings.MaxColumns = %integer((string)clValues[0])
				end
				catch (e, @Exception)
				begin
					xcall errorlog("Invalid value after the -maxcols option")
					ok = false
				end
				endtry
			end
			(0),
			begin
				xcall errorlog("Missing value after the -maxcols option")
				ok = false
			end
			(),
			begin
				xcall errorlog("Only one value may follow the -maxcols option")
				ok = false
			end
			endusing
		end
		else
		begin
			;;Or via an environment variable?
			data tmpval, a10
			xcall getlog("REPLICATOR_MAX_COLS",tmpval,length)
			if (length>0)
				Settings.MaxColumns = %integer(tmpval(1:length))
		end
	end

	if (ok)
	begin
		;;Do we have a max cursors value  via the command line?
		if (CommandLineParser.Parse("maxcursors",clValues)) then
		begin
			using clValues.Count select
			(1),
			begin
				try
				begin
					Settings.MaxCursors = %integer((string)clValues[0])
				end
				catch (e, @Exception)
				begin
					xcall errorlog("Invalid value after the -maxcursors option")
					ok = false
				end
				endtry
			end
			(0),
			begin
				xcall errorlog("Missing value after the -maxcursors option")
				ok = false
			end
			(),
			begin
				xcall errorlog("Only one value may follow the -maxcursors option")
				ok = false
			end
			endusing
		end
		else
		begin
			;;Or via an environment variable?
			data tmpval, a10
			xcall getlog("REPLICATOR_MAX_CURSORS",tmpval,length)
			if (length>0)
				Settings.MaxCursors = %integer(tmpval(1:length))
		end
	end

	if (ok)
	begin
		;;Check if the instruction file exists, if not create it
		try
		begin
			data tmpchn, i4, 0
			open(tmpchn,I:I,Settings.TransactionFile)
			close tmpchn
		end
		catch (e, @Synergex.SynergyDE.NoFileFoundException)
		begin
			try
			begin
				.ifdef D_VMS
				xcall isamc(Settings.TransactionFile + ", FIXED", 32054, 1, "START=1, LENGTH=20, NAME=TRANSACTION_ID")
				.else
				xcall isamc(Settings.TransactionFile + ", FIXED, COMPRESS, PAGE=1024, TBYTE", 65054, 1, "START=1, LENGTH=20, NAME=TRANSACTION_ID")
				.endc
			end
			catch (ex, @Exception)
			begin
				xcall errorlog("Failed to create transaction log file " + Settings.TransactionFile + " - Error was: " + e.Message)
				ok = false
			end
			endtry
		end
		catch (e, @Exception)
		begin
			xcall errorlog("Failed to open transaction log file " + Settings.TransactionFile + " - Error was: " + e.Message)
			ok = false
		end
		endtry
	end

	if (ok)
	begin
		;;Open the instruction file
		try
		begin
			data tmpchn, i4, 0
			open(tmpchn,U:I,Settings.TransactionFile)
			Settings.InstructionChannel = tmpchn
		end
		catch (ex)
		begin
			xcall errorlog("Failed to open transaction log file " + Settings.TransactionFile)
			ok = false
		end
		endtry
	end

	if (ok)
	begin
		;;Is the queue file location specified via the command line?
		if (CommandLineParser.Parse("datadir",clValues))
		begin
			using clValues.Count select
			(1),
			begin
				data sts, i4
				xcall setlog("REPLICATOR_DATA",(string)clValues[0],sts)
			end
			(0),
			begin
				xcall errorlog("Missing value after the -datadir option")
				ok = false
			end
			(),
			begin
				xcall errorlog("Only one value may follow the -datadir option")
				ok = false
			end
			endusing
		end
	end

	if (ok)
	begin
		;;Is a database connect string specified via the command line?
		if (CommandLineParser.Parse("database",clValues)) then
		begin
			using clValues.Count select
			(1),
			begin
				Settings.DatabaseConnectString = (string)clValues[0]
			end
			(0),
			begin
				xcall errorlog("Missing value after the -database option")
				ok = false
			end
			(),
			begin
				xcall errorlog("Only one value may follow the -database option")
				ok = false
			end
			endusing
		end
		else
		begin
			;;Or via an environment variable?
			data tmpval, a256
			xcall getlog("REPLICATOR_DATABASE",tmpval,length)
			if (length) then
				Settings.DatabaseConnectString = tmpval(1:length)
			else
			begin
				;;We don't have a database connect string so we can't continue!
				xcall errorlog("No database connect string was found. Use command line option -database or define environment variable REPLICATOR_DATABASE.")
				ok = false
			end
		end
	end

	if (ok)
	begin
		;;Enable and Initialize SQL Connection
		.ifdef OS_VMS
		xcall init_ssql
		.else
		status = %option(48,1)
		.endc
		Settings.DatabaseChannel = 1
		if (%ssc_init(Settings.DatabaseChannel,Settings.MaxCursors,Settings.MaxColumns)==SSQL_FAILURE)
		begin
			xcall errorlog("Failed to initialize SQL Connection")
			ok = false
		end
	end

	if (ok)
	begin
		;;Connect to the database
		xcall log("Connecting to database...")
		if (%ssc_connect(Settings.DatabaseChannel,Settings.DatabaseConnectString)==SSQL_NORMAL) then
			xcall log("Connected")
		else
		begin
			;;Failed to connect
			xcall ssc_getemsg(Settings.DatabaseChannel,dberrtxt,length)
			xcall errorlog("Failed to connect to database!")
			xcall log("Connect string was: " + Settings.DatabaseConnectString)
			xcall log("Error message was : " + dberrtxt(1,length))
			ok = false

			;;If we're sending emails then let's record the connect failure
			if (Settings.CanSendEmail())
			begin
				data body = new string[3]
				body[1] = "ERROR: Failed to connect to database!"
				body[2] = "Connect string was: " + Settings.DatabaseConnectString
				body[3] = "Error message was :  " + dberrtxt(1,length)
				xcall SendEmail("ERROR",body)
			end
		end
	end

	;;Register a shutdown handler
	if (ok && !Settings.RunningOnTerminal)
		xcall syn_atexit(%xaddr("ReplicatorShutdown"))

	.ifdef d_GUI
	;;If there has been a failure and we're running on the terminal, pause so error messages may be read
	if (!ok && Settings.RunningOnTerminal)
	begin
		data tmpchr, a1
		display(Settings.TerminalChannel,13,10,"Replicator will stop - press a key: ")
		accept(Settings.TerminalChannel,tmpchr)
	end
	.endc

	if (ok)
	begin
		;;Create the process ID file
		call RecordProcessID

		;;Create a namespace to record information about Synergy data files that we have opened.
		Settings.ChannelInfo = %nspc_open(,%size(structure_data))

		xcall log("Maximum cursors: "+%string(Settings.MaxCursors))
		xcall log("Maximum columns: "+%string(Settings.MaxColumns))

		xcall log("--- Processing instructions ----------------------")

		;;If we're sending emails then let's record the server startup
		if (Settings.CanSendEmail())
		begin
			data body = new string[#] {"The SQL replicator process was started."}
			xcall SendEmail("STARTED",body)
		end

		;;If were writing to the system log, record the startup
		if (Settings.SystemLog)
		begin
			data tmpmsg, string, "Startup of replicator instance " + Settings.InstanceName + %char(13) + %char(10)
			tmpmsg += "Database connect string is " + Settings.DatabaseConnectString + %char(13) + %char(10)
			tmpmsg += "Transaction file is " + Settings.TransactionFile + %char(13) + %char(10)
			tmpmsg += "Log file is " + Settings.LogFileName + %char(13) + %char(10)
			tmpmsg += "Sleep interval is " + %string(Settings.SleepTime) + " seconds. " + %char(13) + %char(10)
			if (Settings.StopOnError) then
				tmpmsg += "Replicator will stop if any error is encountered" + %char(13) + %char(10)
			else
				tmpmsg += "Replicator will attempt to continue if errors are encountered" + %char(13) + %char(10)
			if (Settings.CanSendEmail()) then
			begin
				tmpmsg += "Replicator is configured to send email messages to " + Settings.ErrorEmail + %char(13) + %char(10)
				tmpmsg += "Emails will be sent from " + Settings.EmailSender + %char(13) + %char(10)
				tmpmsg += "Email server is " + Settings.EmailServer + %char(13) + %char(10)
			end
			else
				tmpmsg += "Replicator is NOT configured to send email messages" + %char(13) + %char(10)

			xcall syn_reportevent(D_EVENTLOG_INFORMATION_TYPE,tmpmsg)
		end
	end

	return

;;-----------------------------------------------------------------------------
;; Record the process ID of the running instance

RecordProcessId,

	if (!Settings.RunningOnTerminal)
	begin
		data pidFileSpec, string, "REPLICATOR_LOGDIR:REPLICATOR_" + Settings.InstanceName + ".PID"
		data pidFileChannel, int

		;;Open the PID file
		try
		begin
			xcall delet(pidFileSpec)
			open(pidFileChannel=0,o:s,pidFileSpec)
			.ifdef D_VMS
			writes(pidFileChannel,%hex(%jbno,4))
			.else
			writes(pidFileChannel,%string(%jbno))
			.endc
		end
		catch (ex)
		begin
			xcall errorlog("Failed to create or write PID file! Error was " + ex.Message)
		end
		finally
		begin
			if (pidFileChannel && %chopen(pidFileChannel))
				close pidFileChannel
		end
		endtry
	end

	return

endmain

;;*****************************************************************************
;;
;; Routine:     ReplicatorShutdown
;;
;; Description: This routine is an event handler which is called when the
;;              replicator service is being stopped by the Windows operating
;;              system, or because a shutdown message was received via the
;;              instructions file.
;;
;; Author:      Steve Ives, Synergex Professional Services Group
;;
;; Created:     10th April 2008
;;
;;*****************************************************************************
;;
;; This code is supplied as seen and without warranty or support, and is used
;; at your own risk. Neither the author or Synergex accept any responsability
;; for any loss or damage which may result from the use of this code. This text
;; must remain unaltered in this file at all times. Possession or use of this
;; code, or any modified version of this code, indicates your acceptance of
;; these conditions.
;;
;;*****************************************************************************
;;
subroutine ReplicatorShutdown

    endparams

    .include "CONNECTDIR:ssql.def"
    .include "DBLDIR:namspc.def"
    .include "INC:structureio.def"
    .include "INC:SmtpMail.def"

    stack record
        idx                 ,i4                 ;;Loop counter
        access_code         ,i4                 ;;Namespace access code
        status              ,i4                 ;;Function return status
        functionName        ,string             ;;External function name to call
        structure_data      ,strStructureData
        message             ,string
    endrecord

proc

    message = "--------------------------------------------------" + %char(13) + %char(10)
    message += "Shutdown of replicator instance " + Settings.InstanceName + %char(13) + %char(10)
    message += "INSERTS: " + %string(Counters.Inserts,"ZZZ,ZZZ,ZZZ,ZZX") + %char(13) + %char(10)
    message += "UPDATES: " + %string(Counters.Updates,"ZZZ,ZZZ,ZZZ,ZZX") + %char(13) + %char(10)
    message += "DELETES: " + %string(Counters.Deletes,"ZZZ,ZZZ,ZZZ,ZZX") + %char(13) + %char(10)
    message += "ERRORS:  " + %string(Counters.Errors, "ZZZ,ZZZ,ZZZ,ZZX") + %char(13) + %char(10)
    message += "--------------------------------------------------"

    xcall log(message)

    ;;If were writing to the system log, record the startup
    if (Settings.SystemLog)
        xcall syn_reportevent(D_EVENTLOG_INFORMATION_TYPE,message)

    ;;If we're sending emails then let's record the shutdown
    if (Settings.CanSendEmail())
    begin
        data body = new string[10]
        body[01] = "<html>"
        body[02] = "<head><title>Replicator Activity Summary</title></head>"
        body[03] = "<body>"
        body[04] = "<p>Summary of activity:</p>"
        body[05] = "<pre>INSERTS: " + %string(Counters.Inserts,"ZZZ,ZZZ,ZZZ,ZZX")
        body[06] =      "UPDATES: " + %string(Counters.Updates,"ZZZ,ZZZ,ZZZ,ZZX")
        body[07] =      "DELETES: " + %string(Counters.Deletes,"ZZZ,ZZZ,ZZZ,ZZX")
        body[08] =      "ERRORS:  " + %string(Counters.Errors, "ZZZ,ZZZ,ZZZ,ZZX") + "</pre>"
        body[09] = "</body>"
        body[10] = "</html>"
        xcall SendEmail("STOPPED",body,true)
    end

    ;;Clean up any database cursors and data files that we have open
    if (Settings.ChannelInfo)
    begin
        for idx from 1 thru %nspc_stoa(Settings.ChannelInfo,9999)
        begin
            ;;Get the item data from the namespace
            access_code = %nspc_stoa(Settings.ChannelInfo,idx)
            xcall nspc_getdata(Settings.ChannelInfo,access_code,structure_data)

            ;;Hard close any soft-closed database cursors
            try
            begin
                functionName = %atrim(structure_data.structure_name) + "Close"
                xcall xsubr(functionName,Settings.DatabaseChannel)
            end
            catch (ex)
            begin
                nop
            end
            endtry

            ;;Close the channel
			if ((structure_data.structure_chan)&&%chopen(structure_data.structure_chan))
				close structure_data.structure_chan
        end

        xcall nspc_close(Settings.ChannelInfo)
        Settings.ChannelInfo = 0

    end

    ;;Close our connection to the database
    if (Settings.DatabaseChannel)
    begin
        xcall ssc_release(Settings.DatabaseChannel)
        Settings.DatabaseChannel = 0
    end

    ;;Close the instructions file
    if (Settings.InstructionChannel)
    begin
        close Settings.InstructionChannel
        Settings.InstructionChannel = 0
    end

    ;;Delete the PID file
    if (!Settings.RunningOnTerminal)
    begin
        data pidFileSpec, string, "REPLICATOR_LOGDIR:REPLICATOR_" + Settings.InstanceName + ".PID"
        xcall delet(pidFileSpec)
    end

    ;;Make sure that the keyboard input buffer is empty
    if (Settings.RunningOnTerminal)
    begin
        data tmpvar, a1
        while (%ttsts)
            accept(Settings.TerminalChannel,tmpvar)
    end

    ;;On Windows, give the user the chance to read the final messages
    .ifdef D_GUI
    if (Settings.RunningOnTerminal)
    begin
        xcall log("Replicator will stop in 2 seconds")
        sleep 2
    end
    .endc

    xreturn

endsubroutine

;;*****************************************************************************
;;
subroutine log
    required in message, string
    stack record
        logchn, i4
    endrecord
proc

    ;;Open the log file
    try
    begin
        open(logchn=0,a:s,Settings.LogFileName)

        ;;Log the message
        writes(logchn,%TimeNow + message)

        ;;Close the log file
        close logchn
end
    catch (ex)
    begin
        data tmpmsg = "Replicator failed to open log file " + Settings.LogFileName + ". Error number " + %string(%ernum)
        if (Settings.RunningOnTerminal) then
            writes(Settings.TerminalChannel,tmpmsg)
        else
            xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE,tmpmsg)
    end
    endtry

    ;;If running on the terminal, also display the message
    if (Settings.RunningOnTerminal)
        writes(Settings.TerminalChannel,message)

    xreturn
end

;;*****************************************************************************
;;
subroutine errorlog
    required in message, string
proc

    xcall log("ERROR: " + message)
    ;;Are we also logging to the system log?
    if (Settings.SystemLog)
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE,"ERROR: " + message)

    xreturn

endsubroutine

;;*****************************************************************************
;;
subroutine verboselog
    required in message, string
proc
    if (Settings.FullLogging)
        xcall log(message)
    xreturn
endsubroutine

;;*****************************************************************************
;;
subroutine LogFunctionError
    required in functionName, string
    required in errorNumber, int
    required in errorMessage, string
    endparams
    .include "INC:SmtpMail.def"
    stack record
        errorText           ,string
    endrecord
proc

    errorText = "Function " + functionName + " returned error " + %string(errorNumber) + ": " + %atrim(errorMessage)

    ;;Log the error
    xcall errorlog(errorText)

    ;;Email the error?
    if (Settings.CanSendEmail())
    begin
        data body = new string[3]
        if (Settings.StopOnError) then
            body[1] = "The SQL Replicator encountered the following error and will STOP processing:"
        else
            body[1] = "The SQL Replicator encountered the following error and will CONTINUE processing:"
        body[2] = ""
        body[3] = errorText
        xcall SendEmail("ERROR",body)
    end

    ;;Stop processing?
    if (Settings.StopOnError)
    begin
        xcall ReplicatorShutdown
        stop
    end

    xreturn

endsubroutine

;;*****************************************************************************
;;
subroutine SendEmail
    required in subject, string
    required in body, [#]string
	optional in bodyhtml, boolean
	optional in recipientEmail, string
    .include "INC:SmtpMail.def"
    stack record
        emailStatus, i4
		subjectLine, string
		recipientAddress, string
        html, boolean
    endrecord
proc
    emailStatus = 0
    subjectLine = "Replicator " + Settings.InstanceName + " " + subject
	html = ^passed(bodyhtml) && bodyhtml
	if (^passed(recipientEmail) && recipientEmail.Length>0) then
		recipientAddress = recipientEmail
	else
		recipientAddress = Settings.ErrorEmail
    if ((emailStatus=%SmtpMail(Settings.EmailServer,Settings.EmailSender,"SQL Replicator",,recipientAddress,,subjectLine,body,,html)) != SMERR_SUCCESS)
        xcall errorlog("Failed to send error email. Error was " + %atrim(SmtpErrorText[emailStatus]))
    xreturn
endsubroutine

;;*****************************************************************************
;;
function LogFunctionFail, boolean
    required in functionName, string
    required in errorNumber, int
    required in errorMessage, string
    endparams
    .include "INC:SmtpMail.def"
    stack record
        errorText           ,string
    endrecord
proc

    errorText = "Function " + functionName + " failed with error " + %string(errorNumber) + ": " + %atrim(errorMessage)

    ;;Log the error
    xcall errorlog(errorText)

    ;;Email the error?
    if (Settings.CanSendEmail())
    begin
        data body = new string[3]
        if (Settings.StopOnError) then
            body[1] = "The SQL Replicator encountered the following error and will STOP processing:"
        else
            body[1] = "The SQL Replicator encountered the following error and will CONTINUE processing:"
        body[2] = ""
        body[3] = errorText
        xcall SendEmail("ERROR",body)
    end

    ;;Stop processing?
    if (Settings.StopOnError)
    begin
        xcall ReplicatorShutdown
        stop
    end

    freturn false

endfunction

;;*****************************************************************************
;;
function TimeNow, string
    record
        now, d20
    endrecord
proc
    now = %datetime
    freturn %string(now(1:14),"XXXX-XX-XX XX:XX:XX ")
endfunction

;;*****************************************************************************

namespace Tools

    public class Counters

        public static Inserts, int

        public static Updates, int

        public static Deletes, int

        public static Errors, int

    endclass

    ;;; <summary>
    ;;; Represents various settings used within the replicator application.
    ;;; </summary>
    .ifdef D_VMS
    public class Settings
    .else
    public static class Settings
        .endc

        ;;; <summary>
        ;;; Configure default settings
        ;;; Can't use a static constructor because VMS doesn't support them
        ;;; </summary>
        public static method Initialize, void
            record 
                now, a20
            endrecord
        proc
            now = %datetime
			ErrorSleepTime     = 0.5
			LocalExportPath    = ^null
			RemoteExportPath   = ^null
            InstanceName       = "DEFAULT"
            LogFileName        = "REPLICATOR_LOGDIR:replicator_" + now(1:8) + "_" + now(9:6) + ".log"
            MaxCursors         = 128
            MaxColumns         = 254
            RunningOnTerminal  = (%tnmbr >= 0)
            SleepTime          = 60
            SystemLog          = false
            TransactionFile    = "REPLICATOR_DATA:REPLICATION.ISM"
        endmethod


        ;;; <summary>
        ;;; A synergy namespace used to store information about SDMS channels that the replicator currently has open
        ;;; </summary>
		public static readwrite property ChannelInfo, i4

        ;;; <summary>
        ;;; The SQL Connection database channel that represents our connection to the database.
        ;;; </summary>
		public static readwrite property DatabaseChannel, int

        ;;; <summary>
        ;;; Database connection string.
        ;;; </summary>
		public static readwrite property DatabaseConnectString, string

		private static mInstanceName, string

        ;;; <summary>
        ;;; The name of the replicator instance. The default instance name is DEFAULT. The instance name is used to
        ;;; discriminate between multiple instances of the replicator that might be active, each processing different
        ;;; data sets.
        ;;; </summary>
        public static property InstanceName, string
            method get
            proc
                mreturn mInstanceName
            endmethod
            method set
            proc
                mInstanceName = value.ToUpper()
            endmethod
        endproperty

        ;;; <summary>
        ;;; The channel number of the replication instruction file.
        ;;; </summary>
        public static readwrite property InstructionChannel, int

        ;;; <summary>
        ;;; The email address or addresses to send status messages to.
        ;;; One or more email addresses seperated by commas.
        ;;; </summary>
		public static readwrite property ErrorEmail, string

        ;;; <summary>
        ;;; The DNS name or IP address of the SMTP server to use to send email messages.
        ;;; The SMTP server must be configured to accept messages from unauthenticated sources.
        ;;; </summary>
		public static readwrite property EmailServer, string

        ;;; <summary>
        ;;; The email address to be used as the sender of status messages.
        ;;; </summary>
		public static readwrite property EmailSender, string

        ;;; <summary>
        ;;; How many seconds should we sleep after processing an error?
        ;;; </summary>
		public static readwrite property ErrorSleepTime, decimal

		;;; <summary>
		;;; Where should export files be created locally?
		;;; </summary>
		public static readwrite property LocalExportPath, string

		;;; <summary>
		;;; Where should export files be copied to remotely?
		;;; </summary>
		public static readwrite property RemoteExportPath, string

		;;; <summary>0
		;;; Which server should export files be copied to?
		;;; </summary>
;		public static readwrite property RemoteExportServer, string

		;;; <summary>
        ;;; Are we doing full logging?
        ;;; </summary>
        public static readwrite property FullLogging, boolean

        ;;; <summary>
        ;;; <summary>
        ;;; The name of the replicator log file.
        ;;; If running in interactive mode this will be TT:
        ;;; </summary>
        public static readwrite property LogFileName, string

        ;;; Include key data in debug logs?
        ;;; </summary>
        public static readwrite property LogKeys, boolean

        ;;; <summary>
        ;;; Log bulk load exceptions to a log file?
        ;;; </summary>
		public static readwrite property LogLoadExceptions, boolean

        ;;; <summary>
        ;;; Maximum number of database cursors
        ;;; </summary>
		public static readwrite property MaxCursors, int

        ;;; <summary>
        ;;; Maximum number of columns in a database table
        ;;; </summary>
		public static readwrite property MaxColumns, int

        ;;; <summary>
        ;;; Should we report progress when bulk loading tables?
        ;;; </summary>
		public static readwrite property BulkLoadProgressReporting, boolean

        ;;; <summary>
        ;;; Are we attached to a terminal?
        ;;; </summary>
		public static readwrite property RunningOnTerminal, boolean

        ;;; <summary>
        ;;; How many seconds should we sleep when we run out of instructions to process?
        ;;; </summary>
		public static readwrite property SleepTime, int

        ;;; <summary>
        ;;; Should we stop processing and close if we encounter an error?
        ;;; </summary>
		public static readwrite property StopOnError, boolean

        ;;; <summary>
        ;;; Should we also log to the system log?
        ;;; </summary>
		public static readwrite property SystemLog, boolean

        ;;; <summary>
        ;;; If running interactively, the channel number of the terminal.
        ;;; </summary>
		public static readwrite property TerminalChannel, int

        ;;; <summary>
        ;;; The name of the replication transation log file.
        ;;; </summary>
		public static readwrite property TransactionFile, string

		;;; <summary>
		;;; Are we able to use bulk load?
		;;; </summary>
		;;; <returns>Returns true if we have all the data, but does not guarantee that bulk upload will work!</returns>
		public static method CanBulkLoad, boolean
		proc
			.ifdef OS_VMS
			mreturn (RemoteExportPath!=^null && RemoteExportPath.ToLower().Contains("http://") && RemoteExportPath.ToLower().Contains("fileservice"))
			.endc
			.ifdef OS_UNIX
			mreturn (RemoteExportPath!=^null && RemoteExportPath.ToLower().Contains("http://") && RemoteExportPath.ToLower().Contains("fileservice"))
			.endc
			.ifdef OS_WINDOWS7
			;TODO: On windows we can also bulk load IF the database is on the same server as the replicator
			mreturn (!DatabaseConnectString.ToLower().StartsWith("net:") || (RemoteExportPath!=^null && RemoteExportPath.ToLower().Contains("http://") && RemoteExportPath.ToLower().Contains("fileservice")))
			.endc
		endmethod

		;;; <summary>
        ;;; Are we able to send email messages. In order for this to return true we must have values
        ;;; for EmailError, EmailServer, EmailSender and EmailDomain.
        ;;; </summary>
        ;;; <returns>Returns true if we have all the data, but does not guarantee that email can be sent!</returns>
        public static method CanSendEmail, boolean
        proc
            mreturn (ErrorEmail != ^null && ErrorEmail.Length>0 && EmailServer != ^null && EmailServer.Length>0 && EmailSender != ^null && EmailSender.Length>0)
        endmethod

    endclass

endnamespace
