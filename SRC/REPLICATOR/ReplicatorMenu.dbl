;;*****************************************************************************
;;
;; File:        ReplicatorMenu.dbl
;;
;; Type:        Application
;;
;; Description: Controls the replicator process.
;;
;;*****************************************************************************
;;
;; Copyright (c) 2008, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import SynPSG.ReplicationDemo

main ReplicatorMenu
	record
		tt,         i4
		system,     d4
		runtime,    d4
		windows,    boolean
		unix,       boolean
		pid,        int
		option,     a2
		tableName,  a30
	endrecord
	.ifdef D_VMS
    .include "REPLICATION_VMS" repository, record="instruction", end
	.else
	.include "REPLICATION" repository, record="instruction", end
	.endc
	record outbuf
		operation,  a20
		,           a2
		table,      a30
		,           a2
		keyval,     a24
	endrecord

proc

	xcall envrn(system,runtime)
	windows = ((runtime==101)||(runtime==104))
	unix = (system==8)

	xcall flags(7004000,1)
	open(tt=0,i,"tt:")

	display(tt,$SCR_POS(1,1),$SCR_CLR(SCREEN))

	display(tt,$SCR_POS(2,2),"Replicator Control Menu")

	display(tt,$SCR_POS(2,40),"Current table: None")

	repeat
	begin

		display(tt,$SCR_POS(4,1),$SCR_CLR(EOS))

		if (windows) then
		begin
			display(tt,$SCR_POS(4,2),"SR. Start Replicator (Normal)")
			display(tt,$SCR_POS(5,2),"SD. Start Replicator (Debug)")
		end
		else if (unix)
		begin
			display(tt,$SCR_POS(4,2),"SR. Start Replicator (Detached)")
		end

		display(tt,$SCR_POS(6,2),"ST. Stop Replicator")
		display(tt,$SCR_POS(7,2),"VI. View instructions")
		display(tt,$SCR_POS(8,2),"PI. Purge instructions")
		display(tt,$SCR_POS(9,2),"QL. Instruction count")
		display(tt,$SCR_POS(10,2),"CI. Change interval")

		display(tt,$SCR_POS(12,2),"T.  Set current table")

		display(tt,$SCR_POS(14,2),"E.  Exit")

		if (tableName)
		begin
			display(tt,$SCR_POS(4,40),"1. Create table")
			display(tt,$SCR_POS(5,40),"2. Load table")
			display(tt,$SCR_POS(6,40),"3. Create and load table")
			display(tt,$SCR_POS(7,40),"4. Truncate table")
			display(tt,$SCR_POS(8,40),"5. Delete table")
			display(tt,$SCR_POS(9,40),"6. Export to CSV")
		end

		display(tt,$SCR_POS(23,2),$SCR_CLR(EOS),"Select an option: ")
		reads(tt,option)

		using option select

		("SR"),
		begin
			if (windows) then
				xcall spawn("dbr EXE:replicator.dbr",D_NOWINDOW|D_NOWAIT)
			else if (unix)
				xcall spawn("nohup dbr EXE:replicator </dev/null >/dev/null 2>&1 &")
		end

		("SD"),
			if (windows)
				xcall spawn("dbr -d EXE:replicator.dbr",D_NOWINDOW|D_NOWAIT)

		("ST"),
		begin
			xcall Replicate(REPLICATION_INSTRUCTION.SHUTDOWN)
			display(tt,$scr_pos(23,2),$SCR_CLR(EOL),"Command queued")
		end

		("VI"),
		begin
			data chn, i4
			data row, i4
			data tmpvar, a1, " "
			open(chn=0,"I:I","REPLICATOR_DATA:REPLICATION.ISM")

			display(tt,$SCR_POS(4,2),$SCR_CLR(EOS),"Operation             Table                           Affected Record",
			&	$SCR_POS(5,2),              "--------------------  ------------------------------  ------------------------")

			find(chn,,^FIRST) [EOF=eof]

			repeat
			begin
				for row from 6 thru 21
				begin
					reads(chn,instruction,eof)
					clear outbuf

					using instruction.action select
					(REPLICATION_INSTRUCTION.CREATE_ROW),
						outbuf.operation = "Create row"
					(REPLICATION_INSTRUCTION.UPDATE_ROW),
						outbuf.operation = "Update row"
					(REPLICATION_INSTRUCTION.DELETE_ROW),
						outbuf.operation = "Delete row"
					(REPLICATION_INSTRUCTION.CREATE_TABLE),
						outbuf.operation = "Create table"
					(REPLICATION_INSTRUCTION.LOAD_TABLE),
						outbuf.operation = "Load table"
					(REPLICATION_INSTRUCTION.CREATE_AND_LOAD_TABLE),
						outbuf.operation = "Create & load table"
					(REPLICATION_INSTRUCTION.DELETE_ALL_ROWS),
						outbuf.operation = "Truncate table"
					(REPLICATION_INSTRUCTION.DELETE_TABLE),
						outbuf.operation = "Delete table"
					(REPLICATION_INSTRUCTION.SHUTDOWN),
						outbuf.operation = "Shutdown"
					(REPLICATION_INSTRUCTION.DELETE_ALL_INSTRUCTIONS),
						outbuf.operation = "Purge instructions"
					(REPLICATION_INSTRUCTION.CLOSE_FILE),
						outbuf.operation = "Close file"
					endusing

					outbuf.table = instruction.structure_name
					outbuf.keyval = instruction.record

					display(tt,$scr_pos(row,2),outbuf)
				end

				display(tt,$SCR_POS(23,2),"Press a key for more, or M for menu: ")

				if (tmpvar=="M") then
					exitloop
				else
				begin
					accept(tt,tmpvar)
					while (%ttsts)
						accept(tt,tmpvar)
				end

				display(tt,$scr_pos(6,1),$scr_clr(EOS))

			end

eof,        close chn

			if (tmpvar!="M")
			begin
				display(tt,$SCR_POS(23,2),$SCR_CLR(EOS),"No more instructions. Press a key: ")
				begin
					accept(tt,tmpvar)
					while (%ttsts)
						accept(tt,tmpvar)
				end
			end
			nextloop
		end

		("QL"),
		begin
			data chn, i4
			data msg, a50
			open(chn=0,"I:I","REPLICATOR_DATA:REPLICATION.ISM")
			msg = %string(%isinfo(chn,"NUMRECS"),"ZZZ,ZZZ,ZZX") [LEFT]
			msg = %atrim(msg) + " outstanding instructions"
			display(tt,$scr_pos(23,2),$scr_clr(EOL),%atrim(msg))
			close chn
			accept(tt,chn)
			while (%ttsts)
				accept(tt,chn)
			nextloop
		end

		("PI"),
		begin
			xcall Replicate(REPLICATION_INSTRUCTION.DELETE_ALL_INSTRUCTIONS)
			display(tt,$scr_pos(23,2),$SCR_CLR(EOL),"Command executed")
		end

		("CI"),
		begin
			data interval, a5
			display(tt,$SCR_POS(23,2),$SCR_CLR(EOS),"Interval (seconds): ")
			reads(tt,interval)

			if (interval) then
			begin
				if (%IsNumeric(interval)) then
				begin
					xcall Replicate(REPLICATION_INSTRUCTION.CHANGE_INTERVAL,,%atrim(interval))
					display(tt,$scr_pos(23,2),$SCR_CLR(EOL),"Command queued")
				end
				else
				begin
					display(tt,$scr_pos(23,2),$SCR_CLR(EOL),"Invalid interval!")
				end
			end
			else
			begin
				nextloop
			end
		end

		("T "),
		begin
			display(tt,$SCR_POS(23,2),$SCR_CLR(EOS),"Table name: ")
			reads(tt,tableName)

			if (tableName) then
			begin
				;;Call the _LENGTH rotuine to make sure we have code for the table
				try
				begin
;                    data length, int, %xsubr(%atrim(tableName) + "_LENGTH")
					display(tt,$SCR_POS(2,55),$SCR_CLR(EOL),%atrim(tableName))
					nextloop
				end
				catch (ex, @SynException)
				begin
					display(tt,$scr_pos(23,2),$SCR_CLR(EOL),"Table not found!")
					clear tableName
				end
				endtry
			end
			else
			begin
				display(tt,$SCR_POS(2,55),$SCR_CLR(EOL),"None")
				nextloop
			end
		end

		("1 "),
		begin
			if (tableName) then
			begin
				xcall Replicate(REPLICATION_INSTRUCTION.CREATE_TABLE,tableName)
				display(tt,$scr_pos(23,2),$SCR_CLR(EOL),"Command queued")
			end
			else
				display(tt,$scr_pos(23,2),$SCR_CLR(EOL),"Invalid option!")
		end

		("2 "),
		begin
			if (tableName) then
			begin
				xcall Replicate(REPLICATION_INSTRUCTION.LOAD_TABLE,tableName)
				display(tt,$scr_pos(23,2),$SCR_CLR(EOL),"Command queued")
			end
			else
				display(tt,$scr_pos(23,2),$SCR_CLR(EOL),"Invalid option!")
		end

		("3 "),
		begin
			if (tableName) then
			begin
				xcall Replicate(REPLICATION_INSTRUCTION.CREATE_AND_LOAD_TABLE,tableName)
				display(tt,$scr_pos(23,2),$SCR_CLR(EOL),"Command queued")
			end
			else
				display(tt,$scr_pos(23,2),$SCR_CLR(EOL),"Invalid option!")
		end

		("4 "),
		begin
			if (tableName) then
			begin
				xcall Replicate(REPLICATION_INSTRUCTION.DELETE_ALL_ROWS,tableName)
				display(tt,$scr_pos(23,2),$SCR_CLR(EOL),"Command queued")
			end
			else
				display(tt,$scr_pos(23,2),$SCR_CLR(EOL),"Invalid option!")
		end

		("5 "),
		begin
			if (tableName) then
			begin
				xcall Replicate(REPLICATION_INSTRUCTION.DELETE_TABLE,tableName)
				display(tt,$scr_pos(23,2),$SCR_CLR(EOL),"Command queued")
			end
			else
				display(tt,$scr_pos(23,2),$SCR_CLR(EOL),"Invalid option!")
		end

		("6 "),
		begin
			if (tableName) then
			begin
				xcall Replicate(REPLICATION_INSTRUCTION.CREATE_CSV,tableName)
				display(tt,$scr_pos(23,2),$SCR_CLR(EOL),"Command queued")
			end
			else
				display(tt,$scr_pos(23,2),$SCR_CLR(EOL),"Invalid option!")
		end

		("E "),
			exitloop

		(),
			display(tt,$scr_pos(23,2),$SCR_CLR(EOL),"Invalid option!")

		endusing

		sleep 0.5
	end

	display(tt,$SCR_POS(1,1),$SCR_CLR(SCREEN))
	close tt
	stop

endmain
