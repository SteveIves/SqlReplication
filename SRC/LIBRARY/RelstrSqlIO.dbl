;;*****************************************************************************
;;
;; File:        RelstrSqlIO.dbl
;;
;; Type:        Functions
;;
;; Description: Various functions that performs SQL I/O for RELSTR
;;
;;*****************************************************************************
;;
;; Copyright (c) 2009, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************
;; WARNING: THIS CODE WAS CODE GENERATED AND WILL BE OVERWRITTEN IF CODE
;;          GENERATION IS RE-EXECUTED FOR THIS PROJECT.
;;*****************************************************************************

import ReplicationLibrary

;;*****************************************************************************
;;; <summary>
;;; Determines if the Relstr table exists in the database.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns 1 if the table exists, otherwise a number indicating the type of error.</returns>

function RelstrExists, ^val

    required in  a_dbchn,  i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        error       ,int    ;;Returned error number
        dberror     ,int    ;;Database error number
        cursor      ,int    ;;Database cursor
        length      ,int    ;;Length of a string
        table_name  ,a128   ;;Retrieved table name
        errtxt      ,a256   ;;Error message text
    endrecord

proc

    init local_data

    ;;Open a cursor for the SELECT statement

    if (%ssc_open(a_dbchn,cursor,"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME='Relstr'",SSQL_SELECT)==SSQL_FAILURE)
    begin
        error=-1
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to open cursor"
    end

    ;;Bind host variables to receive the data

    if (!error)
    begin
        if (%ssc_define(a_dbchn,cursor,1,table_name)==SSQL_FAILURE)
        begin
            error=-1
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variable"
        end
    end

    ;;Move data to host variables

    if (!error)
    begin
        if (%ssc_move(a_dbchn,cursor,1)==SSQL_NORMAL)
                error = 1 ;; Table exists
    end

    ;;Close the database cursor

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (!error)
            begin
                error=-1
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (error) then
            a_errtxt = errtxt
        else
            a_errtxt = ""
    end

    freturn error

endfunction

;;*****************************************************************************
;;; <summary>
;;; Creates the Relstr table in the database.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function RelstrCreate, ^val

    required in  a_dbchn,  i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    .align
    stack record local_data
        ok          ,boolean    ;;Return status
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        transaction ,int        ;;Transaction in process
        errtxt      ,a512       ;;Returned error message text
        sql         ,string     ;;SQL statement
    endrecord

proc

    init local_data
    ok = true

    ;;Start a database transaction

    if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
        transaction=1
    else
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to start transaction"
    end

    ;;Create the database table and primary key constraint

    if (ok)
    begin
        sql = 'CREATE TABLE "Relstr" ('
        & + '"RecordNumber" INT NOT NULL,'
        & + '"Field1" VARCHAR(1),'
        & + '"Field2" DECIMAL(2),'
        & + '"Field3" DATE,'
        & + '"Field4" TIME(0)'
        & + 'CONSTRAINT PK_Relstr PRIMARY KEY CLUSTERED("RecordNumber" ASC)'
        & + ')'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;;Grant access permissions

    if (ok)
    begin
        sql = 'GRANT ALL ON "Relstr" TO PUBLIC'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;;Commit or rollback the transaction

    if (transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = errtxt
    end

    freturn ok

open_cursor,

    if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to open cursor"
    end

    return

execute_cursor,

    if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to execute SQL statement"
    end

    return

close_cursor,

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
        clear cursor
    end

    return

endfunction

;;*****************************************************************************
;;; <summary>
;;; Insert a row into the Relstr table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_recnum">Relative record number to be inserted.</param>
;;; <param name="a_data">Record to be inserted.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns 1 if the row was inserted, 2 to indicate the row already exists, or 0 if an error occurred.</returns>

function RelstrInsert, ^val

    required in  a_dbchn,  i
    required in  a_recnum, n
    required in  a_data,   a
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    .align
    stack record local_data
        ok          ,boolean    ;;OK to continue
        openAndBind ,boolean    ;;Should we open the cursor and bind data this time?
        sts         ,int        ;;Return status
        dberror     ,int        ;;Database error number
        transaction ,int        ;;Transaction in progress
        length      ,int        ;;Length of a string
        errtxt      ,a256       ;;Error message text
        recordNumber,d28        ;;Relative record number
    endrecord

    literal
        sql         ,a*, "INSERT INTO Relstr ("
        & +              '"RecordNumber",'
        & +              '"Field1",'
        & +              '"Field2",'
        & +              '"Field3",'
        & +              '"Field4"'
        & +              ") VALUES(:1,:2,:3,:4,:5)"
    endliteral

    static record
        relstr, strRELSTR
        tmpField4, a7      ;;Storage for HH:MM:SS time field
    endrecord

    global common
        csr_relstr_insert1, i4, 0
    endcommon

proc

    init local_data
    ok = true
    sts = 1
    recordNumber = a_recnum
    openAndBind = (csr_relstr_insert1 == 0)

    ;;Start a database transaction

    if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
        transaction=1
    else
    begin
        ok = false
        sts = 0
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to start transaction"
    end

    ;;Open a cursor for the INSERT statement

    if (ok && openAndBind)
    begin
        if (%ssc_open(a_dbchn,csr_relstr_insert1,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Bind the host variables for data to be inserted

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,csr_relstr_insert1,1,recordNumber)==SSQL_FAILURE)
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variables"
        end
    end

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,csr_relstr_insert1,4,
        &    relstr.field1,
        &    relstr.field2,
        &    ^a(relstr.field3),
        &    tmpField4)==SSQL_FAILURE)
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variables"
        end
    end

    ;;Insert the row into the database

    if (ok)
    begin
        ;;Load the data into the bound record

        relstr = a_data

        ;;Clean up any alpha fields

        relstr.field1 = %atrim(relstr.field1)+%char(0)

        ;;Clean up any decimal fields

        if ((!relstr.field2)||(!%IsNumeric(^a(relstr.field2))))
            clear relstr.field2

        ;;Clean up any date fields

        if ((!relstr.field3)||(!%IsDate(^a(relstr.field3))))
            ^a(relstr.field3(1:1))=%char(0)

        ;;Clean up any time fields

        if ((!relstr.field4)||(!%IsTime(^a(relstr.field4))))
            ^a(relstr.field4(1:1))=%char(0)

        ;;Assign data to any temporary time or user-defined timestamp fields

        tmpField4 = %string(relstr.field4,"XX:XX:XX")

        ;;Execute the INSERT statement

        if (%ssc_execute(a_dbchn,csr_relstr_insert1,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_NORMAL) then
            begin
                ;;If it's a "row exists" then return 2
                using dberror select
                (-2627),
                begin
                    ;;Duplicate key
                    errtxt = "Duplicate key detected in database!"
                    sts = 2
                end
                (),
                    nop
                endusing
            end
            else
                errtxt="Failed to execute SQL statement"
        end
    end

    ;;Commit or rollback the transaction

    if (transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                sts = 0
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = errtxt
    end

    freturn sts

endfunction

;;*****************************************************************************
;;; <summary>
;;; Inserts multiple rows into the Relstr table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel</param>
;;; <param name="a_data">Memory handle containing one or more rows to insert.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <param name="a_exception">Memory handle to load exception data records into.</param>
;;; <param name="a_terminal">Terminal number channel to log errors on.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function RelstrInsertRows, ^val

    required in  a_dbchn,     i
    required in  a_data,      i
    optional out a_errtxt,    a
    optional out a_exception, i
    optional in  a_terminal,  i
    endparams

    .include "CONNECTDIR:ssql.def"

    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok          ,boolean    ;;Return status
        openAndBind ,boolean    ;;Should we open the cursor and bind data this time?
        dberror     ,int        ;;Database error number
        rows        ,int        ;;Number of rows to insert
        transaction ,int        ;;Transaction in progress
        length      ,int        ;;Length of a string
        ex_ms       ,int        ;;Size of exception array
        ex_mc       ,int        ;;Items in exception array
        continue    ,int        ;;Continue after an error
        errtxt      ,a512       ;;Error message text
        recordNumber,d28
    endrecord

    literal
        sql         ,a*, "INSERT INTO Relstr ("
        & +              '"RecordNumber",'
        & +              '"Field1",'
        & +              '"Field2",'
        & +              '"Field3",'
        & +              '"Field4"'
        & +              ") VALUES(:1,:2,:3,:4,:5)"
    endliteral

    structure inpbuf
        recnum, d28
        .include "RELSTR" repository, group="inprec", nofields
    endstructure
    .include "RELSTR" repository, static record="relstr", end

    static record
        tmpField4, a7      ;;Storage for HH:MM:SS time field
        ,a1                         ;;In case there are no user timestamp, date or JJJJJJ date fields
    endrecord

    global common
        csr_relstr_insert2, i4
    endcommon

proc

    init local_data
    ok = true

    openAndBind = (csr_relstr_insert2 == 0)

    if (^passed(a_exception)&&a_exception)
        clear a_exception

    ;;Figure out how many rows to insert

    rows = (%mem_proc(DM_GETSIZE,a_data)/^size(inpbuf))

    ;;Start a database transaction

    if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
        transaction=1
    else
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to start transaction"
    end

    ;;Open a cursor for the INSERT statement

    if (ok && openAndBind)
    begin
        if (%ssc_open(a_dbchn,csr_relstr_insert2,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Bind the host variables for data to be inserted

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,csr_relstr_insert2,1,recordNumber)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variables"
        end
    end

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,csr_relstr_insert2,4,
        &    relstr.field1,
        &    relstr.field2,
        &    ^a(relstr.field3),
        &    tmpField4)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variables"
        end
    end

    ;;Insert the rows into the database

    if (ok)
    begin
        data cnt, int
        for cnt from 1 thru rows
        begin
            ;;Load data into bound record

            recordNumber = ^m(inpbuf[cnt].recnum,a_data)
            relstr = ^m(inpbuf[cnt].inprec,a_data)

            ;;Clean up any alpha variables

            relstr.field1=%atrim(relstr.field1)+%char(0)

            ;;Clean up any decimal variables

            if ((!relstr.field2)||(!%IsNumeric(^a(relstr.field2))))
                clear relstr.field2

            ;;Clean up any date variables

            if ((!relstr.field3)||(!%IsDate(^a(relstr.field3))))
                ^a(relstr.field3(1:1))=%char(0)

            ;;Clean up any time variables

            if ((!relstr.field4)||(!%IsTime(^a(relstr.field4))))
                ^a(relstr.field4(1:1))=%char(0)

            ;;Assign any time or user-defined timestamp fields

            tmpField4 = %string(relstr.field4,"XX:XX:XX")

            ;;Execute the statement

            if (%ssc_execute(a_dbchn,csr_relstr_insert2,SSQL_STANDARD)==SSQL_FAILURE)
            begin
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to execute SQL statement"

                clear continue

                ;;Are we logging errors?
                if (^passed(a_terminal)&&(a_terminal))
                begin
                    writes(a_terminal,errtxt(1:length))
                    continue=1
                end

                ;;Are we processing exceptions?
                if (^passed(a_exception))
                begin
                    if (ex_mc==ex_ms)
                    begin
                        if (!a_exception) then
                            a_exception = %mem_proc(DM_ALLOC|DM_STATIC,^size(inpbuf)*(ex_ms=EXCEPTION_BUFSZ))
                        else
                            a_exception = %mem_proc(DM_RESIZ,^size(inpbuf)*(ex_ms+=EXCEPTION_BUFSZ),a_exception)
                    end
                    ^m(inpbuf[ex_mc+=1],a_exception)=relstr
                    continue=1
                end

                if (continue) then
                    nextloop
                else
                begin
                    ok = false
                    exitloop
                end
            end
        end
    end

    ;;Commit or rollback the transaction

    if (transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;If we're returning exceptions then resize the buffer to the correct size

    if (^passed(a_exception)&&a_exception)
        a_exception = %mem_proc(DM_RESIZ,^size(inpbuf)*ex_mc,a_exception)

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = %atrim(errtxt)+" [Database error "+%string(dberror)+"]"
    end

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Updates a row in the Relstr table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_recnum">record number.</param>
;;; <param name="a_data">Record containing data to update.</param>
;;; <param name="a_rows">Returned number of rows affected.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function RelstrUpdate, ^val

    required in  a_dbchn,  i
    required in  a_recnum, n
    required in  a_data,   a
    optional out a_rows,   i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        ok          ,boolean    ;;OK to continue
        openAndBind ,boolean    ;;Should we open the cursor and bind data this time?
        transaction ,boolean    ;;Transaction in progress
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        rows        ,int        ;;Number of rows updated
        errtxt      ,a256       ;;Error message text
    endrecord

    literal
        sql         ,a*, 'UPDATE Relstr SET '
        & +              '"Field1"=:1,'
        & +              '"Field2"=:2,'
        & +              '"Field3"=:3,'
        & +              '"Field4"=:4'
        & +              ' WHERE "RecordNumber"=:5'
    endliteral

    static record
        relstr, strRELSTR
        tmpField4, a7      ;;Storage for HH:MM:SS time field
    endrecord

    global common
        csr_relstr_update, i4
    endcommon
proc

    init local_data
    ok = true

    openAndBind = (csr_relstr_update == 0)

    if (^passed(a_rows))
        clear a_rows

    ;;Load the data into the bound record

    relstr = a_data

    ;;Start a database transaction

    if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
        transaction = true
    else
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to start transaction"
    end

    ;;Open a cursor for the UPDATE statement

    if (ok && openAndBind)
    begin
        if (%ssc_open(a_dbchn,csr_relstr_update,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Bind the host variables for data to be updated

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,csr_relstr_update,4,
        &    relstr.field1,
        &    relstr.field2,
        &    ^a(relstr.field3),
        &    tmpField4)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variables"
        end
    end

    ;;Bind the host variables for the key segments / WHERE clause

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,csr_relstr_update,1,a_recnum)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind key variables"
        end
    end

    ;;Update the row in the database

    if (ok)
    begin
        ;;Clean up any alpha fields

        relstr.field1 = %atrim(relstr.field1) + %char(0)

        ;;Clean up any decimal fields

        if ((!relstr.field2)||(!%IsNumeric(^a(relstr.field2))))
            clear relstr.field2

        ;;Clean up any date fields

        if ((!relstr.field3)||(!%IsDate(^a(relstr.field3))))
            ^a(relstr.field3(1:1)) = %char(0)

        ;;Clean up any time fields

        if ((!relstr.field4)||(!%IsTime(^a(relstr.field4))))
            ^a(relstr.field4(1:1)) = %char(0)

        ;;Assign any time and user-defined timestamp fields

        tmpField4 = %string(relstr.field4,"XX:XX:XX")

        if (%ssc_execute(a_dbchn,csr_relstr_update,SSQL_STANDARD,,rows)==SSQL_NORMAL) then
        begin
            if (^passed(a_rows))
                a_rows = rows
        end
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to execute SQL statement"
        end
    end

    ;;Commit or rollback the transaction

    if (transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;Return error message

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = errtxt
    end

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Deletes all rows from the Relstr table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function RelstrClear, ^val

    required in  a_dbchn,  i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        ok          ,boolean    ;;Return status
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        transaction ,int        ;;Transaction in process
        errtxt      ,a512       ;;Returned error message text
        sql         ,string     ;;SQL statement
    endrecord

proc

    init local_data
    ok = true

    ;;Start a database transaction

    if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
        transaction=1
    else
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to start transaction"
    end

    ;;Open cursor for the SQL statement

    if (ok)
    begin
        sql = 'TRUNCATE TABLE "Relstr"'
        if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Execute SQL statement

    if (ok)
    begin
        if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to execute SQL statement"
        end
    end

    ;;Close the database cursor

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
    end

    ;;Commit or rollback the transaction

    if (transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = errtxt
    end

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Deletes the Relstr table from the database.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function RelstrDrop, ^val

    required in  a_dbchn,  i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        ok          ,boolean    ;;Return status
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        transaction ,int        ;;Transaction in progress
        errtxt      ,a256       ;;Returned error message text
    endrecord

proc

    init local_data
    ok = true

    ;;Close any open cursors

    xcall RelstrClose(a_dbchn)

    ;;Start a database transaction

    if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
        transaction=1
    else
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to start transaction"
    end

    ;;Open cursor for DROP TABLE statement

    if (ok)
    begin
        if (%ssc_open(a_dbchn,cursor,"DROP TABLE Relstr",SSQL_NONSEL)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Execute DROP TABLE statement

    if (ok)
    begin
        if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_NORMAL) then
            begin
                ;;Check if the error was that the table did not exist
                if (dberror==-3701) then
                    clear errtxt
                else
                    ok = false
            end
            else
            begin
                errtxt="Failed to execute SQL statement"
                ok = false
            end
        end
    end

    ;;Close the database cursor

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
    end

    ;;Commit or rollback the transaction

    if (transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = errtxt
    end

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Load all data from REPLICATOR_DATA:RELFILE.DDF into the Relstr table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <param name="a_logex">Log exception records?</param>
;;; <param name="a_terminal">Terminal channel to log errors on.</param>
;;; <param name="a_added">Total number of successful inserts.</param>
;;; <param name="a_failed">Total number of failed inserts.</param>
;;; <param name="a_progress">Report progress.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function RelstrLoad, ^val

    required in  a_dbchn,    i
    optional out a_errtxt,   a
    optional in  a_logex,    i
    optional in  a_terminal, i
    optional out a_added,    n
    optional out a_failed,   n
    optional in  a_progress, n
    endparams

    .include "CONNECTDIR:ssql.def"
    structure inpbuf
        recnum, d28
        .include "RELSTR" repository, group="inprec"
    endstructure
    .include "RELSTR" repository, structure="RELSTR", end
    .include "RELSTR" repository, stack record="tmprec", end
    .include "INC:structureio.def"

    .define BUFFER_ROWS     1000
    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok          ,boolean    ;;Return status
        firstRecord ,boolean    ;;Is this the first record?
        filechn     ,int        ;;Data file channel
        mh          ,D_HANDLE   ;;Memory handle containing data to insert
        ms          ,int        ;;Size of memory buffer in rows
        mc          ,int        ;;Memory buffer rows currently used
        ex_mh       ,D_HANDLE   ;;Memory buffer for exception records
        ex_mc       ,int        ;;Number of records in returned exception array
        ex_ch       ,int        ;;Exception log file channel
        attempted   ,int        ;;Rows being attempted
        ttl_added   ,int        ;;Total rows added
        ttl_failed  ,int        ;;Total failed inserts
        errnum      ,int        ;;Error number
        errtxt      ,a256       ;;Error message text
        recordNumber,d28
    endrecord

proc

    init local_data
    ok = true
    recordNumber = 0

    ;;If we are logging exceptions, delete any existing exceptions file.
    if (^passed(a_logex) && a_logex)
    begin
        xcall delet("REPLICATOR_LOGDIR:relstr_data_exceptions.log")
    end

    ;;Open the data file associated with the structure

    if (%RelstrIO(IO_OPEN_INP,filechn)!=IO_OK)
    begin
        ok = false
        errtxt = "Failed to open file REPLICATOR_DATA:RELFILE.DDF"
        clear filechn
    end

    if (ok)
    begin
        ;;Allocate memory buffer for the database rows

        mh = %mem_proc(DM_ALLOC,^size(inpbuf)*(ms=BUFFER_ROWS))

        ;;Read records from the input file

        firstRecord = true
        repeat
        begin
            ;;Get the next record from the input file
            if (firstRecord) then
            begin
                errnum = %RelstrIO(IO_READ_FIRST,filechn,,tmprec)
                firstRecord = false
            end
            else
            begin
                errnum = %RelstrIO(IO_READ_NEXT,filechn,,tmprec)
            end

            using errnum select
            (IO_OK),
            begin
                recordNumber += 1
                if (!tmprec)
                    nextloop
            end
            (IO_EOF),
                exitloop
            (),
            begin
                ok = false
                errtxt = "Unexpected response " + %string(errnum) + " from %RelstrIO"
                exitloop
            end
            endusing

            ;;Got one, load it into or buffer
            ^m(inpbuf[mc+=1].recnum,mh) = recordNumber
            ^m(inpbuf[mc].inprec,mh) = tmprec

            ;;If the buffer is full, write it to the database
            if (mc==ms)
                call insert_data
        end

        if (mc)
        begin
            mh = %mem_proc(DM_RESIZ,^size(inpbuf)*mc,mh)
            call insert_data
        end

        ;;Deallocate memory buffer

        mh = %mem_proc(DM_FREE,mh)

    end

    ;;Close the file

    if (filechn)
        xcall RelstrIO(IO_CLOSE,filechn)

    ;;Close the exceptions log file

    if (ex_ch)
        close ex_ch

    ;;Return the error text

    if (^passed(a_errtxt))
        a_errtxt = errtxt

    ;;Return totals

    if (^passed(a_added))
        a_added = ttl_added
    if (^passed(a_failed))
        a_failed = ttl_failed

    freturn ok

insert_data,

    attempted = (%mem_proc(DM_GETSIZE,mh)/^size(inpbuf))

    if (%RelstrInsertRows(a_dbchn,mh,errtxt,ex_mh,a_terminal))
    begin
        ;;Any exceptions?
        if (ex_mh) then
        begin
            ;;How many exceptions to log?
            ex_mc = (%mem_proc(DM_GETSIZE,ex_mh)/^size(inpbuf))
            ;;Update totals
            ttl_failed+=ex_mc
            ttl_added+=(attempted-ex_mc)
            ;;Are we logging exceptions?
            if (^passed(a_logex)&&a_logex) then
            begin
                data cnt, int
                ;;Open the log file
                if (!ex_ch)
                    open(ex_ch=0,o:s,"REPLICATOR_LOGDIR:relstr_data_exceptions.log")
                ;;Log the exceptions
                for cnt from 1 thru ex_mc
                    writes(ex_ch,^m(inpbuf[cnt],ex_mh))
                if (^passed(a_terminal)&&a_terminal)
                    writes(a_terminal,"Exceptions were logged to REPLICATOR_LOGDIR:relstr_data_exceptions.log")
            end
            else
            begin
                ;;No, report and error
                ok = false
            end
            ;;Release the exception buffer
            ex_mh=%mem_proc(DM_FREE,ex_mh)
        end
        else
        begin
            ;;No exceptions
            ttl_added += attempted
            if ^passed(a_terminal) && a_terminal && ^passed(a_progress) && a_progress
                writes(a_terminal," - " + %string(ttl_added) + " rows inserted")
        end
    end

    clear mc

    return

endfunction

;;*****************************************************************************
;;; <summary>
;;; Bulk load data from REPLICATOR_DATA:RELFILE.DDF into the Relstr table via a CSV file.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_localpath">Path to local export directory</param>
;;; <param name="a_remotepath">Remote export directory or URL</param>
;;; <param name="a_terminal">Terminal channel to log errors on</param>
;;; <param name="a_records">Total number of records processed</param>
;;; <param name="a_exceptions">Total number of exception records detected</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function RelstrBulkLoad, ^val

    required in  a_dbchn,      i
	required in  a_localpath,  string
	required in  a_remotepath, string
    optional in  a_terminal,   n
	optional out a_records,    n
	optional out a_exceptions, n
    optional out a_errtxt,     a
    endparams

    .include "CONNECTDIR:ssql.def"

     stack record local_data
        ok,						boolean    ;;Return status
		transaction,			boolean
		cursorOpen,				boolean
		remoteBulkLoad,			boolean
		loggingToTerminal,		boolean
		sql,					string
		localCsvFile,			string
		localExceptionsFile,	string
		localExceptionsLog,	    string
		remoteCsvFile,			string
		remoteExceptionsFile,	string
		remoteExceptionsLog,	string
		copyTarget,				string
		fileToLoad,				string
		errorFile,				string
		cursor,					int
		length,					int
		dberror,				int
		recordCount,			int
		exceptionCount,         int
        errtxt,					a256       ;;Error message text
		fsc,					@FileServiceClient
    endrecord

	.define ttlog(x) if (loggingToTerminal) writes(a_terminal,"   - " + x)

proc

    init local_data
	ok = true

	;;Are we logging to a terminal channel?
	loggingToTerminal = (^passed(a_terminal) && a_terminal)

	;;If we're doing a remote bulk load, create an instance of the FileService client
	if (remoteBulkLoad = ((a_remotepath!=^null) && (a_remotepath.nes." ")))
	begin
		;;Make sure we can talk to the FileService endpoint
		fsc = new FileServiceClient(a_remotepath)
		ttlog("Verifying FileService connection")
		if (!fsc.Ping(errtxt))
		begin
			ttlog(errtxt = "No response from FileService, bulk upload cancelled")
			ok = false
		end
	end

	if (ok)
	begin
		;;Determine temporary file names
		.ifdef OS_WINDOWS7
		localCsvFile = a_localpath + "\Relstr.csv"
		.endc
		.ifdef OS_UNIX
		localCsvFile = a_localpath + "/Relstr.csv"
		.endc
		.ifdef OS_VMS
		localCsvFile = a_localpath + "Relstr.csv"
		.endc
		localExceptionsFile  = localCsvFile + "_err"
		localExceptionsLog   = localExceptionsFile + ".Error.Txt" 

		if (remoteBulkLoad)
		begin
			remoteCsvFile = "Relstr.csv"
			remoteExceptionsFile = remoteCsvFile + "_err"
			remoteExceptionsLog  = remoteExceptionsFile + ".Error.Txt"
		end

		;;Make sure there are no files left over from previous operations
		call DeleteFiles

		ttlog("Exporting delimited file")

		;;Are we doing a remote bulk load?
		if (remoteBulkLoad) then
		begin
			;;Remote bulk load. Create the export file locally then copy it to the server.
			if (ok = %RelstrCsv(localCsvFile,recordCount,errtxt))
			begin
				ttlog("Uploading data to database host via HTTP")
				ok = fsc.Upload(remoteCsvFile,localCsvFile,fileToLoad,errtxt)
			end
		end
		else
		begin
			;;Local bulk load; so we must be on Windows
			ok = %RelstrCsv(localCsvFile,recordCount,errtxt)
			fileToLoad  = localCsvFile
		end
	end

	;;Bulk load the delimited file into the database

	if (ok)
	begin
		ttlog("Executing SQL BULK INSERT")

		;;Start a database transaction
		if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
			transaction = true
		else
		begin
			ok = false
			if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
				errtxt="Failed to start transaction"
		end

		;;Open a cursor for the statement
		if (ok)
		begin
			errorFile = fileToLoad + "_err"

			sql = "BULK INSERT Relstr FROM '" + fileToLoad + "' WITH (FIRSTROW=2,FIELDTERMINATOR='|',ROWTERMINATOR='\n', ERRORFILE='" + errorFile + "')"

			if (%ssc_open(a_dbchn,cursor,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_NORMAL) then
				cursorOpen = true
			else
			begin
				ok = false
				if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
					errtxt="Failed to open cursor"
			end
		end

		;;Execute the statement
		if (ok)
		begin
			if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
			begin
				if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_NORMAL) then
				begin
					using dberror select
					(-4864),
					begin
						;Bulk load data conversion error
						ttlog("Data conversion errors were reported")
						clear dberror, errtxt
						call GetExceptionDetails
					end
					(),
					begin
						errtxt = %string(dberror) + " " + errtxt
						ok = false
					end
					endusing
				end
				else
				begin
					errtxt="Failed to execute SQL statement"
					ok = false
				end
			end

			;;Delete temporary files
			call DeleteFiles
		end

		;;Commit or rollback the transaction

		if (transaction)
		begin
			if (ok) then
			begin
				;;Success, commit the transaction
				if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
				begin
					if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
						errtxt="Failed to commit transaction"
					ok = false
				end
			end
			else
			begin
				;;There was an error, rollback the transaction
				xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
			end
		end

		;;Close the cursor
		if (cursorOpen)
		begin
			if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
			begin
				if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
					errtxt="Failed to close cursor"
			end		
		end
	end

	;; Return the record count

	if (^passed(a_records))
		a_records = recordCount

	if (^passed(a_exceptions))
		a_exceptions = exceptionCount

    ;;Return the error text

    if (^passed(a_errtxt))
        a_errtxt = errtxt

    freturn ok

GetExceptionDetails,

	;;If we get here then the bulk load reported one or more "data conversion error" issues
	;;There should be two files on the server 

	if (remoteBulkLoad) then
	begin
		data fileExists, boolean
		data tmpmsg, string

		if (fsc.Exists(remoteExceptionsFile,fileExists,tmpmsg)) then
		begin
			if (fileExists) then
			begin
				;;Download the error file
				data exceptionRecords, [#]string

				ttlog("Downloading remote exceptions data file")

				if (fsc.DownloadText(remoteExceptionsFile,exceptionRecords))
				begin
					data ex_ch, int
					data exceptionRecord, string

					open(ex_ch=0,o:s,localExceptionsFile)

					foreach exceptionRecord in exceptionRecords
						writes(ex_ch,exceptionRecord)
						
					close ex_ch

					exceptionCount = exceptionRecords.Length

					ttlog(%string(exceptionCount) + " items saved to " + localExceptionsFile)
				end
			end
			else
			begin
				;;Error file does not exist! In theory this should not happen, because we got here due to "data conversion error" being reported
				ttlog("Remote exceptions data file not found!")
			end
		end
		else
		begin
			;;Failed to determine if file exists
			ttlog("Failed to determine if remote exceptions data file exists. Error was " + tmpmsg)
		end

		;;Now check for and retrieve the associated exceptions log

		if (fsc.Exists(remoteExceptionsLog,fileExists,tmpmsg)) then
		begin
			if (fileExists) then
			begin
				;;Download the error file
				data exceptionRecords, [#]string

				ttlog("Downloading remote exceptions log file")

				if (fsc.DownloadText(remoteExceptionsLog,exceptionRecords))
				begin
					data ex_ch, int
					data exceptionRecord, string

					open(ex_ch=0,o:s,localExceptionsLog)

					foreach exceptionRecord in exceptionRecords
						writes(ex_ch,exceptionRecord)

					close ex_ch

					ttlog(%string(exceptionRecords.Length) + " items saved to " + localExceptionsLog)
				end
			end
			else
			begin
				;;Error file does not exist! In theory this should not happen, because we got here due to "data conversion error" being reported
				ttlog("Remote exceptions file not found!")
			end
		end
		else
		begin
			;;Failed to determine if file exists
			ttlog("Failed to determine if remote exceptions log file exists. Error was " + tmpmsg)
		end
	end
	else
	begin
		;;Local bulk load

		if (File.Exists(localExceptionsFile)) then
		begin
			data ex_ch, int
			data tmprec, a65535
			open(ex_ch=0,i:s,localExceptionsFile)
			repeat
			begin
				reads(ex_ch,tmprec,eof)
				exceptionCount += 1
			end
eof,		close ex_ch
			ttlog(%string(exceptionCount) + " exception items found in " + localExceptionsFile)
		end
		else
		begin
			;;Error file does not exist! In theory this should not happen, because we got here due to "data conversion error" being reported
			ttlog("Exceptions data file not found!")
		end
	end

	return

DeleteFiles,

	;;Delete local files
	
	xcall delet(localCsvFile)
	xcall delet(localExceptionsFile)
	xcall delet(localExceptionsLog)

	;;Delete remote files

	if (remoteBulkLoad)
	begin
		fsc.Delete(remoteCsvFile)
		fsc.Delete(remoteExceptionsFile)
		fsc.Delete(remoteExceptionsLog)
	end

	return

endfunction

;;*****************************************************************************
;;; <summary>
;;; Close cursors associated with the Relstr table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel</param>

subroutine RelstrClose

    required in  a_dbchn, i
    endparams

    .include "CONNECTDIR:ssql.def"

    external common
        csr_relstr_update,  i4
    endcommon

proc

    if (csr_relstr_update)
    begin
        if (%ssc_close(a_dbchn,csr_relstr_update))
            nop
        clear csr_relstr_update
    end

    xreturn

endsubroutine

;;*****************************************************************************
;;; <summary>
;;; Exports REPLICATOR_DATA:RELFILE.DDF to a CSV file.
;;; </summary>
;;; <param name="fileSpec">File to create</param>
;;; <param name="recordCount">Returned error text.</param>
;;; <param name="errorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function RelstrCsv, ^val
	required in  fileSpec, string
	optional out recordCount, n
	optional out errorMessage, a
    endparams

    .include "CONNECTDIR:ssql.def"
    .include "RELSTR" repository, record="relstr", end
    .include "INC:structureio.def"

    .define EXCEPTION_BUFSZ 100

	stack record local_data
		ok,				boolean     ;;Return status
		filechn,		int         ;;Data file channel
		csvchn,			int         ;;CSV file channel
		csvrec,			string		;;A CSV file record
		errnum,			int         ;;Error number
		records,		int         ;;Number of records exported
		errtxt,			a256        ;;Error message text
	endrecord

proc

    init local_data
    ok = true

    ;;Open the data file associated with the structure

    if (%RelstrIO(IO_OPEN_INP,filechn)!=IO_OK)
    begin
        ok = false
        errtxt = "Failed to open file REPLICATOR_DATA:RELFILE.DDF"
        clear filechn
    end

    if (ok)
    begin
		;;Create the local CSV file
		.ifdef OS_WINDOWS7
		open(csvchn=0,o:s,fileSpec)
		.endc
		.ifdef OS_UNIX
		open(csvchn=0,o,fileSpec)
		.endc
		.ifdef OS_VMS
		open(csvchn=0,o,fileSpec,OPTIONS:"/stream")
		.endc

		;;Add a row of column headers
		.ifdef OS_WINDOWS7
		writes(csvchn,"RecordNumber|Field1<|>RecordNumber|Field2<|>RecordNumber|Field3<|>RecordNumber|Field4<|>Field1<|>Field2<|>Field3<|>Field4<|>")
		.else
		puts(csvchn,"RecordNumber|Field1<|>RecordNumber|Field2<|>RecordNumber|Field3<|>RecordNumber|Field4<|>" + %char(13) + %char(10))
		.endc

        ;;Read and add data file records
        repeat
        begin
            ;;Get the next record from the input file
            errnum = %RelstrIO(IO_READ_NEXT,filechn,,relstr)

            using errnum select
            (IO_OK),
            begin
				records += 1
                csvrec = ""
				&	+ %string(records) + "|"
                &    + %atrim(relstr.field1) + "|"
				&	+ %string(records) + "|"
                &    + %string(relstr.field2) + "|"
				&	+ %string(records) + "|"
                &    + %string(relstr.field3,"XXXX-XX-XX") + "|"
				&	+ %string(records) + "|"
                &    + %string(relstr.field4,"XX:XX:XX") + ""
 
				.ifdef OS_WINDOWS7
				writes(csvchn,csvrec)
				.else
				puts(csvchn,csvrec + %char(13) + %char(10))
				.endc
            end
            (IO_EOF),
                exitloop
            (),
            begin
                ok = false
                errtxt = "Unexpected response " + %string(errnum) + " from %RelstrIO"
                exitloop
            end
            endusing
        end
    end

    ;;Close the CSV file
    if (csvchn)
        close csvchn

    ;;Close the data file
    if (filechn)
        xcall RelstrIO(IO_CLOSE,filechn)

    ;;Return the record count
    if (^passed(recordCount))
        recordCount = records

    ;;Return the error text
    if (^passed(errorMessage))
        errorMessage = errtxt

    freturn ok

endfunction


