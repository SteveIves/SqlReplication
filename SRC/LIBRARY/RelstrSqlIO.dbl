;;*****************************************************************************
;;
;; File:        RelstrSqlIO.dbl
;;
;; Type:        Functions
;;
;; Description: Various functions that performs SQL I/O for RELSTR
;;
;;*****************************************************************************
;;
;; Copyright (c) 2009, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************
;; WARNING: THIS CODE WAS CODE GENERATED AND WILL BE OVERWRITTEN IF CODE
;;          GENERATION IS RE-EXECUTED FOR THIS PROJECT.
;;*****************************************************************************

;;*****************************************************************************
;;; <summary>
;;; Determines if the Relstr table exists in the database.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns 1 if the table exists, otherwise a number indicating the type of error.</returns>

function relstr_exists, ^val

    required in  a_dbchn,  i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        error       ,int    ;;Returned error number
        dberror     ,int    ;;Database error number
        cursor      ,int    ;;Database cursor
        length      ,int    ;;Length of a string
        table_name  ,a128   ;;Retrieved table name
        errtxt      ,a256   ;;Error message text
    endrecord

proc

    init local_data

    ;;Open a cursor for the SELECT statement

    if (%ssc_open(a_dbchn,cursor,"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME='Relstr'",SSQL_SELECT)==SSQL_FAILURE)
    begin
        error=-1
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to open cursor"
    end

    ;;Bind host variables to receive the data

    if (!error)
    begin
        if (%ssc_define(a_dbchn,cursor,1,table_name)==SSQL_FAILURE)
        begin
            error=-1
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variable"
        end
    end

    ;;Move data to host variables

    if (!error)
    begin
        if (%ssc_move(a_dbchn,cursor,1)==SSQL_NORMAL)
                error = 1 ;; Table exists
    end

    ;;Close the database cursor

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (!error)
            begin
                error=-1
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (error) then
            a_errtxt = errtxt
        else
            a_errtxt = ""
    end

    freturn error

endfunction

;;*****************************************************************************
;;; <summary>
;;; Creates the Relstr table in the database.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function relstr_create, ^val

    required in  a_dbchn,  i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    .align
    stack record local_data
        ok          ,boolean    ;;Return status
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        transaction ,int        ;;Transaction in process
        errtxt      ,a512       ;;Returned error message text
        sql         ,string     ;;SQL statement
    endrecord

proc

    init local_data
    ok = true

    ;;Start a database transaction

    if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
        transaction=1
    else
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to start transaction"
    end

    ;;Create the database table and primary key constraint

    if (ok)
    begin
        sql = 'CREATE TABLE "Relstr" ('
        & + '"RecordNumber" INT NOT NULL,'
        & + '"Field1" VARCHAR(1),'
        & + '"Field2" DECIMAL(2),'
        & + '"Field3" DATE,'
        & + '"Field4" TIME(0)'
        & + 'CONSTRAINT PK_Relstr PRIMARY KEY CLUSTERED("RecordNumber" ASC)'
        & + ')'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;;Grant access permissions

    if (ok)
    begin
        sql = 'GRANT ALL ON "Relstr" TO PUBLIC'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;;Commit or rollback the transaction

    if (transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = errtxt
    end

    freturn ok

open_cursor,

    if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to open cursor"
    end

    return

execute_cursor,

    if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to execute SQL statement"
    end

    return

close_cursor,

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
        clear cursor
    end

    return

endfunction

;;*****************************************************************************
;;; <summary>
;;; Insert a row into the Relstr table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_recnum">Relative record number to be inserted.</param>
;;; <param name="a_data">Record to be inserted.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns 1 if the row was inserted, 2 to indicate the row already exists, or 0 if an error occurred.</returns>

function relstr_insert_row, ^val

    required in  a_dbchn,  i
	required in  a_recnum, n
    required in  a_data,   a
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    .align
    stack record local_data
        ok          ,boolean    ;;OK to continue
        openAndBind ,boolean    ;;Should we open the cursor and bind data this time?
        sts         ,int        ;;Return status
        dberror     ,int        ;;Database error number
        transaction ,int        ;;Transaction in progress
        length      ,int        ;;Length of a string
        errtxt      ,a256       ;;Error message text
		recordNumber,d28		;;Relative record number
    endrecord

    literal
        sql         ,a*, "INSERT INTO Relstr ("
        & +              '"RecordNumber",'
        & +              '"Field1",'
        & +              '"Field2",'
        & +              '"Field3",'
        & +              '"Field4"'
        & +              ") VALUES(:1,:2,:3,:4,:5)"
    endliteral

    .include "RELSTR" repository, static record="relstr", end

    static record
        tmpField4, a7      ;;Storage for HH:MM:SS time field
        ,a1                         ;;In case there are no user timestamp, date or JJJJJJ date fields
    endrecord

    global common
        csr_relstr_insert1, i4, 0
    endcommon

proc

    init local_data
    ok = true
    sts = 1
	recordNumber = a_recnum
    openAndBind = (csr_relstr_insert1 == 0)

    ;;Start a database transaction

    if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
        transaction=1
    else
    begin
        ok = false
        sts = 0
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to start transaction"
    end

    ;;Open a cursor for the INSERT statement

    if (ok && openAndBind)
    begin
        if (%ssc_open(a_dbchn,csr_relstr_insert1,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Bind the host variables for data to be inserted

	if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,csr_relstr_insert1,1,recordNumber)==SSQL_FAILURE)
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variables"
        end
	end

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,csr_relstr_insert1,4,
        &    relstr.field1,
        &    relstr.field2,
        &    ^a(relstr.field3),
        &    tmpField4)==SSQL_FAILURE)
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variables"
        end
    end

    ;;Insert the row into the database

    if (ok)
    begin
        ;;Load data into bound record

        relstr = a_data

        ;;Clean up any alpha fields

        relstr.field1 = %atrim(relstr.field1)+%char(0)

        ;;Clean up any decimal fields

        if ((!relstr.field2)||(!%IsNumeric(^a(relstr.field2))))
            clear relstr.field2

        ;;Clean up any date fields

        if ((!relstr.field3)||(!%IsDate(^a(relstr.field3))))
            ^a(relstr.field3(1:1))=%char(0)

        ;;Clean up any time fields

        if ((!relstr.field4)||(!%IsTime(^a(relstr.field4))))
            ^a(relstr.field4(1:1))=%char(0)

        ;;Assign data to any temporary time or user-defined timestamp fields

        tmpField4 = %string(relstr.field4,"XX:XX:XX")

        ;;Execute the INSERT statement

        if (%ssc_execute(a_dbchn,csr_relstr_insert1,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_NORMAL) then
            begin
                ;;If it's a "row exists" then return 2
                using dberror select
                (-2627),
                begin
                    ;;Duplicate key
                    errtxt = "Duplicate key detected in database!"
                    sts = 2
                end
                (),
                    nop
                endusing
            end
            else
                errtxt="Failed to execute SQL statement"
        end
    end

    ;;Commit or rollback the transaction

    if (transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                sts = 0
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = errtxt
    end

    freturn sts

endfunction

;;*****************************************************************************
;;; <summary>
;;; Inserts multiple rows into the Relstr table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel</param>
;;; <param name="a_data">Memory handle containing one or more rows to insert.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <param name="a_exception">Memory handle to load exception data records into.</param>
;;; <param name="a_terminal">Terminal number channel to log errors on.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function relstr_insert_rows, ^val

    required in  a_dbchn,     i
    required in  a_data,      i
    optional out a_errtxt,    a
    optional out a_exception, i
    optional in  a_terminal,  i
    endparams

    .include "CONNECTDIR:ssql.def"

    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok          ,boolean    ;;Return status
        openAndBind ,boolean    ;;Should we open the cursor and bind data this time?
        dberror     ,int        ;;Database error number
        rows        ,int        ;;Number of rows to insert
        transaction ,int        ;;Transaction in progress
        length      ,int        ;;Length of a string
        ex_ms       ,int        ;;Size of exception array
        ex_mc       ,int        ;;Items in exception array
        continue    ,int        ;;Continue after an error
        errtxt      ,a512       ;;Error message text
        recordNumber,d28
    endrecord

    literal
        sql         ,a*, "INSERT INTO Relstr ("
        & +              '"RecordNumber",'
        & +              '"Field1",'
        & +              '"Field2",'
        & +              '"Field3",'
        & +              '"Field4"'
        & +              ") VALUES(:1,:2,:3,:4,:5)"
    endliteral

    structure inpbuf
        recnum, d28
        .include "RELSTR" repository, group="inprec", nofields
    endstructure
    .include "RELSTR" repository, static record="relstr", end

    static record
        tmpField4, a7      ;;Storage for HH:MM:SS time field
        ,a1                         ;;In case there are no user timestamp, date or JJJJJJ date fields
    endrecord

    global common
        csr_relstr_insert2, i4
    endcommon

proc

    init local_data
    ok = true

    openAndBind = (csr_relstr_insert2 == 0)

    if (^passed(a_exception)&&a_exception)
        clear a_exception

    ;;Figure out how many rows to insert

    rows = (%mem_proc(DM_GETSIZE,a_data)/^size(inpbuf))

    ;;Start a database transaction

    if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
        transaction=1
    else
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to start transaction"
    end

    ;;Open a cursor for the INSERT statement

    if (ok && openAndBind)
    begin
        if (%ssc_open(a_dbchn,csr_relstr_insert2,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Bind the host variables for data to be inserted

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,csr_relstr_insert2,1,recordNumber)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variables"
        end
    end
    
    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,csr_relstr_insert2,4,
        &    relstr.field1,
        &    relstr.field2,
        &    ^a(relstr.field3),
        &    tmpField4)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variables"
        end
    end

    ;;Insert the rows into the database

    if (ok)
    begin
        data cnt, int
        for cnt from 1 thru rows
        begin
            ;;Load data into bound record

            recordNumber = ^m(inpbuf[cnt].recnum,a_data)
            relstr = ^m(inpbuf[cnt].inprec,a_data)

            ;;Clean up any alpha variables

            relstr.field1=%atrim(relstr.field1)+%char(0)

            ;;Clean up any decimal variables

            if ((!relstr.field2)||(!%IsNumeric(^a(relstr.field2))))
                clear relstr.field2

            ;;Clean up any date variables

            if ((!relstr.field3)||(!%IsDate(^a(relstr.field3))))
                ^a(relstr.field3(1:1))=%char(0)

            ;;Clean up any time variables

            if ((!relstr.field4)||(!%IsTime(^a(relstr.field4))))
                ^a(relstr.field4(1:1))=%char(0)

            ;;Assign any time or user-defined timestamp fields

            tmpField4 = %string(relstr.field4,"XX:XX:XX")

            ;;Execute the statement

            if (%ssc_execute(a_dbchn,csr_relstr_insert2,SSQL_STANDARD)==SSQL_FAILURE)
            begin
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to execute SQL statement"

                clear continue

                ;;Are we logging errors?
                if (^passed(a_terminal)&&(a_terminal))
                begin
                    writes(a_terminal,errtxt(1:length))
                    continue=1
                end

                ;;Are we processing exceptions?
                if (^passed(a_exception))
                begin
                    if (ex_mc==ex_ms)
                    begin
                        if (!a_exception) then
                            a_exception = %mem_proc(DM_ALLOC|DM_STATIC,^size(inpbuf)*(ex_ms=EXCEPTION_BUFSZ))
                        else
                            a_exception = %mem_proc(DM_RESIZ,^size(inpbuf)*(ex_ms+=EXCEPTION_BUFSZ),a_exception)
                    end
                    ^m(inpbuf[ex_mc+=1],a_exception)=relstr
                    continue=1
                end

                if (continue) then
                    nextloop
                else
                begin
                    ok = false
                    exitloop
                end
            end
        end
    end

    ;;Commit or rollback the transaction

    if (transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;If we're returning exceptions then resize the buffer to the correct size

    if (^passed(a_exception)&&a_exception)
        a_exception = %mem_proc(DM_RESIZ,^size(inpbuf)*ex_mc,a_exception)

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = %atrim(errtxt)+" [Database error "+%string(dberror)+"]"
    end

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Updates a row in the Relstr table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_recnum">record number.</param>
;;; <param name="a_data">Record containing data to update.</param>
;;; <param name="a_rows">Returned number of rows affected.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function relstr_update_row, ^val

    required in  a_dbchn,  i
    required in  a_recnum, n
    required in  a_data,   a
    optional out a_rows,   i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        ok          ,boolean    ;;OK to continue
        openAndBind ,boolean    ;;Should we open the cursor and bind data this time?
        transaction ,boolean    ;;Transaction in progress
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        rows        ,int        ;;Number of rows updated
        errtxt      ,a256       ;;Error message text
    endrecord

    literal
        sql         ,a*, 'UPDATE Relstr SET '
        & +              '"Field1"=:1,'
        & +              '"Field2"=:2,'
        & +              '"Field3"=:3,'
        & +              '"Field4"=:4'
        & +              ' WHERE "RecordNumber"=:5'
    endliteral

    .include "RELSTR" repository, static record="relstr", end

    static record
        tmpField4, a7      ;;Storage for HH:MM:SS time field
        ,a1                         ;;In case there are no user timestamp, date or JJJJJJ date fields
    endrecord

    global common
        csr_relstr_update, i4
    endcommon
proc

    init local_data
    ok = true

    openAndBind = (csr_relstr_update == 0)

    if (^passed(a_rows))
        clear a_rows

    ;;Load the data into the bound record

    relstr = a_data

    ;;Start a database transaction

    if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
        transaction = true
    else
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to start transaction"
    end

    ;;Open a cursor for the UPDATE statement

    if (ok && openAndBind)
    begin
        if (%ssc_open(a_dbchn,csr_relstr_update,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Bind the host variables for data to be updated

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,csr_relstr_update,4,
        &    relstr.field1,
        &    relstr.field2,
        &    ^a(relstr.field3),
        &    tmpField4)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variables"
        end
    end

    ;;Bind the host variables for the key segments / WHERE clause

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,csr_relstr_update,1,a_recnum)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind key variables"
        end
    end

    ;;Update the row in the database

    if (ok)
    begin
        ;;Clean up any alpha fields

        relstr.field1 = %atrim(relstr.field1) + %char(0)
        
        ;;Clean up any decimal fields

        if ((!relstr.field2)||(!%IsNumeric(^a(relstr.field2))))
            clear relstr.field2

        ;;Clean up any date fields

        if ((!relstr.field3)||(!%IsDate(^a(relstr.field3))))
            ^a(relstr.field3(1:1)) = %char(0)

        ;;Clean up any time fields

        if ((!relstr.field4)||(!%IsTime(^a(relstr.field4))))
            ^a(relstr.field4(1:1)) = %char(0)

        ;;Assign any time and user-defined timestamp fields

        tmpField4 = %string(relstr.field4,"XX:XX:XX")

        if (%ssc_execute(a_dbchn,csr_relstr_update,SSQL_STANDARD,,rows)==SSQL_NORMAL) then
        begin
            if (^passed(a_rows))
                a_rows = rows
        end
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to execute SQL statement"
        end
    end

    ;;Commit or rollback the transaction

    if (transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;Return error message

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = errtxt
    end

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Deletes all rows from the Relstr table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function relstr_clear, ^val

    required in  a_dbchn,  i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        ok          ,boolean    ;;Return status
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        transaction ,int        ;;Transaction in process
        errtxt      ,a512       ;;Returned error message text
        sql         ,string     ;;SQL statement
    endrecord

proc

    init local_data
    ok = true

    ;;Start a database transaction

    if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
        transaction=1
    else
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to start transaction"
    end

    ;;Open cursor for the SQL statement

    if (ok)
    begin
        sql = 'TRUNCATE TABLE "Relstr"'
        if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Execute SQL statement

    if (ok)
    begin
        if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to execute SQL statement"
        end
    end

    ;;Close the database cursor

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
    end

    ;;Commit or rollback the transaction

    if (transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = errtxt
    end

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Deletes the Relstr table from the database.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function relstr_drop, ^val

    required in  a_dbchn,  i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        ok          ,boolean    ;;Return status
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        transaction ,int        ;;Transaction in progress
        errtxt      ,a256       ;;Returned error message text
    endrecord

proc

    init local_data
    ok = true

    ;;Close any open cursors

    xcall relstr_close(a_dbchn)

    ;;Start a database transaction

    if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
        transaction=1
    else
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to start transaction"
    end

    ;;Open cursor for DROP TABLE statement

    if (ok)
    begin
        if (%ssc_open(a_dbchn,cursor,"DROP TABLE Relstr",SSQL_NONSEL)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Execute DROP TABLE statement

    if (ok)
    begin
        if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_NORMAL) then
            begin
                ;;Check if the error was that the table did not exist
                if (dberror==-3701) then
                    clear errtxt
                else
                    ok = false
            end
            else
            begin
                errtxt="Failed to execute SQL statement"
                ok = false
            end
        end
    end

    ;;Close the database cursor

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
    end

    ;;Commit or rollback the transaction

    if (transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = errtxt
    end

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Load all data from DAT:RELFILE.DDF into the Relstr table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <param name="a_logex">Log exception records?</param>
;;; <param name="a_terminal">Terminal channel to log errors on.</param>
;;; <param name="a_added">Total number of successful inserts.</param>
;;; <param name="a_failed">Total number of failed inserts.</param>
;;; <param name="a_progress">Report progress.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function relstr_load, ^val

    required in  a_dbchn,    i
    optional out a_errtxt,   a
    optional in  a_logex,    i
    optional in  a_terminal, i
    optional out a_added,    n
    optional out a_failed,   n
    optional in  a_progress, n
    endparams

    .include "CONNECTDIR:ssql.def"
    structure inpbuf
        recnum, d28
        .include "RELSTR" repository, group="inprec"
    endstructure
    .include "RELSTR" repository, structure="RELSTR", end
    .include "RELSTR" repository, stack record="TMPREC", end
    .include "INC:structureio.def"

    .define BUFFER_ROWS     1000
    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok          ,boolean    ;;Return status
        firstRecord ,boolean    ;;Is this the first record?
        filechn     ,int        ;;Data file channel
        mh          ,D_HANDLE   ;;Memory handle containing data to insert
        ms          ,int        ;;Size of memory buffer in rows
        mc          ,int        ;;Memory buffer rows currently used
        ex_mh       ,D_HANDLE   ;;Memory buffer for exception records
        ex_mc       ,int        ;;Number of records in returned exception array
        ex_ch       ,int        ;;Exception log file channel
        attempted   ,int        ;;Rows being attempted
        ttl_added   ,int        ;;Total rows added
        ttl_failed  ,int        ;;Total failed inserts
        errnum      ,int        ;;Error number
        errtxt      ,a256       ;;Error message text
        recordNumber,d28
    endrecord

proc

    init local_data
    ok = true
    recordNumber = 0

    ;;If we are logging exceptions, delete any existing exceptions file.
    if (^passed(a_logex) && a_logex)
    begin
        xcall delet("REPLICATOR_LOGDIR:relstr_data_exceptions.log")
    end

    ;;Open the data file associated with the structure

    if (%relstr_io(IO_OPEN_INP,filechn)!=IO_OK)
    begin
        ok = false
        errtxt = "Failed to open file DAT:RELFILE.DDF"
        clear filechn
    end

    if (ok)
    begin
        ;;Allocate memory buffer for the database rows

        mh = %mem_proc(DM_ALLOC,^size(inpbuf)*(ms=BUFFER_ROWS))

        ;;Read records from the input file

        firstRecord = true
        repeat
        begin
            ;;Get the next record from the input file
            if (firstRecord) then
            begin
                errnum = %relstr_io(IO_READ_FIRST,filechn,,tmprec)
                firstRecord = false
            end
            else
            begin
                errnum = %relstr_io(IO_READ_NEXT,filechn,,tmprec)
            end

            using errnum select
            (IO_OK),
			begin
                recordNumber += 1
				if (!tmprec)
					nextloop
			end
            (IO_EOF),
                exitloop
            (),
            begin
                ok = false
                errtxt = "Unexpected response " + %string(errnum) + " from %relstr_io"
                exitloop
            end
            endusing

            ;;Got one, load it into or buffer
            ^m(inpbuf[mc+=1].recnum,mh) = recordNumber
            ^m(inpbuf[mc].inprec,mh) = tmprec

            ;;If the buffer is full, write it to the database
            if (mc==ms)
                call insert_data
        end

        if (mc)
        begin
            mh = %mem_proc(DM_RESIZ,^size(inpbuf)*mc,mh)
            call insert_data
        end

        ;;Deallocate memory buffer

        mh = %mem_proc(DM_FREE,mh)

    end

    ;;Close the file

    if (filechn)
        xcall relstr_io(IO_CLOSE,filechn)

    ;;Close the exceptions log file

    if (ex_ch)
        close ex_ch

    ;;Return the error text

    if (^passed(a_errtxt))
        a_errtxt = errtxt

    ;;Return totals

    if (^passed(a_added))
        a_added = ttl_added
    if (^passed(a_failed))
        a_failed = ttl_failed

    freturn ok

insert_data,

    attempted = (%mem_proc(DM_GETSIZE,mh)/^size(inpbuf))

    if (%relstr_insert_rows(a_dbchn,mh,errtxt,ex_mh,a_terminal))
    begin
        ;;Any exceptions?
        if (ex_mh) then
        begin
            ;;How many exceptions to log?
            ex_mc = (%mem_proc(DM_GETSIZE,ex_mh)/^size(inpbuf))
            ;;Update totals
            ttl_failed+=ex_mc
            ttl_added+=(attempted-ex_mc)
            ;;Are we logging exceptions?
            if (^passed(a_logex)&&a_logex) then
            begin
                data cnt, int
                ;;Open the log file
                if (!ex_ch)
                    open(ex_ch=0,o:s,"REPLICATOR_LOGDIR:relstr_data_exceptions.log")
                ;;Log the exceptions
                for cnt from 1 thru ex_mc
                    writes(ex_ch,^m(inpbuf[cnt],ex_mh))
                if (^passed(a_terminal)&&a_terminal)
                    writes(a_terminal,"Exceptions were logged to REPLICATOR_LOGDIR:relstr_data_exceptions.log")
            end
            else
            begin
                ;;No, report and error
                ok = false
            end
            ;;Release the exception buffer
            ex_mh=%mem_proc(DM_FREE,ex_mh)
        end
        else
        begin
            ;;No exceptions
            ttl_added += attempted
            if ^passed(a_terminal) && a_terminal && ^passed(a_progress) && a_progress
                writes(a_terminal," - " + %string(ttl_added) + " rows inserted")
        end
    end

    clear mc

    return

endfunction

;;*****************************************************************************
;;; <summary>
;;; Close cursors associated with the Relstr table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel</param>

subroutine relstr_close

    required in  a_dbchn, i
    endparams

    .include "CONNECTDIR:ssql.def"

    external common
        csr_relstr_update,  i4
    endcommon

proc

    if (csr_relstr_update)
    begin
        if (%ssc_close(a_dbchn,csr_relstr_update))
            nop
        clear csr_relstr_update
    end

    xreturn

endsubroutine

;;*****************************************************************************
;;; <summary>
;;; Exports DAT:RELFILE.DDF to a CSV file.
;;; </summary>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function relstr_create_csv, ^val

    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"
    .include "RELSTR" repository, record="relstr", end
    .include "INC:structureio.def"

    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok          ,boolean    ;;Return status
        filechn     ,int        ;;Data file channel
        csvchn      ,int        ;;CSV file channel
        errnum      ,int        ;;Error number
        attempted   ,int        ;;Number of records exported
        errtxt      ,a256       ;;Error message text
    endrecord

proc

    init local_data
    ok = true

    ;;Open the data file associated with the structure

    if (%relstr_io(IO_OPEN_INP,filechn)!=IO_OK)
    begin
        ok = false
        errtxt = "Failed to open file DAT:RELFILE.DDF"
        clear filechn
    end

    ;;Open the CSV file

    if (ok)
    begin
        open(csvchn=0,o:s,"REPLICATOR_EXPORT:relstr.csv")
        writes(csvchn,"Field1|Field2|Field3|Field4")
    end

    if (ok)
    begin
        ;;Read records from the input file

        repeat
        begin

            ;;Get the next record from the input file

            errnum = %relstr_io(IO_READ_NEXT,filechn,,relstr)

            using errnum select
            (IO_OK),
            begin
                data buff, string, ""
                buff = ""
                &    + %atrim(relstr.field1) + "|"
                &    + %string(relstr.field2) + "|"
                &    + %atrim(^a(relstr.field3)) + "|"
                &    + %string(relstr.field4,"XX:XX:XX") + ""
                writes(csvchn,buff)
                attempted += 1
            end
            (IO_EOF),
                exitloop
            (),
            begin
                ok = false
                errtxt = "Unexpected response " + %string(errnum) + " from %relstr_io"
                exitloop
            end
            endusing
        end
    end

    ;;Close the CSV file

    if (csvchn)
        close csvchn

    ;;Create the SQL command file

    if (ok)
    begin
        data csvdir, a128
        data csvlen, i4
        data csvfile, string, ""

        xcall getlog("CSV",csvdir,csvlen)

        if (csvlen)
            csvfile = %atrim(csvdir)

        if (csvfile.EndsWith("\")) then
            csvfile = csvfile + "relstr.csv"
        else
            csvfile = csvfile + "\relstr.csv"

        open(csvchn=0,o:s,"REPLICATOR_EXPORT:relstr.sql")

        writes(csvchn,"")
        writes(csvchn,"/*")
        writes(csvchn,"Use <put database name here>")
        writes(csvchn,"GO")
        writes(csvchn,"*/")
        writes(csvchn,"")
        writes(csvchn,"TRUNCATE TABLE Relstr")
        writes(csvchn,"GO")
        writes(csvchn,"")
        writes(csvchn,"BULK INSERT Relstr")
        writes(csvchn,"    FROM '" + csvfile + "'")
        writes(csvchn,"    WITH")
        writes(csvchn,"    (")
        writes(csvchn,"        FIRSTROW=2,")
        writes(csvchn,"        FIELDTERMINATOR='|',")
        writes(csvchn,"        ROWTERMINATOR ='\n'")
        writes(csvchn,"    )")
        writes(csvchn,"GO")
        writes(csvchn,"")

        close csvchn
    end

    ;;Close the file

    if (filechn)
        xcall relstr_io(IO_CLOSE,filechn)

    ;;Return the error text

    if (^passed(a_errtxt))
        a_errtxt = errtxt

    freturn ok

endfunction

