;*******************************************************************************
;
; Routine:      EMPLOYEE_MAINT_TAB
;
; Description:  Master file maintenance for EMPLOYEE structure
;
; Author:       Steve Ives (stevei)
;
; Company:      Synergex
;
; Created:      04/10/2008 at 15:01
;
;*******************************************************************************
;
; WARNING:      This code was generated by CodeGen V3.1.  Any changes that
;               you make to this file will be lost if the code is regenerated.
;
; This code is supplied as seen and without warranty or support, and is used
; at your own risk. Neither the author or Synergex accept any responsability
; for any loss or damage which may result from the use of this code. This text
; must remain unaltered in this file at all times. Possession or use of this
; code, or any modified version of this code, indicates your acceptance of
; these conditions.
;
;*******************************************************************************
;
; This routine first builds and processes a tab set which allows searching the
; master file based on multiple keys.  The first page of the tab set allows
; the user to select the key to be used, and optionally enter a partial value
; for the key search.  For example, for a customer file, searches may be done
; by account number, company name, city, state, zip code etc.  The user could
; for example select company name, and enter S to search for all customers
; beginning with S.  When the user clicks OK or hits return, the results are
; shown in a list on the second tab page.
;
; When the user clicks on or hits return on a record in the results list, the
; routine presents a second tab set containing multiple pages allowing them
; to maintain the record.
;
; The routine also supports creating new records, deleting records.  These
; functions can all be supressed if not required.
;
; The routine requires several windows to be present in the window library
; referred to by g_utlib. The names of those windows are constructed using a
; base window name which is the name of the structure:
;
;    EMPLOYEE_CTA        ;Search criteria input window
;    EMPLOYEE_LUP        ;Search results list input window
;    EMPLOYEEn           ;Multiple input windows for the input tab set
;
; In constructing these windows you must comply with the following requirements:
;
; Search criteria input window
; ----------------------------
;
; Must be named EMPLOYEE_CTA and fields MUST be defined in a structure
; called EMPLOYEE_CRITERIA
;
; The size of this window will determine the size of the search tabset.
; The first field in the window MUST be a D1 called MODE.  This field indicates
; the search mode (in other words which key to read the master file on when
; searching).  The field should normally be an enumerated selection list
; (displayed as radio buttons or a dropdown list).  The base enumeration value
; MUST be 1 and the step value MUST be 1. The field MUST specify a change method
; name of "employee_mntmode".
;
; For each selectable item in the MODE field there should be an ALPHA field of
; the appropriate size for the key value required.  These fields MUST be named
; FIELD<n> (FIELD1, FIELD2 etc.)
;
; There MUST be 2 sets defined in the window. The first set MUST be called ALL
; and MUST contain all fields in the window.  The second set MUST be called DATA
; and must contain all fields except MODE.
;
; I would recommend defining these fields in a repository structure.
;
; The keys referred to by the various MODE options MUST be encoded into the
; title of the window, as a string of D2 values.  For example, if the first
; search option uses key 2 and the second search option uses key 4, the title of
; the criteria window MUST be set to 0204
;
; An example of a search criteria window would be:
;
;       .input EMPLOYEE_CTA, 20, 88
;       .title "0300040105"
;       .repository_structure EMPLOYEE_CRITERIA
;       .field MODE, pos(2, 4), fpos(2, 14)
;       .field FIELD1, fpos(2, 38)
;       .field FIELD2, fpos(3, 38)
;       .field FIELD3, fpos(4, 38)
;       .field FIELD4, fpos(5, 38)
;       .field FIELD5, fpos(6, 38)
;       .set ALL, EMPLOYEE_CRITERIA, MODE, FIELD1, FIELD2, FIELD3, FIELD4, FIELD5
;       .set DATA, EMPLOYEE_CRITERIA, FIELD1, FIELD2, FIELD3, FIELD4, FIELD5
;       .end
;
; Search results list input window
; --------------------------------
;
; MUST be named EMPLOYEE_LUP and MUST be one row high
;
; MUST be based on the Repository structure of the master file being maintained,
; and should contain the fields to define the columns to view in the results
; list.  Fields should have prompts and methods disabled, and should be
; positioned adjacent to each other.
;
; An example of a search results list input window would be:
;
;    .input EMPLOYEE_LUP, 1, 67
;    .border on, dragbar(on)
;    .repository_structure EMPLOYEE
;    .field CODE, noprompt, fpos(1, 1), nochange_method, nodrill_method
;    .field NAME, noprompt, fpos(1, 7)
;    .field CITY, noprompt, fpos(1, 33)
;    .field STATE, noprompt, fpos(1, 54), nochange_method, nodrill_method
;    .field AKEY, noprompt, fpos(1, 57)
;    .end
;
; Maintenance tabset input windows
; --------------------------------
;
; Must be named EMPLOYEEn (e.g. EMPLOYEE1, EMPLOYEE2 etc.)
;
; The size of the largest window determines the size of the maintenance tabset.
; The title of each window will be the selection text on that windows tab. Each
; window MUST be based on the repository structure being maintained.  This MAY
; be a super-structure which contains the actual master file's structure and
; additional local display field definitions. If this is the case, then the
; group representing the actual master file MUST be the first field in the
; super-structure, followed by the additional display fields, which MUST be
; named in the format <field>_DSP, and MUST have either the disabled or
; read-only attribute set.  The name of the super-structure MUST be defined as
; EMPLOYEE_INPUT.
;
; In ALL windows the first set MUST be called ALL and must contain ALL fields
; (including local display fields). The FIRST window must also have 2 additional
; sets, one called KEY (which must include only the primary key field) and one
; called DATA (which must include all fields except the primary key field).
;
;*******************************************************************************
;
subroutine employee_maint_tab
    required in a_base_title    ,a  ;Base text for tabset titles (e.g."Customer")
    optional in a_channel       ,n  ;Master file update mode channel
    optional in a_lst_header    ,a  ;Search list column headers
    optional in a_lst_footer    ,a  ;Search list footer
    optional in a_icon          ,a  ;Icon file name
    optional in a_no_amend      ,n  ;Suppress "Amend" (view obly)
    optional in a_no_create     ,n  ;Suppress "New" button
    optional in a_no_delete     ,n  ;Suppress "Delete" button
    endparams

    .include "WND:tools.def"
    .include "WND:fldinf.def"
    .include "WND:setinf.def"
    .include "WND:windows.def"
    .include "DBLDIR:activex.def"
    .include "INC:system.def"
    .include "GENSRC:StructureIO.def"

    ;Main data buffers
    .include "EMPLOYEE" repository, stack record="employee", nofields
    .include "EMPLOYEE" repository, stack record="employee_save", nofields
    .include "EMPLOYEE_INPUT" repository, stack record="employee_input", nofields
    .include "EMPLOYEE_CRITERIA" repository, stack record="criteria", nofields
    .include "EMPLOYEE_CRITERIA" repository, stack record="last_criteria", nofields
    
    stack record local_data
        ok              ,i4     ;OK to continue
        error           ,i4     ;An error was detected
    
        channel         ,i4     ;Master file channel
    
        idi_criteria    ,i4     ;Search criteria input window
        idi_results     ,i4     ;Search list input window ID
        clsid           ,i4     ;Search list class
        idl_results     ,i4     ;Search results list
        req             ,i4     ;List processor request flag
        control         ,i4     ;Search results list AX control ID
        idt_search      ,i4     ;Search criteria / results tabset
        headers         ,i4     ;# of search list header lines
        footers         ,i4     ;# of search list footer lines
    
        idi_maint       ,[10]i4 ;Maintenance window ID's
        idt_maint       ,i4     ;Maintenance tabset ID
    
        count           ,i4     ;Local counter
        tabcount        ,i4     ;Number of pages in tabset
        nullitem        ,i4     ;Current list item is null
    
        rows            ,i4     ;Height of window
        maxrows         ,i4     ;Maximum height of any window
    
        cols            ,i4     ;Width of window
        maxcols         ,i4     ;Maximum width of any window
    
        creating        ,i4     ;Creating a new record
    
        set_number      ,i4     ;Input set number
    
        no_amend        ,i4     ;Suppress "Amend" (view only)
        no_create       ,i4     ;Suppress "New" button
        no_delete       ,i4     ;Suppress "Delete" button

        wndname         ,a15    ;Window name
        setname         ,a5     ;Name of current input set
        wintitle        ,a50    ;Window title
        keynums         ,[10]d2 @wintitle   ;Array of search key numbers extracted from window title
        keynum          ,d2     ;Current key to use
        keyval          ,a80    ;Key value to match on
        winattr         ,2d3    ;Window title attributes
        keyfldname      ,a30    ;Input field name
        msgtext         ,a80    ;Message text

    endrecord

proc

    ;Initialize data
    clear employee, employee_save, employee_input, criteria, last_criteria
    init local_data
    ok=true

    ;Validate required parameters

    if (!a_base_title)
    begin
        xcall u_msgbox("Parameter 1 (base window title) was blank.",D_MOK+D_MICONSTOP,"Error")
        clear ok
    end

    ;Process optional parameters

    if (ok)
    begin

        if (^passed(a_lst_header)&&a_lst_header)
            headers=1

        if (^passed(a_lst_footer)&&a_lst_footer)
            footers=1

        if (^passed(a_no_create)&&a_no_create)
            no_create = TRUE

        if (^passed(a_no_delete)&&a_no_delete)
            no_delete = TRUE

        if (^passed(a_no_amend)&&a_no_amend)
        begin
            no_amend = TRUE
            no_create = TRUE
            no_delete = TRUE
        end

    end

    xcall e_enter

    ;Open master file (if not passed an open channel to the file)

    if (^passed(a_channel)&&a_channel&&%chopen(a_channel)) then
        channel = a_channel
    else
    begin

        if (%employee_io(IO_OPEN_UPD,channel)!=IO_OK)
        begin
            xcall u_msgbox("Failed to open file DAT:employee.ism",D_MOK+D_MICONSTOP,"Error")
            clear ok
        end
    end

    ;Build the search tabset

    if (ok)
    begin

        ;Load search criteria input window
        xcall i_ldinp(idi_criteria,,"EMPLOYEE_CTA",D_NOPLC,,error)
        if (error) then
        begin
            xcall u_msgbox("Failed to load input window EMPLOYEE_CTA.",D_MOK+D_MICONSTOP,"Error")
            ok=false
        end
        else
        begin
            ;Get window dimensions
            rows = %w_info(WIF_ROWS,idi_criteria)
            cols = %w_info(WIF_COLS,idi_criteria)

            ;Extract key numbers, set title & disable fields
            xcall w_info(WI_TITLE,idi_criteria,wintitle,winattr)
            xcall w_brdr(idi_criteria,WB_TITLE,"Criteria")
            xcall i_disable(D_SET,idi_criteria,"DATA")
            xcall i_enable(D_FLDS,idi_criteria,"FIELD1")
            xcall i_next(idi_criteria,,"FIELD1")
        end

        ;Create search results list
        if (ok)
        begin

            ;Load list input window
            if (ok)
            begin
                xcall i_ldinp(idi_results,,"EMPLOYEE_LUP",D_NOPLC,,error)
                if (error) then
                begin
                    xcall u_msgbox("Failed to load input window EMPLOYEE_LUP.",D_MOK+D_MICONSTOP,"Error")
                    clear ok
                end
                else
                    xcall w_brdr(idi_results,WB_TITLE,"Results")
            end

            ;Create list class
            if (ok)
            begin
                xcall l_class(clsid,"TKM_SRCHCLASS",2,2,15,headers,,footers,1,,,"employee_mntload","ACTIVEX",error)
                if (error)
                begin
                    xcall u_msgbox("Failed to create list class TKM_SRCHCLASS",D_MOK+D_MICONSTOP,"Error")
                    clear ok
                end
            end

            ;Create list
            if (ok)
            begin
                xcall l_create(idl_results,idi_results,employee,,"TKM_SRCHCLASS",,,D_NOPLC,,,,error)
                if (error)
                begin
                    xcall u_msgbox("Failed to create search list",D_MOK+D_MICONSTOP,"Error")
                    clear ok
                end

            end

            ;Configure list
            if (ok)
            begin

                ;Header
                if (headers)
                    xcall l_sect(idl_results,a_lst_header,D_HEADER)

                ;Footer
                if (footers)
                    xcall l_sect(idl_results,a_lst_footer,D_FOOTER)

                ;Customize AX control parameters
                xcall l_status(idl_results, D_LAXCTRL, control)
                xcall ax_set(control,"RowMode",1)
                xcall ax_set(control,"LightItemColor",RGB_VALUE(255,255,180))
                xcall ax_set(control,"SelBackColor",RGB_VALUE(0,0,180))

            end

        end

        ;Create search tabset

        if (ok)
        begin

            ;Create tab container and add pages

            idt_search=%ts_tabset(DTS_CREATE,"TKM_SEARCH",rows,cols)
            xcall ts_tabset(DTS_WINDOW,idt_search,idi_criteria,"employee_mntcta",,"Specify search criteria")
            xcall ts_tabset(DTS_LIST,  idt_search,idl_results, "employee_mntlst",,"View search results")

            ;Set tab container title

            xcall w_brdr(idt_search,WB_TITLE,%atrim(a_base_title) + " Search")

            ;Add buttons to tab container

            xcall ts_tabset(DTS_BUTTON,idt_search,"SEARCH",DSB_TEXT,"Search")

            if (!no_create)
                xcall ts_tabset(DTS_BUTTON,idt_search,"CREATE",DSB_TEXT,"Create")

            if (no_amend) then
                xcall ts_tabset(DTS_BUTTON,idt_search,"AMEND", DSB_TEXT,"View")
            else
                xcall ts_tabset(DTS_BUTTON,idt_search,"AMEND", DSB_TEXT,"Amend")

            if (!no_delete)
                xcall ts_tabset(DTS_BUTTON,idt_search,"DELETE",DSB_TEXT,"Delete")

            xcall ts_tabset(DTS_BUTTON,idt_search,"CANCEL",DSB_TEXT,"Close")
            xcall ts_tabset(DTS_BUTTONSET,idt_search,,,DSB_END,"SEARCH")

            if (wndevent_close)
            begin
                xcall u_wndevents(D_ASSIGN,wndevent_close,idt_search)
                if (^passed(a_icon)&&a_icon)
                    xcall u_icon(D_ICONSET,a_icon,1,idt_search)
            end

        end

    end

    ;Build the maintenance tabset
    if (ok)
    begin

        ;Load input windows
        repeat
        begin

            tabcount+=1

            if (tabcount>10)
            begin
                tabcount-=1
                xcall u_msgbox("Too many input windows, using first 10.",D_MOK+D_MICONEXCLAM,"Warning")
                exitloop
            end

            wndname = "EMPLOYEE" + %string(tabcount)

            xcall i_ldinp(idi_maint[tabcount],,wndname,,,error)
            if (error) then
            begin

                if (tabcount==1) then
                begin
                    xcall s_bld(msgtext,,"Failed to load window %a.",wndname)
                    xcall u_msgbox(msgtext,D_MOK+D_MICONSTOP,"Error")
                    ok=false
                end
                else
                    tabcount-=1
                exitloop

            end
            else
            begin

                ;Make sure the first set is called "ALL"
                xcall i_setinf(idi_maint[tabcount],setname="",1)
                if (setname!="ALL ")
                begin
                    xcall s_bld(msgtext,,"First SET in window %a should be ALL.  It is actually %a.",wndname,setname)
                    xcall u_message(msgtext,D_MOK+D_MICONSTOP)
                    ok = FALSE
                    exitloop
                end

                ;For first window, make sure we have key and data sets
                if (tabcount==1)
                begin

                    xcall i_setinf(idi_maint[tabcount],setname="",2)
                    if (setname!="KEY ")
                    begin
                        xcall s_bld(msgtext,,"Second SET in window %a should be KEY.  It is actually %a.",wndname,setname)
                        xcall u_message(%atrim(msgtext))
                        ok = FALSE
                    end

                    xcall i_setinf(idi_maint[tabcount],setname="",3)
                    if (setname!="DATA ")
                    begin
                        xcall s_bld(msgtext,,"Third SET in window %a should be DATA.  It is actually %a.",wndname,setname)
                        xcall u_message(%atrim(msgtext))
                        ok = FALSE
                    end

                    if (!ok)
                        exitloop

                end

                ;Get window dimensions

                if ((rows=%w_info(WIF_ROWS,idi_maint[tabcount])) > maxrows )
                    maxrows=rows

                if ((cols=%w_info(WIF_COLS,idi_maint[tabcount])) > maxcols)
                    maxcols=cols

                ;For window 1 make sure there are no drill or change methods on the key field
                if (tabcount==1)
                begin
                    xcall i_setinf(idi_maint[tabcount],"KEY",set_number,,gs_fldset)
                    clear keyfldname
                    xcall i_fldinf(idi_maint[tabcount],keyfldname,gs_setfldi(1),,gs_inpfld)
                    xcall i_fldmod(idi_maint[tabcount],keyfldname,,,D_OFF,D_FLD_DRILL,D_FLD_CHANGE)
                end

            end

        end

        if (ok)
        begin

            ;Create tabset
            idt_maint=%ts_tabset(DTS_CREATE,"TKM_MAINT",maxrows,maxcols)

            ;Add tab pages
            for count from 1 thru tabcount
                xcall ts_tabset(DTS_WINDOW,idt_maint,idi_maint[count],"employee_mntinp")

            ;Add buttons
            xcall ts_tabset(DTS_BUTTON,idt_maint,"OK",DSB_TEXT,"OK")
            xcall ts_tabset(DTS_BUTTON,idt_maint,"CANCEL",DSB_TEXT,"Cancel")
            xcall ts_tabset(DTS_BUTTONSET,idt_maint,,,DSB_END)

            ;Set title
            xcall w_brdr(idt_maint,WB_TITLE,%atrim(a_base_title) + " Maintenance")

            if (wndevent_close)
            begin
                xcall u_wndevents(D_ASSIGN,wndevent_close,idt_maint)
                if (^passed(a_icon)&&a_icon)
                    xcall u_icon(D_ICONSET,a_icon,1,idt_maint)
            end
        end

    end

    ;Process search tabset
    if (ok)
    begin

        xcall position_window(idt_search)
        criteria = "1"
        xcall i_display(idi_criteria,"ALL",criteria)
        xcall i_next(idi_criteria,"ALL","FIELD1")
        keynum = keynums[1]
        clear keyval

        repeat
        begin

            xcall ts_process(idt_search,idt_search,channel,criteria,
            &                employee,keynums,keynum,keyval,last_criteria,
            &                no_create,no_delete)

            using g_entnam select
            ("SEARCH"),
            begin
                ;Criteria page was active, go to results page
                xcall ts_tabset(DTS_ACTIVE,idt_search,2)
            end
            ("AMEND"),
            begin
                call check_null
                if (!nullitem)
                begin
                    clear creating
                    call maintain
                end
            end
            ("CREATE"),
            begin
                creating = TRUE
                call maintain
            end
            ("DELETE"),
            begin
                call check_null
                if (!nullitem)
                    call delete
            end
            ("CANCEL"),
                exitloop
            ("R_"),
                xcall ReplicatorMenuItem(g_entnam)
            endusing

        end

    end

    xcall e_exit

    xreturn

check_null,

    xcall l_status(idl_results,D_LNULL,nullitem)
    if (nullitem)
    begin
        xcall u_msgbox("No records match your search criteria.\nTry different search criteria.",D_MOK+D_MICONINFO,"No Matches")
        xcall ts_tabset(DTS_ACTIVE,idt_search,1)
    end

    return

;---------------------------------------------------------------------------------------------------
;
maintain,

    ok=TRUE
    clear employee_input

    ;Save data as it currently appears in search results list
    employee_save = employee

    if (!creating)
    begin
        ;Read record from file to lock and ensure latest copy
        if (%employee_io(IO_READ,channel,%keyval(channel,employee,0),0,employee,IO_LOCK)==IO_OK) then
        begin
            ;Save data as read from file
            employee_save = employee
        end
        else
        begin
            ;Read failed
            xcall u_msgbox("Unable to lock record.",D_MOK+D_MICONEXCLAM)
            employee = employee_save
            ok=FALSE
        end
    end

    if (ok)
    begin

        if (creating) then
        begin
            ;Enable key set on page 1
            xcall i_enable(D_SET,idi_maint[1],setname="KEY")

        end
        else
        begin
            ;Load the data into the input record
            employee_input = employee
            ;Disable key set on pae 1
            xcall i_disable(D_SET,idi_maint[1],setname="KEY")
        end

        ;Load data into input forms
        for count from 1 thru tabcount
        begin
            xcall i_init(idi_maint[count],"ALL")
            if (!creating)
            begin
                xcall i_display(idi_maint[count],"ALL",employee_input)
                xcall i_next(idi_maint[count],"ALL","*FRST*")
                xcall display_local_fields(idi_maint[count],employee_input)
                if (no_amend)
                    xcall i_disable(D_SET,idi_maint[count],"ALL")
            end
        end

        ;Make sure tab 1 is displayed
        xcall ts_tabset(DTS_ACTIVE,idt_maint,1)

        ;Place maintenance tabset on screen
        xcall position_window(idt_maint,,idt_search,2,5)

        ;Process maintenance tabset
        repeat
        begin

            xcall ts_process(idt_maint,employee_input)

            using g_entnam select

            ("OK"),
            begin

                ;Validate required fields
                ok=TRUE
                for count from 1 thru tabcount
                begin
                    if (!%i_checkdata(idi_maint[count],"ALL",employee_input))
                    begin
                        xcall ts_tabset(DTS_ACTIVE,idt_maint,count)
                        ok=FALSE
                        exitloop
                    end
                end

                ;Back to input if required fields are missing
                if (!ok)
                    nextloop

                call save_record

                if (ok)
                    exitloop

            end

            ("CANCEL"),
            begin
                ;Drop the record lock
                unlock channel
                employee = employee_save
                exitloop
            end

            ("R_"),
                xcall ReplicatorMenuItem(g_entnam)

            endusing

        end

        xcall u_window(D_REMOVE,idt_maint)

    end

    return


save_record,

    ok=TRUE

    ;Load data into master file record
    employee = employee_input

    if (creating) then
    begin

        ;CREATE NEW RECORD

        if ((error=%employee_io(IO_CREATE,channel,,,employee))==IO_OK) then
        begin

            ;If we're on the search results list page
            if (%ts_tabset(DTS_ACTIVE,idt_search)==2)
            begin
                ;Add the new record to the list
                xcall l_process(idl_results,req=D_LAPPEND,employee_save)
                xcall l_process(idl_results,req=D_LNOP,employee)
                xcall i_display(idi_results,,employee)
            end

        end
        else
        begin

            if (error==IO_DUP_KEY) then
            begin
                ;Back to maintenance to change primary key
                xcall u_msgbox("Record already exists",D_MOK+D_MICONINFO)
                xcall i_init(idi_maint[1],"ALL",employee_input,keyfldname)
                xcall i_next(idi_maint[1],"ALL",keyfldname)
                xcall ts_tabset(DTS_ACTIVE,idt_maint,1)
                ok=false
            end
            else
            begin
                xcall u_msgbox("Failed to save new record",D_MOK+D_MICONINFO)
            end
        end

    end
    else
    begin

        ;AMEND EXISTING RECORD

        ;Update record in file
        if (%employee_io(IO_UPDATE,channel,,,employee)!=IO_OK) then
        begin
            xcall u_msgbox("Unable to update record.",D_MOK+D_MICONEXCLAM)
            employee = employee_save
        end
        else
            xcall i_display(idi_results,,employee)
    end

    return

delete,

    ;Save data as it currently appears in search results list
    employee_save = employee

    ;Read record from file to lock and ensure latest copy
    if (%employee_io(IO_READ,channel,%keyval(channel,employee,0),0,employee,IO_LOCK)==IO_OK) then
    begin
        xcall s_bld(msgtext,,"Delete %a %d ?",a_base_title,%keyval(channel,employee,0))
        if (%u_msgbox(msgtext,D_MYESNO+D_MICONQUESTION+D_MDEFBUTTON2,"Confirm")==D_MIDYES)
        begin
            if (%employee_io(IO_DELETE,channel)==IO_OK) then
                xcall l_queue(idl_results,D_LDELITEM)
            else
            begin
                employee = employee_save
                xcall u_msgbox("Failed to delete record.",D_MOK+D_MICONEXCLAM)
            end
        end
    end
    else
    begin
        employee = employee_save
        xcall u_msgbox("Unable to lock record.",D_MOK+D_MICONEXCLAM)
    end

    return

endsubroutine

;===================================================================================================
;
subroutine employee_mntcta
    required in    a_inpid          ,n      ;Criteria input window ID
    required in    a_tabset         ,n      ;Tabset ID
    required in    a_channel        ,n      ;Master file channel
    required inout a_criteria       ,a      ;Criteria record
    required in    a_employee       ,a      ;Selected master file record
    required in    a_keynums        ,[*]n   ;Array of key numbers
    required inout a_keynum         ,n      ;Key number to use
    required inout a_keyval         ,a      ;Key value to match
    required inout a_last_criteria  ,a      ;Last used criteria
    required in    a_no_create      ,n      ;Supress "New" button
    required in    a_no_delete      ,n      ;Supress "Delete" button
    endparams

    .include "WND:tools.def"
    .include "WND:fldinf.def"

proc

    ;Setup UI for criteria window processing

    xcall b_enable(a_tabset,"SEARCH")
    xcall b_disable(a_tabset,"AMEND")

    if (!a_no_delete)
        xcall b_disable(a_tabset,"DELETE")

    xcall b_buttonset(a_tabset,,,,"SEARCH")

    ;Process the criteria input window

    repeat
    begin
        xcall i_input(a_inpid,"ALL",a_criteria,,,,D_NOTERM)
        if (g_setsts) then
            exitloop
        else
            xcall i_next(a_inpid,"ALL","*FRST*")

    end

    ;Set current key number
    a_keynum = a_keynums[^d(a_criteria(1:1))]

    ;Extract partial key value
    xcall i_fldinf(a_inpid,"FIELD"+a_criteria(1:1),,,gs_inpfld)
    a_keyval = a_criteria(gs_pos:gs_siz)

    xreturn

endsubroutine

;===================================================================================================
;This is the change method for the search mode field on the criteria page
;The criteria window that the calling passes must specify this as a change
;method on the required MODE field.  The routine enables and disables the
;appropriate filter field for the currently selected search mode (key).

function employee_mntmode ,^val ,reentrant
    a_data_entered      ,a      ;Data as entered by the user.
    a_data_stored       ,a      ;Data as stroed in variable
    a_pending_status    ,n      ;Result of Toolkit's field validations.
    .include "WND:inpinf.def"   ;Input information structure
    a_criteria          ,a      ;Input data area
    endparams

    .include "WND:tools.def"

    stack record
        status          ,i4
        newfield        ,a10
    endrecord

proc

    status = a_pending_status

    ;Delete current data field content
    xcall i_init(inp_wndid,"DATA")

    ;Clear same data from input record
    clear a_criteria(2,%len(a_criteria))

    ;Disable previous and enable new data field
    newfield = "FIELD" + a_data_stored(1:1)
    xcall i_disable(D_SET,inp_wndid,"DATA")
    xcall i_enable(D_FLDS,inp_wndid,newfield)

    ;Activate new data field
    xcall i_next(inp_wndid,,newfield)

    freturn status

endfunction

;===================================================================================================
;This routine processes the list on the search results tab.
;
subroutine employee_mntlst
    required in    a_lstid          ,n      ;Search results list ID
    required in    a_tabset         ,n      ;Tabset ID
    required in    a_channel        ,n      ;Master file channel
    required in    a_criteria       ,a      ;Criteria record
    required in    a_employee       ,a      ;Selected master file record
    required in    a_keynums        ,[*]n   ;Array of key numbers
    required in    a_keynum         ,n      ;Key number to use
    required in    a_keyval         ,a      ;Key value to match
    required inout a_last_criteria  ,a      ;Last used criteria
    required in    a_no_create      ,n      ;Supress "New" button
    required in    a_no_delete      ,n      ;Supress "Delete" button
    endparams

    .include "WND:tools.def"

    stack record
        req                 ,i4     ;List processor request
    endrecord

proc

    ;Configure UI for search results list processing

    ;xcall ui_okcancel(D_ON)

    xcall b_disable(a_tabset,"SEARCH")
    xcall b_enable(a_tabset,"AMEND")

    if (!a_no_delete)
        xcall b_enable(a_tabset,"DELETE")

    xcall b_buttonset(a_tabset,,,,"AMEND")

    ;Process the search results

    if (a_criteria!=a_last_criteria)
        xcall l_restart(a_lstid)

    xcall l_select(a_lstid,req=D_LNOP,a_employee,,,,,,,,,,,,,a_channel,a_keynum,a_keyval)

    if (!g_select)
        xcall m_signal("AMEND")

    a_last_criteria = a_criteria

    ;xcall ui_okcancel(D_OFF)

    xreturn

endsubroutine

;===================================================================================================
;This is the load method for the search results list.
;
subroutine employee_mntload

    ;Arguments
    a_listid        ,n      ;Search results list ID
    a_reqest        ,n      ;List processor request
    a_employee      ,a      ;Master file record
    a_inpid         ,n      ;Search results list input window
    a_disable       ,n      ;Current item disabled
    a_index         ,n      ;Item index being requested

    ;Method data
    a_channel       ,n      ;Master file channel
    a_keynum        ,n      ;Key number to use
    a_keyval        ,a      ;Key value to match

    endparams

    .include "WND:tools.def"
    .include "GENSRC:StructureIO.def"

proc

    ;If it's the first record, position to the correct starting position in
    ;the master file

    if (a_index==1)
    begin

        if (a_keyval) then
        begin
            ;Position to first match in specified key
            if (%employee_io(IO_FIND,a_channel,a_keyval,a_keynum,,,IO_PARTIAL)!=IO_OK)
                a_reqest=D_LEOF
        end
        else
        begin
            ;Position to first record in specified key
            if (%employee_io(IO_FIND_FIRST,a_channel,,a_keynum)!=IO_OK)
            begin
                xcall u_msgbox("No records found",D_MOK+D_MICONINFO)
                a_reqest=D_LEOF
            end
        end

    end

    if (a_reqest!=D_LEOF)
    begin

        ;Read next record in key sequence

        repeat
        begin
            if (%employee_io(IO_READ_NEXT,a_channel,,,a_employee)==IO_OK) then
            begin

                ;Ignore MCBA deleted records
                if (%instr(1,a_employee,']]]]'))
                    nextloop

                ;If matching a value, make sure we're still in range
                if (a_keyval&&(%keyval(a_channel,a_employee,a_keynum)!=%atrim(a_keyval)))
                begin
                    a_reqest = D_LEOF
                    exitloop
                end

                ;Got a metching record, return it
                xcall i_display(a_inpid,,a_employee)

                exitloop

            end
            else
            begin
                ;End of file, close the list
                a_reqest = D_LEOF
                exitloop
            end
        end

    end

    xreturn

endsubroutine

;===================================================================================================
;This is the input processor for the maintenance tab pages.
;
subroutine employee_mntinp

    inp_wndid           ,n  ;ID of input window on current tab page
    a_employee_input    ,a  ;Input record
    endparams
    
    .include "WND:tools.def"

proc

    ;Process the input window on the current tab page

    repeat
    begin
        xcall i_input(inp_wndid,"ALL",a_employee_input,,,,D_NOTERM)

        if (g_setsts) then
            exitloop
        else
            xcall i_next(inp_wndid,,"*FRST*")

    end

    xreturn

endsubroutine

